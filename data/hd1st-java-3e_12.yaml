- en: 'Chapter 10\. Numbers Matter: Numbers and Statics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。数字很重要：数字和静态
- en: '![image](Images/f0275-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0275-01.png)'
- en: '**Do the Math.** But there’s more to working with numbers than just doing primitive
    arithmetic. You might want to get the absolute value of a number, or round a number,
    or find the larger of two numbers. You might want your numbers to print with exactly
    two decimal places, or you might want to put commas into your large numbers to
    make them easier to read. And what about parsing a String into a number? Or turning
    a number into a String? Someday you’re gonna want to put a bunch of numbers into
    a collection like ArrayList that takes only objects. You’re in luck. Java and
    the Java API are full of handy number-tweaking capabilities and methods, ready
    and easy to use. But most of them are **static**, so we’ll start by learning what
    it means for a variable or method to be static, including constants in Java, also
    known as static *final* variables.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**做数学计算。** 但与其说数字只涉及基本算术，不如说有更多内容。您可能希望获取数字的绝对值，或四舍五入一个数字，或找到两个数字中较大的那个。您可能希望以确切的两位小数打印数字，或者您可能希望将逗号插入大数以使其更易于阅读。还有将字符串解析为数字？或者将数字转换为字符串？总有一天，您会想要将一堆数字放入仅接受对象的集合中，例如ArrayList。您很幸运。Java和Java
    API充满了方便的数字调整功能和方法，准备好且易于使用。但其中大多数都是**静态的**，所以我们将从学习变量或方法为静态的含义开始，包括Java中的常量，也称为静态*final*变量。'
- en: 'MATH methods: as close as you’ll ever get to a *global* method'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MATH方法：这是您能接近*全局*方法的方式
- en: 'Except there’s no global *anything* in Java. But think about this: what if
    you have a method whose behavior doesn’t depend on an instance variable value.
    Take the round() method in the Math class, for example. It does the same thing
    every time—rounds a floating-point number (the argument to the method) to the
    nearest integer. Every time. If you had 10,000 instances of class Math, and ran
    the round(42.2) method, you’d get an integer value of 42\. Every time. In other
    words, the method acts on the argument but is never affected by an instance variable
    state. The only value that changes the way the round() method runs is the argument
    passed to the method!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java中没有全局*任何东西*。但是想象一下：如果您有一个方法，其行为不依赖于实例变量的值。例如，考虑Math类中的round()方法。它每次都做同样的事情——将浮点数（方法的参数）四舍五入为最接近的整数。每一次都是如此。如果您有10000个Math类的实例，并运行round(42.2)方法，则会得到整数值42。换句话说，该方法作用于参数，但从不受实例变量状态的影响。唯一改变round()方法运行方式的是传递给方法的参数！
- en: Doesn’t it seem like a waste of perfectly good heap space to make an instance
    of class Math simply to run the round() method? And what about *other* Math methods
    like min(), which takes two numerical primitives and returns the smaller of the
    two? Or max(). Or abs(), which returns the absolute value of a number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将Math类的实例化仅仅为了运行round()方法看起来是对堆空间的浪费，对吗？那么其他像min()这样的Math方法呢？该方法接受两个数值原始类型参数，并返回较小的那个。或者max()方法。或者abs()方法，该方法返回数的绝对值。
- en: '***These methods never use instance variable values***. In fact, the Math class
    doesn’t *have* any instance variables. So there’s nothing to be gained by making
    an instance of class Math. So guess what? You don’t have to. As a matter of fact,
    you can’t.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '***这些方法从不使用实例变量的值***。事实上，Math类根本没有*任何*实例变量。因此，通过创建Math类的实例无济于事。所以你猜怎么着？实际上，你不能。'
- en: '**If you try to make an instance of class Math:**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您试图创建Math类的实例：**'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**You’ll get this error:**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**您将获得此错误：**'
- en: '![image](Images/f0276-02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0276-02.png)'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Methods in the Math class don’t use any instance variable values. And because
    the methods are “static,” you don’t need to have an instance of Math. All you
    need is the Math class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Math类中的方法不使用任何实例变量的值。并且因为这些方法是“静态”的，您不需要Math的实例。只需要Math类即可。
- en: '![image](Images/f0276-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0276-01.png)'
- en: The difference between regular (non-static) and static methods
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规（非静态）和静态方法之间的区别
- en: Java is object-oriented, but once in a while you have a special case, typically
    a utility method (like the Math methods), where there is no need to have an instance
    of the class. The keyword **`static`** lets a method run ***without any instance
    of the class***. A static method means “behavior not dependent on an instance
    variable, so no instance/object is required. Just the class.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java是面向对象的，但偶尔会有特例，通常是实用方法（如Math方法），其中没有必要创建类的实例。关键字**`static`**允许方法在***没有类的任何实例的情况下运行***。静态方法意味着“行为不依赖于实例变量，因此不需要实例/对象。只需要类。”
- en: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
- en: What it means to have a class with static methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是具有静态方法的类
- en: Often (although not always), a class with static methods is not meant to be
    instantiated. In [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*, we talked about abstract classes, and how marking a class
    with the **`abstract`** modifier makes it impossible for anyone to say “new” on
    that class type. In other words, ***it’s impossible to instantiate an abstract
    class.***
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（尽管并非总是如此），具有静态方法的类不打算被实例化。在[第8章](ch08.xhtml#serious_polymorphism_interfaces_and_abst)《严肃的多态性》中，我们讨论了抽象类，并且标记一个类为**`abstract`**会使任何人无法在该类类型上使用“new”。换句话说，***无法实例化抽象类。***
- en: But you can restrict other code from instantiating a *non*-abstract class by
    marking the constructor **`private`**. Remember, a *method* marked private means
    that only code from within the class can invoke the method. A *constructor* marked
    private means essentially the same thing—only code from within the class can invoke
    the constructor. Nobody can say “new” from *outside* the class. That’s how it
    works with the Math class, for example. The constructor is private; you cannot
    make a new instance of Math. The compiler knows that your code doesn’t have access
    to that private constructor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以通过将构造函数标记为**`private`**来限制其他代码实例化一个*非*抽象类。记住，标记为私有的*方法*意味着只有类内的代码才能调用该方法。标记为私有的*构造函数*基本上意味着相同的事情——只有类内的代码才能调用构造函数。从*外部*类中不能使用“new”。这就是例如Math类的工作原理。构造函数是私有的；你不能创建Math的新实例。编译器知道你的代码不能访问那个私有构造函数。
- en: This does *not* mean that a class with one or more static methods should never
    be instantiated. In fact, every class you put a main() method in is a class with
    a static method in it!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这*并不*意味着具有一个或多个静态方法的类永远不应该被实例化。事实上，你将main()方法放在的每个类中都是有一个静态方法的类！
- en: Typically, you make a main() method so that you can launch or test another class,
    nearly always by instantiating a class in main and then invoking a method on that
    new instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会创建一个main()方法，以便可以启动或测试另一个类，几乎总是通过在main中实例化一个类，然后调用该新实例的方法。
- en: So you’re free to combine static and non-static methods in a class, although
    even a single non-static method means there must be *some* way to make an instance
    of the class. The only ways to get a new object are through “new” or deserialization
    (or something called the Java Reflection API that we don’t go into). No other
    way. But exactly *who* says new can be an interesting question, and one we’ll
    look at a little later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以自由地在一个类中组合静态和非静态方法，尽管即使有一个单独的非静态方法，也必须有*某种*方法来创建类的实例。获取新对象的唯一方法是通过“new”或反序列化（或称为Java反射API的东西，我们不深入讨论）。没有其他方式。但*谁*说new可能是一个有趣的问题，我们稍后在本章中会详细讨论。
- en: Static methods can’t use non-static (instance) variables!
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法也不能使用非静态（实例）变量！
- en: Static methods run without knowing about any particular instance of the static
    method’s class. And as you saw on the previous pages, there might not even *be*
    any instances of that class. Since a static method is called using the *class*
    (***Math***.random()) as opposed to an *instance reference* (***t2***.play()),
    a static method can’t refer to any instance variables of the class. The static
    method doesn’t know *which* instance’s variable value to use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法在不知道静态方法类的任何特定实例的情况下运行。正如你在前几页看到的，可能甚至*没有*那个类的任何实例。由于静态方法是使用*类*（***Math***.random()）而不是*实例引用*（***t2***.play()）来调用的，静态方法不能引用类的任何实例变量。静态方法不知道使用哪个实例的变量值。
- en: '**If you try to compile this code:**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你尝试编译这段代码：**'
- en: '![image](Images/f0279-01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-01.png)'
- en: '**You’ll get this error:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**你将会得到这个错误：**'
- en: '![image](Images/f0279-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-02.png)'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to use an instance variable from inside a static method, the compiler
    thinks, “I don’t know which object’s instance variable you’re talking about!”
    If you have ten Duck objects on the heap, a static method doesn’t know about any
    of them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在静态方法内部使用实例变量，编译器会认为：“我不知道你在说哪个对象的实例变量！”如果堆上有十个Duck对象，静态方法对任何一个都不了解。
- en: '![image](Images/f0279-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-03.png)'
- en: Static methods can’t use non-static methods, either!
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法也不能使用非静态方法！
- en: What do non-static methods do? ***They usually use instance variable state to
    affect the behavior of the method.*** A getName() method returns the value of
    the name variable. Whose name? The object used to invoke the getName() method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态方法通常用实例变量状态来影响方法的行为。***它们通常使用实例变量状态来影响方法的行为。*** 一个 `getName()` 方法返回 `name`
    变量的值。谁的名字？调用 `getName()` 方法的对象的名字。
- en: '**This won’t compile:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**这不会编译：**'
- en: '![image](Images/f0280-01.png)![image](Images/f0280-02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0280-01.png)![image](Images/f0280-02.png)'
- en: 'Static variable: value is the same for ALL instances of the class'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态变量：对于类的所有实例都是相同的值
- en: Imagine you wanted to count how many Duck instances are being created while
    your program is running. How would you do it? Maybe an instance variable that
    you increment in the constructor?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在程序运行时计算创建的Duck实例数。你会怎么做？也许是一个在构造函数中递增的实例变量？
- en: '![image](Images/f0281-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0281-01.png)'
- en: No, that wouldn’t work because duckCount is an instance variable, and starts
    at 0 for each Duck. You could try calling a method in some other class, but that’s
    kludgey. You need a class that’s got only a single copy of the variable, and all
    instances share that one copy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不，那行不通，因为`duckCount`是一个实例变量，并且每个鸭子的初始值都是0。你可以尝试在其他类中调用一个方法，但那样有些笨拙。你需要一个只有一个副本的类变量，而所有实例共享这一个副本。
- en: 'That’s what a static variable gives you: a value shared by all instances of
    a class. In other words, one value per *class*, instead of one value per *instance*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是静态变量能带给你的东西：一个所有类实例共享的值。换句话说，一个*类*只有一个值，而不是一个*实例*一个值。
- en: '![image](Images/f0281-02.png)![image](Images/f0281-03.png)![image](Images/f0282-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0281-02.png)![image](Images/f0281-03.png)![image](Images/f0282-01.png)'
- en: '**Static variables are shared.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态变量是共享的。**'
- en: '**All instances of the same class share a single copy of the static variables.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**同一个类的所有实例共享静态变量的单个副本。**'
- en: 'instance variables: 1 per **instance**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量：每个**实例**一个
- en: 'static variables: 1 per **class**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量：每个**类**一个
- en: Initializing a static variable
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化静态变量
- en: Static variables are initialized when a *class is loaded*. A class is loaded
    because the JVM decides it’s time to load it. Typically, the JVM loads a class
    because somebody’s trying to make a new instance of the class, for the first time,
    or use a static method or variable of the class. As a programmer, you also have
    the option of telling the JVM to load a class, but you’re not likely to need to
    do that. In nearly all cases, you’re better off letting the JVM decide when to
    *load* the class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当*加载类*时，静态变量会被初始化。JVM决定何时加载类。通常，JVM加载一个类是因为有人试图首次创建该类的一个新实例，或使用该类的静态方法或变量。作为程序员，你也可以选择告诉JVM加载一个类，但你不太可能需要这样做。在几乎所有情况下，最好让JVM决定何时*加载*类。
- en: 'And there are two guarantees about static initialization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并且静态初始化有两个保证：
- en: Static variables in a class are initialized before any *object* of that class
    can be created.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的静态变量在该类的任何*对象*创建之前初始化。
- en: Static variables in a class are initialized before any *static method* of the
    class runs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的静态变量在类的任何*静态方法*运行之前初始化。
- en: '![image](Images/f0283-01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0283-01.png)'
- en: If you don’t explicitly initialize a static variable (by assigning it a value
    at the time you declare it), it gets a default value, so int variables are initialized
    to zero, which means we didn’t need to explicitly say playerCount = 0\. Declaring,
    but not initializing, a static variable means the static variable will get the
    default value for that variable type, in exactly the same way that instance variables
    are given default values when declared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不显式初始化一个静态变量（在声明时给它赋值），它会得到一个默认值，所以 int 变量会被初始化为零，这意味着我们不需要显式地说 `playerCount
    = 0`。声明但不初始化静态变量意味着静态变量会得到该变量类型的默认值，就像实例变量在声明时得到默认值一样。
- en: '![image](Images/f0283-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0283-02.png)'
- en: static final variables are constants
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`static final` 变量是常量'
- en: 'A variable marked **`final`** means that—once initialized—it can never change.
    In other words, the value of the static final variable will stay the same as long
    as the class is loaded. Look up Math.PI in the API, and you’ll find:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为**`final`**的变量意味着一旦初始化就不能更改。换句话说，静态final变量的值在类加载时会保持不变。在API中查找 `Math.PI`，你会发现：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variable is marked **`public`** so that any code can access it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被标记为**`public`**，以便任何代码都可以访问它。
- en: The variable is marked **`static`** so that you don’t need an instance of class
    Math (which, remember, you’re not allowed to create).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被标记为**`static`**，因此你不需要Math类的实例（记住，你是不允许创建的）。
- en: The variable is marked **`final`** because PI doesn’t change (as far as Java
    is concerned).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被标记为**`final`**，因为在Java看来PI不会改变。
- en: There is no other way to designate a variable as a constant, but there is a
    naming convention that helps you to recognize one. ***Constant variable names
    are usually in all caps!***
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他方法可以将变量指定为常量，但有一种命名约定可以帮助你识别常量。***常量变量通常全大写！***
- en: '**Initialize a *final* static variable:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化一个*final*静态变量：**'
- en: '![Images](Images/1.png) **At the time you declare it:**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **在你声明它的时候：**'
- en: '![image](Images/f0284-01.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0284-01.png)'
- en: '**OR**'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**或**'
- en: '![Images](Images/2.png) **In a static initializer:**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **在静态初始化器中：**'
- en: '![image](Images/f0284-02.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0284-02.png)'
- en: '**If you don’t give a value to a final variable in one of those two places:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你没有在这两个地方给最终变量赋值：**'
- en: '![image](Images/f0284-03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0284-03.png)'
- en: '**The compiler will catch it:**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器将捕获它：**'
- en: '![image](Images/f0284-04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0284-04.png)'
- en: final isn’t just for static variables...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: final不仅适用于静态变量...
- en: 'You can use the keyword **`final`** to modify non-static variables too, including
    instance variables, local variables, and even method parameters. In each case,
    it means the same thing: the value can’t be changed. But you can also use final
    to stop someone from overriding a method or making a subclass.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字**`final`**来修改非静态变量，包括实例变量、局部变量，甚至方法参数。在每种情况下，它的意思是一样的：该值无法被改变。但你也可以使用final来阻止某人重写一个方法或创建一个子类。
- en: '**non-static final variables**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**非静态最终变量**'
- en: '![image](Images/f0285-01.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0285-01.png)'
- en: '**final method**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终方法**'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**final class**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终类**'
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**A final variable means you can’t change its value.**'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**最终变量意味着你不能改变它的值。**'
- en: '**A final method means you can’t override the method.**'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**最终方法意味着你无法重写这个方法。**'
- en: '**A final class means you can’ extend the class (i.e., you can’t make a subclass).**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**最终类意味着你不能扩展这个类（即不能创建一个子类）。**'
- en: '![image](Images/f0285-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0285-03.png)'
- en: '![Images](Images/arr.png) **Answers in [“Sharpen your pencil”](#sharpen_your_pencil_left_parenthesisfrom).**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) 答案在[“磨尖你的铅笔”](#sharpen_your_pencil_left_parenthesisfrom)中。'
- en: Math methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math方法
- en: Now that we know how static methods work, let’s look at some static methods
    in class Math. This isn’t all of them, just the highlights. Check your API for
    the rest including cos(), sin(), tan(), ceil(), floor(), and asin().
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道静态方法是如何工作的，让我们来看看Math类中的一些静态方法。这并不是全部，只是一些亮点。查阅你的API以获取包括cos()、sin()、tan()、ceil()、floor()和asin()在内的其余方法。
- en: '![image](Images/f0288-01.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0288-01.png)'
- en: '**Math.abs()**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.abs()**'
- en: Returns a double that is the absolute value of the argument. The method is overloaded,
    so if you pass it an int, it returns an int. Pass it a double, it returns a double.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个double，该值是参数的绝对值。该方法是重载的，因此如果传入int，它返回int；传入double，它返回double。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Math.random()**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.random()**'
- en: Returns a double between (and including) 0.0 through (but not including) 1.0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个介于（包括）0.0到（但不包括）1.0之间的double。
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ve been using this method so far, but there’s also java.util.Random, which
    is a bit nicer to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用这种方法，但也有java.util.Random，它更好用一些。
- en: '**Math.round()**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.round()**'
- en: Returns an int or a long (depending on whether the argument is a float or a
    double) rounded to the nearest integer value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个四舍五入到最接近整数值的int或long（取决于参数是float还是double）。
- en: '![image](Images/f0289-01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0289-01.png)'
- en: '**Math.min()**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.min()**'
- en: Returns a value that is the minimum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个参数中的最小值。该方法被重载以接受int、long、float或double。
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Math.max()**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.max()**'
- en: Returns a value that is the maximum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个参数中的最大值。该方法被重载以接受int、long、float或double。
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Math.sqrt()**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.sqrt()**'
- en: Returns the positive square root of the argument. The method takes a double,
    but of course you can pass in anything that fits in a double.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数的正平方根。该方法接受一个double，当然你可以传入任何适合double类型的内容。
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wrapping a primitive
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装一个基本类型
- en: 'Sometimes you want to treat a primitive like an object. For example, collections
    like ArrayList only work with Objects:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望将一个基本类型视为对象。例如，像ArrayList这样的集合只能与对象一起使用：
- en: '![image](Images/f0290-01.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0290-01.png)'
- en: There’s a wrapper class for every primitive type, and since the wrapper classes
    are in the java.lang package, you don’t need to import them. You can recognize
    wrapper classes because each one is named after the primitive type it wraps, but
    with the first letter capitalized to follow the class naming convention.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每种原始类型都有一个包装类，由于这些包装类位于 java.lang 包中，您不需要导入它们。您可以通过每个包装类的命名来识别它们，每个包装类的命名都是以它包装的原始类型命名的，但是第一个字母大写以遵循类命名约定。
- en: 'Oh yeah, for reasons absolutely nobody on the planet is certain of, the API
    designers decided not to map the names *exactly* from primitive type to class
    type. You’ll see what we mean:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 哦对了，因为绝对没有人能确切知道的原因，API 设计者决定不将原始类型的名称*完全*映射到类类型。您会明白我们的意思：
- en: '![image](Images/f0290-02.png)![image](Images/f0290-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0290-02.png)![图片](Images/f0290-03.png)'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you need to treat a primitive like an object, wrap it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要像对象一样对待原始类型时，请将其包装起来。
- en: '![image](Images/f0290-04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0290-04.png)'
- en: 'Note: the picture at the top is a chocolate in a foil wrapper. Get it? Wrapper?
    Some people think it looks like a baked potato, but that works too.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：顶部的图片是包装在箔纸中的巧克力。懂了吗？包装器？有些人认为它看起来像烤土豆，但那也可以。
- en: '![image](Images/f0291-01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0291-01.png)'
- en: Java will Autobox primitives for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 将为您自动装箱原始类型
- en: In The Olden Days (pre–Java 5), we did have to do all this ourselves, manually
    wrapping and unwrapping primitives. Fortunately, now it’s all done for us *automatically*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在“古老的时代”（Java 5 之前），我们必须手动包装和解包原始类型。幸运的是，现在这一切都*自动*完成了。
- en: Let’s see what happens when we want to make an ArrayList to hold ints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们想要创建一个 ArrayList 来保存整数时会发生什么。
- en: '**An ArrayList of primitive ints**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个包含原始整数的 ArrayList**'
- en: '![image](Images/f0291-02.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0291-02.png)'
- en: Autoboxing works almost everywhere
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装箱几乎在所有地方都起作用
- en: Autoboxing lets you do more than just the obvious wrapping and unwrapping to
    use primitives in a collection...it also lets you use either a primitive or its
    wrapper type virtually anywhere one or the other is expected. Think about that!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装箱不仅让您可以进行明显的包装和解包以在集合中使用原始类型...它还允许您在几乎任何期望使用其中一个的地方使用原始类型或其包装器类型。想想看！
- en: '**Fun with autoboxing**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动装箱的乐趣**'
- en: '| **Method arguments** If a method takes a wrapper type, you can pass a reference
    to a wrapper or a primitive of the matching type. And of course the reverse is
    true—if a method takes a primitive, you can pass in either a compatible primitive
    or a reference to a wrapper of that primitive type. | ![image](Images/f0292-01.png)
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **方法参数** 如果方法接受一个包装器类型，您可以传递一个包装器的引用或匹配类型的原始值。当然反过来也成立——如果方法接受一个原始类型，您可以传递一个兼容的原始值或该原始类型的包装器的引用。
    | ![图片](Images/f0292-01.png) |'
- en: '| **Return values** If a method declares a primitive return type, you can return
    either a compatible primitive or a reference to the wrapper of that primitive
    type. And if a method declares a wrapper return type, you can return either a
    reference to the wrapper type or a primitive of the matching type. | ![image](Images/f0292-02.png)
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **返回值** 如果方法声明了原始返回类型，您可以返回与之兼容的原始值或该原始类型的包装器的引用。如果方法声明了包装器返回类型，您可以返回与之匹配的包装器类型的引用或匹配类型的原始值。
    | ![图片](Images/f0292-02.png) |'
- en: '| **Boolean expressions** Any place a boolean value is expected, you can use
    either an expression that evaluates to a boolean (4 > 2), a primitive boolean,
    or a reference to a Boolean wrapper. | ![image](Images/f0292-03.png) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **布尔表达式** 任何需要布尔值的地方，您都可以使用一个计算结果为布尔值的表达式（例如 4 > 2），一个原始布尔值，或者一个 Boolean
    包装器的引用。 | ![图片](Images/f0292-03.png) |'
- en: '| **Operations on numbers** This is probably the strangest one—yes, you can
    use a wrapper type as an operand in operations where the primitive type is expected.
    That means you can apply, say, the increment operator against a reference to an
    Integer object!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| **数字操作** 这可能是最奇怪的一点——是的，您可以在期望原始类型的操作中使用包装器类型作为操作数。这意味着您可以对一个 Integer 对象的引用应用增量运算符！'
- en: But don’t worry—this is just a compiler trick. The language wasn’t modified
    to make the operators work on objects; the compiler simply converts the object
    to its primitive type before the operation. It sure looks weird, though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但不用担心——这只是一个编译器技巧。语言没有修改使运算符在对象上工作；编译器只是在操作之前将对象转换为其原始类型。尽管看起来确实很奇怪。
- en: Integer i = new Integer(42); i++;
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Integer i = new Integer(42); i++;
- en: 'And that means you can also do things like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您也可以做一些事情，比如：
- en: Integer j = new Integer(5); Integer k = j + 3; | ![image](Images/f0293-01.png)
    |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Integer j = new Integer(5); Integer k = j + 3; | ![图片](Images/f0293-01.png)
    |
- en: '| **Assignments** You can assign either a wrapper or primitive to a variable
    declared as a matching wrapper or primitive. For example, a primitive int variable
    can be assigned to an Integer reference variable, and vice versa—a reference to
    an Integer object can be assigned to a variable declared as an int primitive.
    | ![image](Images/f0293-02.png) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **赋值** 你可以把一个包装类或原始类型赋给一个声明为匹配的包装类或原始类型的变量。例如，一个原始int变量可以赋给一个Integer引用变量，反之亦然——可以把一个Integer对象的引用赋给一个声明为int原始类型的变量。
    | ![图片](Images/f0293-02.png) |'
- en: '![Images](Images/arr.png) **Yours to solve.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **由你来解决。**'
- en: But wait! There’s more! Wrappers have static utility methods too!
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但等等！还有更多！包装类也有静态实用方法！
- en: Besides acting like a normal class, the wrappers have a bunch of really useful
    static methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像普通类一样运行外，包装类还有许多非常有用的静态方法。
- en: For example, the *parse* methods take a String and give you back a primitive
    value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*parse*方法接受一个字符串并返回一个原始值。
- en: '![image](Images/f0294-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0294-01.png)'
- en: '**Converting a String to a primitive value is easy:**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**把一个字符串转换成原始值很容易：**'
- en: '![image](Images/f0294-02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0294-02.png)'
- en: '**But if you try to do this:**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**但如果你尝试这样做：**'
- en: '![image](Images/f0294-03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0294-03.png)'
- en: '**You’ll get a runtime exception:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**你将会得到一个运行时异常：**'
- en: '![image](Images/f0294-04.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0294-04.png)'
- en: '**Every method or constructor that parses a String can throw a NumberFormatException****.
    It’s a runtime exception, so you don’t have to handle or declare it. But you might
    want to.**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个解析字符串的方法或构造函数都可能抛出NumberFormatException**。这是一个运行时异常，所以你不必处理或声明它。但你可能会想要处理它。'
- en: (We’ll talk about exceptions in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在[第13章](ch13.xhtml#risky_behavior_exception_handling)讨论异常，*风险行为*。）
- en: And now in reverse...turning a primitive number into a String
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在反过来...把原始数值转换成字符串
- en: You may want to turn a number into a String, for example when you want to show
    this number to a user or put it into a message. There are several ways to turn
    a number into a String. The easiest is to simply concatenate the number to an
    existing String.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想把一个数字转换成字符串，比如当你想向用户显示这个数字或将它放入消息中时。有几种方法可以把一个数字转换成字符串。最简单的方法是简单地将数字与现有字符串连接起来。
- en: '![image](Images/f0295-01.png)![image](Images/f0295-02.png)![image](Images/f0295-03.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0295-01.png)![图片](Images/f0295-02.png)![图片](Images/f0295-03.png)'
- en: Number formatting
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字格式化
- en: In Java, formatting numbers and dates doesn’t have to be coupled with I/O. Think
    about it. One of the most typical ways to display numbers to a user is through
    a GUI. You put Strings into a scrolling text area, or maybe a table. If formatting
    was built only into print statements, you’d never be able to format a number into
    a nice String to display in a GUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，格式化数字和日期不必与I/O耦合。想想看。向用户显示数字的最典型方式之一是通过GUI。你把字符串放入一个滚动文本区域，或者可能是一个表格。如果格式化仅仅内建到打印语句中，你永远不能把一个数字格式化成一个漂亮的字符串以显示在GUI中。
- en: The Java API provides powerful and flexible formatting using the Formatter class
    in java.util. But often you don’t need to create and call methods on the Formatter
    class yourself, because the Java API has convenience methods in some of the I/O
    classes (including printf()) and the String class. So it can be a simple matter
    of calling a static String.format() method and passing it the thing you want formatted
    along with formatting instructions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Java API提供了强大灵活的格式化功能，使用java.util中的Formatter类。但通常你不需要自己创建和调用Formatter类上的方法，因为Java
    API在一些I/O类（包括printf()）和String类中提供了便利方法。所以只需调用一个静态的String.format()方法，并传入要格式化的内容以及格式化指令就可以了。
- en: Of course, you do have to know how to supply the formatting instructions, and
    that takes a little effort unless you’re familiar with the ***printf()*** function
    in C/C++. Fortunately, even if you *don’t* know printf(), you can simply follow
    recipes for the most basic things (that we’re showing in this chapter). But you
    *will* want to learn how to format if you want to mix and match to get *anything*
    you want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要知道如何提供格式化指令，这需要一点努力，除非你熟悉C/C++中的***printf()***函数。幸运的是，即使你*不*了解printf()，你也可以简单地按照本章展示的最基本的东西的配方。但如果你想要混搭以获取*任何*你想要的东西，你*会*想要学习如何格式化。
- en: 'We’ll start here with a basic example and then look at how it works. (Note:
    we’ll revisit formatting again in [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr),
    *Saving Objects*.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个基本示例开始，然后看看它是如何工作的。（注意：我们将在[第16章](ch16.xhtml#saving_objects_left_parenthesisand_textr)，*保存对象*中再次讨论格式化。）
- en: '**Making big numbers more readable with underscores, a quick detour**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过下划线使大数字更易读，一个快速的绕路**'
- en: 'Before we get into formatting numbers, let’s take a small, useful detour. Sometimes
    you’ll want to declare variables with large initial values. Let’s look at three
    declarations that assign the same large value, a billion, to long primitives:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论数字格式化之前，让我们进行一个小而有用的绕路。有时候，你会想要声明带有大初始值的变量。让我们看看分配相同大值（十亿）给长整型变量的三个声明：
- en: '![image](Images/f0296-01.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0296-01.png)'
- en: '**Formatting a number to use commas**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**为数字添加逗号格式**'
- en: '![image](Images/f0296-02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0296-02.png)'
- en: Formatting deconstructed...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化解析...
- en: 'At the most basic level, formatting consists of two main parts (there is more,
    but we’ll start with this to keep it cleaner):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的级别上，格式化包括两个主要部分（还有更多，但我们将从这里开始，以保持更清晰）：
- en: '![Images](Images/1.png) **Formatting instructions**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **格式化说明**'
- en: You use special format specifiers that describe how the argument should be formatted.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你使用特殊的格式说明符来描述参数应该如何格式化。
- en: '![Images](Images/2.png) **The argument to be formatted.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **要格式化的参数。**'
- en: Although there can be more than one argument, we’ll start with just one. The
    argument type can’t be just *anything*...it has to be something that can be formatted
    using the format specifiers in the formatting instructions. For example, if your
    formatting instructions specify a *floating-point number*, you can’t pass in a
    Dog or even a String that looks like a floating-point number.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然可能有多个参数，但我们将从一个开始。参数类型不能仅仅是*任何东西*……它必须是能够使用格式指示中的格式说明符进行格式化的东西。例如，如果你的格式说明指定*浮点数*，你不能传入一只狗，甚至是看起来像浮点数的字符串。
- en: '![image](Images/f0297-01.png)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0297-01.png)'
- en: '**What do these instructions actually say?**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些说明实际上说了什么？**'
- en: “Take the second argument to this method, and format it as a **d**ecimal integer
    and insert **commas**.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: “取此方法的第二个参数，并将其格式化为**十**进制整数，并插入**逗号**。”
- en: '**How do they say that?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**他们是怎么说的？**'
- en: On the next page we’ll look in more detail at what the syntax “%,d” actually
    means, but for starters, any time you see the percent sign (%) in a format String
    (which is always the first argument to a format() method), think of it as representing
    a variable, and the variable is the other argument to the method. The rest of
    the characters after the percent sign describe the formatting instructions for
    the argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页中，我们将更详细地查看语法“%，d”实际上意味着什么，但首先，任何时候在格式字符串（始终是format()方法的第一个参数）中看到百分号（%）时，请认为它代表一个变量，而这个变量是方法的另一个参数。百分号后面的其余字符描述了参数的格式化说明。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: if you already know printf() from c/C++, you can probably just skim the
    next few pages. Otherwise, read carefully!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你已经了解了来自C/C++的printf()，可能只需略过接下来的几页。否则，请仔细阅读！
- en: The percent (%) says, “insert argument here” (and format it using these instructions)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百分号（%）表示：“在这里插入参数”（并使用这些说明进行格式化）
- en: The first argument to a format() method is called the format String, and it
    can actually include characters that you just want printed as-is, without extra
    formatting. When you see the % sign, though, think of the percent sign as a variable
    that represents the other argument to the method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: format()方法的第一个参数称为格式字符串，实际上它可以包含你只想原样打印的字符，而无需额外的格式化。不过，当你看到%符号时，认为百分号代表方法的另一个参数。
- en: '![image](Images/f0298-01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0298-01.png)'
- en: The “%” sign tells the formatter to insert the other method argument (the second
    argument to format(), the number) here, AND format it using the “.2f” characters
    after the percent sign. Then the rest of the format String, “bugs to fix,” is
    added to the final output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “%”符号告诉格式化程序在此处插入方法的另一个参数（format()的第二个参数，即数字），并使用在百分号后的“.2f”字符进行格式化。然后将格式字符串的其余部分“bugs
    to fix”添加到最终输出。
- en: '**Adding a comma**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加逗号**'
- en: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
- en: The format String uses its own little language syntax
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式字符串使用其自己的小语言语法
- en: You obviously can’t put just *anything* after the “%” sign. The syntax for what
    goes after the percent sign follows very specific rules, and describes how to
    format the argument that gets inserted at that point in the result (formatted)
    String.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不能在“%”符号后面随便放什么东西。紧随百分号后的语法遵循非常具体的规则，并描述了在结果（格式化）字符串中插入的参数如何格式化。
- en: 'You’ve already seen some examples:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过一些例子了：
- en: '**%,d** means “insert commas and format the number as a decimal integer.”'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**%,d** 表示“插入逗号并将数字格式化为十进制整数。”'
- en: and
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '**%.2f** means “format the number as a floating point with a precision of two
    decimal places.”'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**%.2f** 表示“将数字格式化为具有两位小数的浮点数。”'
- en: and
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '**%,.2f** means “insert commas and format the number as a floating point with
    a precision of two decimal places.”'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**%,.2f** 表示“插入逗号并将数字格式化为具有两位小数的浮点数。”'
- en: 'Really the question is: “How do I know what to put after the percent sign to
    get it to do what I want?” And that includes knowing the symbols (like “d” for
    decimal and “f” for floating point) as well as the order in which the instructions
    must be placed following the percent sign. For example, if you put the comma after
    the “d” like “%d,” instead of “%,d” it won’t work!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上问题是：“我怎么知道在百分号后面放什么才能让它做我想要的事情？”这包括知道符号（如“d”表示十进制和“f”表示浮点数）以及必须在百分号后放置说明的顺序。例如，如果你在“d”后面放逗号，像“%d,”
    而不是“%,d”，它是行不通的！
- en: 'Or will it? What do you think this will do:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者呢？你认为这会做什么：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (We’ll answer that on the next page.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在下一页回答这个问题。）
- en: The format specifier
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式说明符
- en: Everything after the percent sign up to and including the type indicator (like
    “d” or “f”) is part of the formatting instructions. After the type indicator,
    the formatter assumes the next set of characters is meant to be part of the output
    String, until or unless it hits another percent (%) sign. Hmmmm...is that even
    possible? Can you have more than one formatted argument variable? Put that thought
    on hold for right now; we’ll come back to it in a few minutes. For now, let’s
    look at the syntax for the format specifiers—the things that go after the percent
    (%) sign and describe how the argument should be formatted.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号后的一切，直到并包括类型指示符（如“d”或“f”），都是格式化说明的一部分。在类型指示符之后，格式化程序假定下一组字符应该是输出字符串的一部分，直到或除非它遇到另一个百分号（%）符号。嗯...这可能吗？你能有多个格式化参数变量吗？暂时把这个想法放一放；我们几分钟后再来讨论。现在，让我们看看格式说明符的语法——在百分号（%）后面的描述如何格式化参数。
- en: '**A format specifier can have up to five different parts (not including the
    “%”). Everything in brackets [ ] below is optional, so only the percent (%) and
    the type are required. But the order is also mandatory, so any parts you DO use
    must go in this order.**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式说明符最多可以有五个不同的部分（不包括“%”）。方括号 [ ] 中的所有内容都是可选的，因此只有百分号（%）和类型是必需的。但是顺序也是强制的，因此您使用的任何部分必须按照这个顺序排列。**'
- en: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
- en: The only required specifier is for TYPE
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一必需的说明符是 TYPE
- en: Although type is the only required specifier, remember that if you *do* put
    in anything else, type must always come last! There are more than a dozen different
    type modifiers (not including dates and times; they have their own set), but most
    of the time you’ll probably use %d (decimal) or %f (floating point). And typically
    you’ll combine %f with a precision indicator to set the number of decimal places
    you want in your output.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型是唯一必需的说明符，但要记住，如果你确实添加了其他内容，类型必须始终放在最后！有十多种不同的类型修饰符（不包括日期和时间；它们有自己的一套），但大多数时候你可能会使用
    %d（十进制）或 %f（浮点数）。通常你会将 %f 与精度指示器组合，以设置你想要的输出中的小数位数。
- en: '**The TYPE is mandatory, everything else is optional.**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**TYPE 是强制的，其他都是可选的。**'
- en: '![image](Images/f0301-01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0301-01.png)'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You must include a type in your format instructions, and if you specify things
    besides type, the type must always come last. Most of the time, you’ll probably
    format numbers using either “d” for decimal or “f” for floating point.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的格式指令中必须包含一个类型，如果除了类型还指定其他内容，则类型必须始终放在最后。大多数情况下，你可能会使用“d”表示十进制或“f”表示浮点数来格式化数字。
- en: The argument must be a byte, short, char, or int (including both primitive and
    wrapper types).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须是 byte、short、char 或 int（包括基本类型和包装类型）。
- en: What happens if I have more than one argument?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我有多个参数会发生什么？
- en: 'Imagine you want a String that looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你想要一个看起来像这样的字符串：
- en: “The rank is ***20,456,654*** out of ***100,567,890.24***.”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: “排名是***20,456,654***，总数是***100,567,890.24***。”
- en: But the numbers are coming from variables. What do you do? You simply add *two*
    arguments after the format String (first argument), so that means your call to
    format() will have three arguments instead of two. And inside that first argument
    (the format String), you’ll have two different format specifiers (two things that
    start with “%”). The first format specifier will insert the second argument to
    the method, and the second format specifier will insert the third argument to
    the method. In other words, the variable insertions in the format String use the
    order in which the other arguments are passed into the format() method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但数字是来自变量。你怎么办？在格式字符串（第一个参数）后面简单地添加*两个*参数，这意味着你的 format() 调用将有三个参数而不是两个。在这个第一个参数（格式字符串）中，你将有两个不同的格式化指定符（两个以“%”开头的东西）。第一个格式化指定符将插入方法的第二个参数，而第二个格式化指定符将插入方法的第三个参数。换句话说，格式字符串中的变量插入使用其他参数传递给
    format() 方法的顺序。
- en: '![image](Images/f0302-01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0302-01.png)'
- en: As you’ll see when we get to date formatting, you might actually want to apply
    different formatting specifiers to the same argument. That’s probably hard to
    imagine until you see how *date* formatting (as opposed to the *number* formatting
    we’ve been doing) works. Just know that in a minute, you’ll see how to be more
    specific about which format specifiers are applied to which arguments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论日期格式化时，你会看到，你可能确实想要对同一个参数应用不同的格式化指定符。在看到*日期*格式化（与我们之前做的*数字*格式化不同）是如何工作之前，这可能很难想象。只需知道一分钟后，你将看到如何更具体地指定哪些格式化指定符应用于哪些参数。
- en: Just one more thing...static imports
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只剩最后一件事……静态导入
- en: Static imports are a real mixed blessing. Some people love this idea, some people
    hate it. Static imports exist to make your code a little shorter. If you hate
    to type or hate long lines of code, you might just like this feature. The downside
    to static imports is that—if you’re not careful—using them can make your code
    a lot harder to read.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入实际上是一种真正的利弊并存。有些人喜欢这个想法，有些人讨厌。静态导入的存在是为了让你的代码稍微变短一些。静态导入的缺点是，如果不小心使用，它们会使你的代码更难阅读。
- en: The basic idea is that whenever you’re using a static class, a static variable,
    or an enum (more on those later), you can import them and save yourself some typing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，每当你使用静态类、静态变量或枚举（稍后详细介绍），你都可以导入它们，节省一些输入。
- en: '**Without static imports:**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有静态导入：**'
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Same code, with static imports:**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用静态导入的相同代码：**'
- en: '![image](Images/f0303-01.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0303-01.png)'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Use carefully: Static imports can make your code confusing to read. Always
    re-read your code after using a static import and think: “Will I understand this
    in six months time?”'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用：静态导入可能会使你的代码变得难以理解。在使用静态导入后，一定要重新阅读你的代码并思考：“六个月后我还能理解这个吗？”
- en: Fireside Chats
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fireside Chats
- en: '![image](Images/f0304-01.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0304-01.png)'
- en: 'Tonight’s Talk: **An instance variable takes cheap shots at a static variable**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 今晚的讨论主题：**实例变量针对静态变量出手**
- en: '| Instance Variable | Static Variable |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 实例变量 | 静态变量 |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| I don’t even know why we’re doing this. Everyone knows static variables are
    just used for constants. And how many of those are there? I think the whole API
    must have, what, four? And it’s not like anybody ever uses them. |  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 我甚至不知道我们为什么要这样做。每个人都知道静态变量只用于常量。那有多少常量？我觉得整个 API 只有四个？而且也没人真正用它们。 |  |'
- en: '|  | You really should check your facts. When was the last time you looked
    at the API? It’s frickin’ loaded with statics! It even has entire classes dedicated
    to holding constant values. There’s a class called SwingConstants, for example,
    that’s just full of them. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  | 你真应该核实你的事实。你上次查看 API 是什么时候？它简直是静态变量的天下！甚至还有专门用来保存常量值的整个类。例如，有一个叫做 SwingConstants
    的类，里面全是这些东西。 |'
- en: '| Full of it. Yeah, you can say that again. OK, so there are a few in the Swing
    library, but everybody knows Swing is just a special case. |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 说得太对了。是啊，你可以再说一遍。好吧，Swing 库中确实有一些，但每个人都知道 Swing 只是一个特例。 |  |'
- en: '|  | It might be a special case, but it’s a really important one! And what
    about the Color class? What a pain if you had to remember the RGB values to make
    the standard colors! But the color class already has constants defined for blue,
    purple, white, red, etc. Very handy. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  | 这可能是一个特殊情况，但确实非常重要！那么Color类呢？如果你要记住RGB值来制作标准颜色，那真是太麻烦了！但是Color类已经为蓝色、紫色、白色、红色等定义了常量。非常方便。
    |'
- en: '| Ok, but besides a few GUI things, give me an example of just one static variable
    that anyone would actually use. In the real world. |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，但除了一些GUI的东西，给我举个任何人实际会用到的静态变量的例子。在现实世界中。 |  |'
- en: '|  | How’s System.out for starters? The out in System.out is a static variable
    of the System class. You personally don’t make a new instance of the System; you
    just ask the System class for its out variable. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  | 那System.out怎么样？System.out中的out是System类的静态变量。你个人不会创建System的新实例；你只需请求System类的out变量。
    |'
- en: '| Well, that’s another special case. And nobody uses that except for debugging
    anyway. |  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，那是另一种特殊情况。反正除了调试，也没人会用到它。 |  |'
- en: '|  | Oh, like debugging isn’t important? And here’s something that probably
    never crossed your narrow mind—let’s face it, static variables are more efficient.
    One per class instead of one per instance. The memory savings might be huge! |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  | 哦，调试不重要吗？而且还有一件事你可能从未想过——静态变量更高效。每个类只需要一个，而不是每个实例一个。这可能节省大量内存！ |'
- en: '| Um, aren’t you forgetting something? |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 嗯，你难道忘了什么吗？ |  |'
- en: '|  | What? |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | 什么？ |'
- en: '| Static variables are about as un-OO as it gets!! Gee, why not just go take
    a giant backward step and do some procedural programming while we’re at it. |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 静态变量是完全不符合面向对象的最糟糕的东西！天哪，干嘛不退后一步，重新学习一些过程化编程呢。 |  |'
- en: '|  | What do you mean *un-*OO? |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  | 你说什么*非*-面向对象？ |'
- en: '| You’re like a global variable, and any programmer worth their sticker-covered
    laptop knows that’s usually a Bad Thing. |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 你就像一个全局变量，任何值得拥有贴满贴纸的笔记本电脑的程序员都知道，通常这不是一个好事情。 |  |'
- en: '|  | I am NOT a global variable. There’s no such thing. I live in a class!
    That’s pretty OO you know, a CLASS. I’m not just sitting out there in space somewhere;
    I’m a natural part of the state of an object; the only difference is that I’m
    shared by all instances of a class. Very efficient. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  | 我不是全局变量。根本就不存在这种东西。我生活在一个类中！这非常符合面向对象，你知道，一个类。我不是仅仅坐在某个地方；我是对象状态的自然组成部分；唯一的区别是我被所有类的实例共享。非常高效。
    |'
- en: '| Yeah, you live in a class, but they don’t call it *Class*-Oriented programming.
    That’s just stupid. You’re a relic. Something to help the old-timers make the
    leap to Java. |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 是的，你生活在一个类中，但他们不会称之为*类*-导向编程。那只是愚蠢。你是个遗留物。帮助老程序员们跨入Java的工具。 |  |'
- en: '|  | Alright just stop right there. THAT is definitely not true. Some static
    variables are absolutely crucial to a system. And even the ones that aren’t crucial
    sure are handy. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  | 好了，就在那停下。那绝对不是真的。某些静态变量对系统至关重要。即使那些并非必不可少的也确实非常方便。 |'
- en: '| Well, OK, every once in a while sure, it makes sense to use a static, but
    let me tell you, abuse of static variables (and methods) is the mark of an immature
    OO programmer. A designer should be thinking about *object* state, not *class*
    state. |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，确实偶尔这样做有意义，但让我告诉你，滥用静态变量（和方法）是一个不成熟的面向对象程序员的标志。设计者应该考虑*对象*状态，而不是*类*状态。
    |  |'
- en: '|  | Why do you say that? And what’s wrong with static methods? |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  | 你为什么这么说？静态方法有什么问题？ |'
- en: '| Static methods are the worst things of all, because it usually means the
    programmer is thinking procedurally instead of about objects doing things based
    on their unique object state. |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法是所有最糟糕的东西，因为这通常意味着程序员在考虑程序化，而不是根据对象独特的对象状态进行操作。 |  |'
- en: '|  | Sure, I know that objects should be the focus of an OO design, but just
    because there are some clueless programmers out there...don’t throw the baby out
    with the bytecode. There’s a time and place for statics, and when you need one,
    nothing else beats it. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  | 当然，我知道对象应该是面向对象设计的重点，但只因为有些不明事理的程序员存在...不要因婴儿般的字节码而弃之不顾。静态变量确实有其使用的时机和场合，而且当你需要它时，没有什么能代替它。
    |'
- en: '| Riiiiiight. Whatever you need to tell yourself. |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 是啊，你需要告诉自己什么。 |  |'
- en: Exercise
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: BE the compiler
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做成编译器
- en: '![image](Images/f0306-02.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-02.png)'
- en: '**The Java file on this page represents a complete program. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it? When it runs, what would be its output?**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**本页上的Java文件代表一个完整的程序。你的任务是扮演编译器，确定这个文件是否会编译。如果不能编译，你如何修复它？当它运行时，它的输出是什么？**'
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which of these is the output?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 哪一个是输出？
- en: '**Possible Output**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能的输出**'
- en: '![image](Images/f0306-04.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-04.png)'
- en: '**Possible Output**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能的输出**'
- en: '![image](Images/f0306-05.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-05.png)'
- en: '![Images](Images/arr.png) **Answers in [“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag).**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在[“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag)中。**'
- en: This chapter explored the wonderful, static world of Java. Your job is to decide
    whether each of the following statements is true or false.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Java静态世界的奇妙之处。你的任务是判断以下每个陈述是真还是假。
- en: True or False
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真还是假
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/hand.png)![image](Images/hand1.png)'
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Math类，第一步是创建它的一个实例。
- en: You can mark a constructor with the **`static`** keyword.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用关键字**`static`**标记一个构造方法。
- en: Static methods don’t have access to instance variable state of the “this” object.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法无法访问“this”对象的实例变量状态。
- en: It is good practice to call a static method using a reference variable.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引用变量调用静态方法是个好习惯。
- en: Static variables could be used to count the instances of a class.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态变量可以用来计算类的实例数。
- en: Constructors are called before static variables are initialized.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数在静态变量初始化之前被调用。
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAX_SIZE是一个静态final变量的好名称。
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态初始化块在类的构造函数运行之前运行。
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类被标记为final，它的所有方法必须被标记为final。
- en: A final method can be overridden only if its class is extended.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅当其类被扩展时，最终方法才能被覆盖。
- en: There is no wrapper class for boolean primitives.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔原语没有包装类。
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想把原始类型像对象一样对待时，使用包装器是个好方法。
- en: The parseXxx methods always return a String.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: parseXxx方法总是返回一个字符串。
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （与I/O无关的）格式化类位于java.format包中。
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfr-id0002).**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在[“True or False”](#true_or_false_left_parenthesisfr-id0002)中。**'
- en: Exercise Solution
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: Sharpen your pencil
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磨你的铅笔
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00021))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“Sharpen your pencil”](#sharpen_your_pencil-id00021)）
- en: '![image](Images/pencil.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/pencil.png)'
- en: 1, 4, 5, and 6 are legal.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 1、4、5和6是合法的。
- en: 2 doesn’t compile because the static method references a non-static instance
    variable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 2无法编译，因为静态方法引用了非静态实例变量。
- en: 3 doesn’t compile because the instance variable is final but hasn’t been initialized.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 3无法编译，因为实例变量是final的，但尚未初始化。
- en: BE the compiler
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the compiler
- en: (from [“BE the compiler”](#be_the_compiler-id00002))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“BE the compiler”](#be_the_compiler-id00002)）
- en: '[PRE12]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: StaticSuper is a constructor and must have ( ) in its signature. Notice that
    as the output below demonstrates, the static blocks for both classes run before
    either of the constructors run.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: StaticSuper是一个构造函数，必须在其签名中有( )。请注意，如下面的输出所示，两个类的静态块都在任何构造函数运行之前运行。
- en: '![image](Images/f0308-02.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0308-02.png)'
- en: True or False
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真还是假
- en: (from [“True or False”](#true_or_false))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“True or False”](#true_or_false)）
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Math类，第一步是创建它的一个实例。
- en: '| **False** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You can mark a constructor with the keyword “static.”
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用关键字“static”标记一个构造函数。
- en: '| **False** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Static methods don’t have access to an object’s instance variables.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法无法访问对象的实例变量。
- en: '| **True** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **正确** |'
- en: '|'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is good practice to call a static method using a reference variable.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引用变量调用静态方法是一个好习惯。
- en: '| **False** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Static variables could be used to count the instances of a class.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态变量可以用来计算类的实例数。
- en: '| **True** |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **正确** |'
- en: '|'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Constructors are called before static variables are initialized.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数在静态变量初始化之前被调用。
- en: '| **False** |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAX_SIZE是一个静态final变量的好名称。
- en: '| **True** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **正确** |'
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态初始化块在类的构造函数运行之前运行。
- en: '| **True** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **正确** |'
- en: '|'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类被标记为final，那么它的所有方法都必须被标记为final。
- en: '| **False** |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **假** |'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A final method can be overridden only if its class is extended.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在其类被扩展时，最终方法才能被覆盖。
- en: '| **False** |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **假** |'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: There is no wrapper class for boolean primitives.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔原始类型没有包装类。
- en: '| **False** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **假** |'
- en: '|'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想要将原始类型像对象一样对待时，会使用包装器。
- en: '| **True** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **真** |'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The parseXxx methods always return a String.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析Xxx方法总是返回一个字符串。
- en: '| **False** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **假** |'
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化类（与I/O分离）位于java.format包中。
- en: '| **False** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **假** |'
