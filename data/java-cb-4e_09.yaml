- en: 'Chapter 9\. Functional Programming Techniques: Functional Interfaces, Streams,
    and Parallel Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章\. 函数式编程技术：函数接口、流和并行集合
- en: 9.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.0 引言
- en: 'Java is an Object-Oriented (OO) language. You know what that is. Functional
    Programming (FP) has been attracting attention lately. There may not be quite
    as many definitions of FP as there are FP languages, but it’s close. Wikipedia’s
    definition of functional programming is as follows (from [*https://en.wikipedia.org/wiki/Functional_programming*](https://en.wikipedia.org/wiki/Functional_programming),
    viewed December 2013):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种面向对象（OO）语言。你知道这是什么。函数式编程（FP）近来引起了关注。关于FP的定义或许不如FP语言多，但也差不多。维基百科对函数式编程的定义如下（来源于[*https://en.wikipedia.org/wiki/Functional_programming*](https://en.wikipedia.org/wiki/Functional_programming)，2013年12月访问）：
- en: a programming paradigm, a style of building the structure and elements of computer
    programs, that treats computation as the evaluation of mathematical functions
    and avoids state and mutable data. Functional programming emphasizes functions
    that produce results that depend only on their inputs and not on the program state—i.e.
    pure mathematical functions. It is a declarative programming paradigm, which means
    programming is done with expressions. In functional code, the output value of
    a function depends only on the arguments that are input to the function, so calling
    a function f twice with the same value for an argument x will produce the same
    result f(x) both times. Eliminating side effects, i.e. changes in state that don’t
    depend on the function inputs, can make it much easier to understand and predict
    the behavior of a program, which is one of the key motivations for the development
    of functional programming.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种编程范式，一种构建计算机程序结构和元素的风格，将计算视为数学函数的评估，并避免状态和可变数据。函数式编程强调的是产生结果仅依赖于其输入而不依赖于程序状态的函数，即纯数学函数。这是一种声明式编程范式，意味着编程是通过表达式完成的。在函数式代码中，函数的输出值仅取决于作为函数输入的参数，因此对于相同参数x两次调用函数f将产生相同的结果f(x)。消除副作用，即不依赖于函数输入的状态变化，可以大大增强理解和预测程序行为的能力，这是开发函数式编程的关键动机之一。
- en: How can we benefit from the FP paradigm? One way would be to switch to using
    an FP language; some of the leading ones are Haskell,^([1](ch09.html#idm45290660939720))
    Idris, Ocaml, Erlang, Julia, and the LISP family. But most of those would require
    walking away from the Java ecosystem. You could consider using [Scala](http://www.scala-lang.org)
    or [Clojure](http://clojure.org), JVM-based languages that provide functional
    programming support in the context of an OO language. And there is [Kotlin](https://kotlinlang.org),
    the latest Java-like language for the JVM.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从FP范式中受益？一种方式是转向使用FP语言；一些主要的FP语言包括Haskell^([1](ch09.html#idm45290660939720))、Idris、Ocaml、Erlang、Julia和LISP家族。但大多数这些语言都要求放弃Java生态系统。你可以考虑使用[Scala](http://www.scala-lang.org)或[Clojure](http://clojure.org)，这些是基于JVM的语言，在面向对象语言的背景下提供函数式编程支持。还有[Kotlin](https://kotlinlang.org)，这是最新的类Java语言。
- en: 'But this is the *Java Cookbook*, so you can imagine we’re going to try to get
    as many benefits of functional programming as we can while remaining in the Java
    language. Some features of FP include the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是《Java Cookbook》，因此可以想象，我们将尝试在保持Java语言的同时获得尽可能多的函数式编程好处。FP的一些特征包括以下内容：
- en: Pure functions having no side effects and whose results depend only on their
    inputs and not on mutable state elsewhere in the program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数没有副作用，其结果仅取决于它们的输入，而不依赖于程序中其他地方的可变状态
- en: First-class functions (e.g., functions as data)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一级函数（例如，函数作为数据）
- en: Immutable data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据
- en: Extensive use of recursion and lazy evaluation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛使用递归和惰性评估
- en: '*Pure functions* are completely self-contained; their operation depends only
    on the input parameters and internal logic, not on any variable state in other
    parts of the program—indeed, there are no global variables, only global *constants*.
    Although this can be hard to accept for those schooled in imperative languages
    like Java, it does make it much easier to test and ensure program correctness!
    It means that, no matter what else is going on in the program (even with multiple
    threads), a method call like `computeValue(27)` will always, unconditionally,
    return the same value every time (with exceptions, of course, for things like
    the current time, random seeds, etc., which are global state).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数* 是完全自包含的；它们的操作仅取决于输入参数和内部逻辑，而不取决于程序其他部分的任何变量状态——事实上，没有全局变量，只有全局 *常量*。虽然这对于那些受过
    Java 等命令式语言教育的人来说可能难以接受，但这确实使测试和确保程序正确性变得更加容易！这意味着，无论程序中发生了什么（即使是多个线程），像 `computeValue(27)`
    这样的方法调用每次都会无条件地返回相同的值（当然，有一些例外情况，比如当前时间、随机种子等，这些是全局状态）。'
- en: We’ll use the terms *function* and *method* interchangeably in this chapter,
    although it’s not strictly correct. FP people use the term *function* in the mathematical
    function sense, whereas in Java *methods* just means some code you can call (a
    Java method call is also referred to as a *message* being *sent* to an object,
    in the OO view of things).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将 *函数* 和 *方法* 这两个术语互换使用，虽然这不是严格正确的。函数式编程人员在数学函数的意义上使用术语 *函数*，而在 Java 中
    *方法* 仅表示您可以调用的一些代码（Java 方法调用在面向对象的视角中也被称为向对象 *发送* 的 *消息*）。
- en: '*Functions as data* means that you can create *an object that is a function*,
    pass it into another function, write a function that returns another function,
    and so on—with no special syntax, because, well, functions *are* data.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数作为数据* 意味着你可以创建 *一个函数对象*，将其传递到另一个函数中，编写一个返回另一个函数的函数，等等——不需要特殊的语法，因为，嗯，函数
    *就是* 数据。'
- en: One of Java’s approaches to FP is the definition of functional interfaces. A
    *functional interface* in Java is one that has only one abstract method, such
    as the widely used `Runnable`, whose only method is `run()`, or the common Swing
    action handler `ActionListener`, whose only method is `actionPerformed(ActionEvent)`.
    Actually, also new in Java 8, interfaces can have methods annotated with the new-in-this-context
    `default` keyword. A `default` method in an interface becomes available for use
    in any class that `implements` the interface. Such methods cannot depend on instance
    state in a particular class because they would have no way of referring to it
    at compile time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的函数式编程方法之一是定义功能性接口。在 Java 中，*功能性接口* 是只有一个抽象方法的接口，例如广泛使用的 `Runnable`，其唯一方法是
    `run()`，或常见的 Swing 动作处理程序 `ActionListener`，其唯一方法是 `actionPerformed(ActionEvent)`。实际上，也是
    Java 8 中的新功能，接口可以具有使用 `default` 关键字注释的方法。接口中的 `default` 方法可用于实现接口的任何类中。这种方法不能依赖于特定类中的实例状态，因为它们在编译时无法引用它。
- en: So a functional interface is more precisely defined as one that has a single
    nondefault method. You can do functional-style programming in Java if you use
    functional interfaces and if you restrict code in your methods to not depending
    on any nonfinal instance or class fields; using default methods is one way of
    achieving this. The first few recipes in this chapter discuss functional interfaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一个功能性接口更精确的定义是具有单一非默认方法的接口。如果你使用功能性接口，并且限制方法中的代码不依赖于任何非最终实例或类字段，则可以在 Java
    中进行函数式编程；使用默认方法是实现这一目标的一种方法。本章的前几个示例讨论了功能性接口。
- en: 'Another Java approach to functional-ness is lambda expressions. A lambda is
    an expression of a functional interface, and it can be used as data (i.e., assigned,
    returned, etc.). Just to give a couple of short examples for now:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Java 实现功能性的方法是 lambda 表达式。Lambda 是功能性接口的表达式，它可以被用作数据（即，赋值、返回等）。现在只给出几个简短的例子：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Immutable data is easy in theory: just have a class with only read accessors
    (“get” methods). The standard `String` class, for example, is immutable: methods
    like `substring()` or `toUpperCase()` don’t change the original string, but make
    up new string objects with the requested change. Yet strings are universally used,
    and useful. Enums are also implicitly immutable. There is a proposal to add a
    new kind of class-like object called a `record` in Java 14 or 15. `record`s are
    implicitly immutable; the compiler generates “get” methods for the fields (along
    with a constructor and the three common `Object` methods), but not “set” methods.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，不可变数据很容易：只需有一个只有读取访问器（“get”方法）的类。例如，标准的 `String` 类是不可变的：诸如 `substring()`
    或 `toUpperCase()` 的方法并不改变原始字符串，而是根据请求生成新的字符串对象。然而字符串是普遍使用的，也很有用。枚举类型也是隐式不可变的。在
    Java 14 或 15 中有提议添加一种称为 `record` 的新型类似对象。`record` 是隐式不可变的；编译器为字段生成“get”方法（以及一个构造函数和三个通用的
    `Object` 方法），但不生成“set”方法。
- en: Also new in Java 8 is the notion of `Stream` classes. A `Stream` is like a pipeline
    that you can feed into, fan out, collect down—like a cross between the Unix notion
    of pipelines and Google’s distributed programming concept of MapReduce, as exemplified
    in [Hadoop](http://hadoop.apache.org), but running in a single VM, a single program.
    `Stream`s can be sequential or parallel; the latter are designed to take advantage
    of the massive parallelism that is happening in hardware design (particularly
    servers, where 12- and 16-core processors are popular). We discuss `Stream`s in
    several recipes in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 中还有 `Stream` 类的概念。`Stream` 就像一个管道，你可以输入、扩展、收集——类似于 Unix 管道的概念和 Google
    的分布式编程概念 MapReduce 的交叉，如 [Hadoop](http://hadoop.apache.org) 所示，但在单个 VM、单个程序中运行。`Stream`
    可以是顺序的或并行的；后者设计用于利用硬件设计中发生的大规模并行性（特别是服务器，其中 12 核和 16 核处理器很流行）。我们在本章的多个示例中讨论 `Stream`。
- en: 'If you’re familiar with Unix pipes and filters, this equivalence will make
    sense to you; if not, you can skip it for now. The Unix command is this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Unix 的管道和过滤器，这种等价性对你来说就很容易理解；如果不熟悉，现在可以跳过它。Unix 命令是这样的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Java `Stream`s equivalent is this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java `Stream` 的等价物是这样的：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These commands are written out in more idiomatic Java in [Example 9-1](#javacook-fp-unixpipes).
    Both approaches give the same answer. For small inputs, the Unix pipeline is faster;
    but for larger volumes, the Java one should be faster, especially when parallelized.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在 [Example 9-1](#javacook-fp-unixpipes) 中更符合 Java 的惯用语法。两种方法得到相同的答案。对于小输入，Unix
    管道更快；但对于较大的数据量，尤其是并行化时，Java 的方法应该更快。
- en: Example 9-1\. main/src/main/java/functional/UnixPipesFiltersReplacement.java
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-1\. main/src/main/java/functional/UnixPipesFiltersReplacement.java
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tied in with `Stream`s is the notion of a `Spliterator`, a derivative (logically,
    not by inheritance) of the familiar `Iterator` but designed for use in parallel
    processing. Most users will not be expected to develop their own `Spliterator`
    and will likely not even call its methods directly very often, so we do not discuss
    them in detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Stream` 相关的是 `Spliterator` 的概念，它是熟悉的 `Iterator` 的派生物（逻辑上而非继承上），但设计用于并行处理。大多数用户不需要开发自己的
    `Spliterator`，并且通常不会直接调用其方法，因此我们不会详细讨论它们。
- en: See Also
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For general information on functional programming, see the book *[Functional
    Thinking](http://shop.oreilly.com/product/0636920029687.do)* by Neal Ford (O’Reilly).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关函数式编程的一般信息，请参阅 Neal Ford 的书 *[Functional Thinking](http://shop.oreilly.com/product/0636920029687.do)*（O’Reilly）。
- en: There is an entire book dedicated to lambda expressions and related tools, Richard
    Warburton’s *[Java 8 Lambdas](http://shop.oreilly.com/product/0636920030713.do)*
    (O’Reilly).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一整本书专门讨论 lambda 表达式和相关工具，Richard Warburton 的 *[Java 8 Lambdas](http://shop.oreilly.com/product/0636920030713.do)*（O’Reilly）。
- en: 9.1 Using Lambdas/Closures Instead of Inner Classes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 使用 Lambdas/Closures 替代内部类
- en: Problem
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to avoid all the typing that even the anonymous style of inner class
    requires.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想要避免即使是匿名内部类风格所需的所有输入。
- en: Solution
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Java’s lambda expressions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 的 lambda 表达式。
- en: Discussion
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The symbol lambda (λ) is the 11th letter of the Greek alphabet and thus as
    old as Western society. The [Lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)
    is about as old as our notions of computing. In this context, Lambda expressions
    are small units of calculation that can be referred to. They are functions as
    data. In that sense, they are a lot like anonymous inner classes, though it’s
    probably better to think of them as *anonymous methods*. They are essentially
    used to replace inner classes for a *functional interface*—that is, an interface
    with one abstract method (function) in it. A very common example is the AWT `ActionListener`
    interface, widely used in GUI code, whose only method is this one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 lambda (λ) 是希腊字母表中的第11个字母，因此与西方社会一样古老。[Lambda 演算](http://en.wikipedia.org/wiki/Lambda_calculus)与我们的计算概念一样古老。在这个上下文中，Lambda
    表达式是可以引用的小计算单位。它们是数据的函数。从这个意义上说，它们很像匿名内部类，但最好将它们视为*匿名方法*。它们主要用于替换内部类，用于*函数接口*——即一个只有一个抽象方法（函数）的接口。一个非常常见的例子是
    AWT 的 `ActionListener` 接口，在 GUI 代码中广泛使用，其唯一方法如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using lambdas is now the preferred method of writing for GUI action listeners.
    Here’s a single example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lambda 现在是编写 GUI 动作监听器的首选方法。这里有一个单一的示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because not everybody writes Swing GUI applications these days, let’s start
    with an example that doesn’t require GUI programming. Suppose we have a collection
    of camera model descriptor objects that has already been loaded from a database
    into memory, and we want to write a general-purpose API for searching them, for
    use by other parts of our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在不是每个人都写 Swing GUI 应用程序，所以让我们从一个不需要 GUI 编程的示例开始。假设我们有一组已经从数据库加载到内存中的相机型号描述符对象，并且我们希望为它们编写一个通用的
    API 来进行搜索，以供应用程序的其他部分使用。
- en: 'The first thought might be along the following lines:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法可能沿着以下思路：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Perhaps you can already see the problem. You will also need to write `findByPrice()`,
    `findByMakeAndModel()`, `findByYearIntroduced()`, and so on as your application
    grows in complexity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您已经能够看出问题所在了。随着应用程序复杂度的增加，您还需要编写 `findByPrice()`、`findByMakeAndModel()`、`findByYearIntroduced()`
    等等。
- en: You could consider implementing a query by example method, where you pass in
    a `Camera` object and all its nonnull fields are used in the comparison. But then
    how would you implement finding cameras with interchangeable lenses *under $500*?^([2](ch09.html#idm45290660596184))
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑实现一个例如查询方法，其中您传入一个`Camera`对象，其所有非空字段都用于比较。但是，如何实现查找价格*低于$500*的可换镜头相机？^([2](ch09.html#idm45290660596184))
- en: 'So a better approach is probably to use a callback function to do the comparison.
    Then you can provide an anonymous inner class to do any kind of searching you
    need. You’d want to be able to write callback methods like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的方法可能是使用回调函数来进行比较。然后，您可以提供一个匿名内部类来执行任何需要的搜索。您可能希望能够编写像这样的回调方法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Accordingly, we’ll build that into an interface:^([3](ch09.html#idm45290660542184))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将把它构建成一个接口：^([3](ch09.html#idm45290660542184))
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the search application provides a method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在搜索应用程序提供了一个方法：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'which we can call with code like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样调用这段代码：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or, if you were not comfortable with anonymous inner classes, you might have
    to type this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您不喜欢匿名内部类，您可能需要键入以下内容：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That’s really a great deal of typing just to get one method packaged up for
    sending into the search engine. Java’s support for lambda expressions or closures
    was argued about for many years (literally) before the experts agreed on how to
    do it. And the result is staggeringly simple. One way to think of Java lambda
    expressions is that each one is just a method that implements a functional interface.
    With lambda expressions, you can rewrite the preceding code as just:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是大量的打字，只是为了将一个方法打包发送到搜索引擎中。Java 对 Lambda 表达式或闭包的支持在专家们达成一致之前（字面上）已经争论了很多年。结果是令人惊讶地简单。Java
    Lambda 表达式的一种思考方式是，每一个都只是实现功能接口的方法。使用 Lambda 表达式，您可以将前述代码简化为：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The arrow notation -> indicates the code to execute. If it’s a simple expression
    as here, you can just write it as shown. If there is conditional logic or other
    statements, you have to use a block, as is usual in Java.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头符号 -> 表示要执行的代码。如果它是一个简单的表达式，如此处所示，您可以直接编写它。如果有条件逻辑或其他语句，则必须使用块，如在 Java 中通常做的那样。
- en: 'Here I just rewrite the search example to show it as a block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只是重新编写搜索示例以展示它作为一个代码块：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first `c` inside the parenthesis corresponds to `Camera c` in the explicitly
    implemented `choose()` method: you can omit the type because the compiler knows
    it! If there is more than one argument to the method, you must parenthesize them.
    Suppose we had a compare method that takes two cameras and returns a quantitative
    value (oh, and good luck trying to get two photographers to agree on *that* algorithm!):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的第一个 `c` 对应于显式实现的 `choose()` 方法中的 `Camera c`：您可以省略类型，因为编译器已经知道它！如果方法有多个参数，您必须将它们括在括号中。假设我们有一个比较方法，它接受两个相机并返回一个定量值（哦，祝你试图让两个摄影师对*那个*算法达成一致好运！）：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This notion of *lambdas* seems pretty potent, and it is! You will see much more
    of this in Java as Java 8 moves into the mainstream of computing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 *lambda* 的概念似乎非常强大，确实如此！随着 Java 8 正成为计算主流，您将在 Java 中看到更多这样的内容。
- en: Up to here, we still have to write an interface for each type of method that
    we want to be able to lambda-ize. The next recipe shows some predefined interfaces
    that you can use to further simplify (or at least shorten) your code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这里，我们仍然需要为每种类型的方法编写一个接口，以便将其转换为 lambda 表达式。下一个示例展示了一些预定义接口，您可以使用它们进一步简化（或至少缩短）您的代码。
- en: And, of course, there are many existing interfaces that are functional, such
    as the `ActionListener` interface from GUI applications. Interestingly, the IntelliJ
    IDE (see [Recipe 1.3](ch01.html#javacook-getstarted-SECT-3)) automatically recognizes
    inner class definitions that are replaceable by lambdas and, when using *code
    folding* (the IDE feature of representing an entire method definition with a single
    line), replaces the inner class with the corresponding lambda! Figures [9-1](#javacook-lambda-intellij-f1)
    and [9-2](#javacook-lambda-intellij-f2) show a before-and-after picture of this
    code folding.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多现有的函数接口，例如来自 GUI 应用程序的 `ActionListener` 接口。有趣的是，IntelliJ IDE（参见 [Recipe
    1.3](ch01.html#javacook-getstarted-SECT-3)）会自动识别可由 lambda 替换的内部类定义，并在使用 *代码折叠*（IDE
    功能，将整个方法定义表示为单行）时，将内部类替换为相应的 lambda！图 [9-1](#javacook-lambda-intellij-f1) 和 [9-2](#javacook-lambda-intellij-f2)
    展示了此代码折叠前后的情况。
- en: '![jcb4 0901](assets/jcb4_0901.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0901](assets/jcb4_0901.png)'
- en: Figure 9-1\. IntelliJ code unfolded
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. IntelliJ 展开的代码
- en: '![jcb4 0902](assets/jcb4_0902.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0902](assets/jcb4_0902.png)'
- en: Figure 9-2\. IntelliJ code folded
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. IntelliJ 代码折叠
- en: 9.2 Using Lambda Predefined Interfaces Instead of Your Own
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 使用 Lambda 预定义接口而不是自己定义
- en: Problem
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use existing interfaces, instead of defining your own, for use with
    Lambdas.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用现有的接口，而不是定义自己的接口，以便与 Lambda 一起使用。
- en: Solution
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Java 8 lambda functional interfaces from `java.util.function`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 8 中来自`java.util.function`的 lambda 函数接口。
- en: Discussion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In [Recipe 9.1](#javacook-lambda-interfaces), we used the interface method
    `acceptCamera()` defined in the interface `CameraAcceptor`. Acceptor-type methods
    are quite common, so the package `java.util.function` includes the `Predicate<T>`
    interface, which we can use instead of `CameraAcceptor`. This interface has only
    one method—`boolean test(T t)`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Recipe 9.1](#javacook-lambda-interfaces) 中，我们使用了接口方法 `acceptCamera()`，该方法在
    `CameraAcceptor` 接口中定义。接收器类型方法非常常见，因此包 `java.util.function` 包含了 `Predicate<T>`
    接口，我们可以使用它来替代 `CameraAcceptor`。该接口只有一个方法 — `boolean test(T t)`：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This package includes about 50 of the most commonly needed functional interfaces,
    such as `IntUnaryOperator`, which takes one `int` argument and returns an `int`
    value; `LongPredicate`, which takes one `long` and returns `boolean`; and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此包包含大约 50 种最常用的功能接口，例如 `IntUnaryOperator`，它接受一个 `int` 参数并返回一个 `int` 值；`LongPredicate`，它接受一个
    `long` 并返回 `boolean` 等等。
- en: 'To use the `Predicate` interface, as with any generic type, we provide an actual
    type for the parameter `Camera`, giving us (in this case) the parameterized type
    `Predicate<Camera>`, which is the following (although we don’t have to write this
    out):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Predicate` 接口，与任何泛型类型一样，我们为参数 `Camera` 提供了一个实际类型，得到了（在本例中）参数化类型 `Predicate<Camera>`，它如下所示（尽管我们不必将其写出来）：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So now our search application will be changed to offer us the following search
    method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的搜索应用程序现在将更改为提供以下搜索方法：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Conveniently, this has the same signature as our own `CameraAcceptor` from
    the point of view of the anonymous methods that lambdas implement, so the rest
    of our code doesn’t have to change! This is still a valid call to the `search()`
    method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，这与我们自己的 `CameraAcceptor` 从 lambda 方法实现的角度来看具有相同的签名，因此我们的其余代码不需要更改！这仍然是对
    `search()` 方法的有效调用：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the implementation of the `search` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `search` 方法的实现：
- en: '*main/src/main/java/functional/CameraSearchPredicate.java*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/functional/CameraSearchPredicate.java*'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Suppose we only need the list to do one operation on each element, and then
    we’ll discard it. Upon reflection, we don’t actually need to get the list back;
    we merely need to get our hooks on each element that matches our `Predicate` in
    turn.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只需要对每个元素执行一个操作，然后将其丢弃。经过反思，我们实际上不需要获取列表返回；我们只需依次获取匹配我们的 `Predicate` 的每个元素的钩子。
- en: Roll Your Own Functional Interface
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义功能接口
- en: 'While the JDK provides a good set of functional interfaces, there may be cases
    where you’d want to create your own. This is a simple example of a functional
    interface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JDK 提供了一组良好的功能性接口，但可能会有需要创建自己的情况。这是一个功能性接口的简单示例：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `@FunctionalInterface` annotation tells the compiler to ensure that a given
    interface is and remains functional. Its use is analogous to `@Override` (both
    annotations are in `java.lang`). It is always optional.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FunctionalInterface` 注解告诉编译器确保给定的接口是功能性的并且保持这种状态。它的使用类似于 `@Override` （这两个注解都在
    `java.lang` 中）。这是可选的。'
- en: '`MyFunctionalInterface` could be used to process an array of integers, like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyFunctionalInterface` 可用于处理整数数组，如下所示：'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If `compute` were a nonfunctional interface—having multiple abstract methods—you
    would not be able to use it in this fashion.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `compute` 是一个非功能接口——有多个抽象方法——那么你将无法以这种方式使用它。
- en: 'Sometimes, of course, you really do need an interface to have more than one
    method. In that case, the illusion (or the effect) of functionality can sometimes
    be preserved by denoting all but one of the methods with the default keyword—the
    nondefault method will still be usable in lambdas. A default method has a method
    body:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时候你确实需要一个接口有多于一个方法。在这种情况下，可以通过使用 `default` 关键字标记除一个方法外的所有方法来保留功能性的幻觉（或效果）—非默认方法仍可在
    lambda 中使用。默认方法具有方法体：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Only default methods may contain executable statements, and there may only be
    one nondefault method per functional interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 只有默认方法可以包含可执行语句，并且每个功能接口只能有一个非默认方法。
- en: By the way, the `MyFunctionalInterface` given earlier can be totally replaced
    by `java.util.function.IntUnaryOperator`, changing the method name `apply()` to
    `applyAsInt()`. There is a version of the `ProcessInts` program under the name
    `ProcessIntsIntUnaryOperator` in the *javasrc* repository.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，前面提到的 `MyFunctionalInterface` 完全可以被 `java.util.function.IntUnaryOperator`
    替代，将方法名 `apply()` 改为 `applyAsInt()`。在 *javasrc* 仓库中有一个名为 `ProcessIntsIntUnaryOperator`
    的 `ProcessInts` 程序版本。
- en: Default methods in interfaces can be used to produce *mixins*, as described
    in [Recipe 9.7](#fp-mixins-sect1).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的默认方法可以用于生成 *mixin*，如 [Recipe 9.7](#fp-mixins-sect1) 所述。
- en: 9.3 Simplifying Processing with Streams
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 简化流处理
- en: Problem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to process some data through a pipeline-like mechanism.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过类似管道的机制处理一些数据。
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `Stream` class and its operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Stream` 类及其操作。
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '*Streams* are a new mechanism introduced with Java 8 to allow a collection
    to send its values out one at a time through a pipeline-like mechanism where they
    can be processed in various ways, with varying degrees of parallelism. There are
    three types of methods involved with `Stream`s:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*Streams* 是在 Java 8 中引入的一种新机制，允许集合通过类似管道的机制逐个发送其值，可以以不同方式进行处理，具有不同的并行程度。与 `Stream`
    相关的方法有三种类型：'
- en: Stream-producing methods (see [Recipe 7.3](ch07.html#javacook-structure-collections)).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流生成方法（参见 [Recipe 7.3](ch07.html#javacook-structure-collections)）。
- en: Stream-passing methods, which operate on a Stream and return a reference to
    it, in order to allow for *fluent programming* (chained methods calls); examples
    include `distinct()`, `filter()`, `limit()`, `map()`, `peek()`, `sorted()`, and
    `unsorted()`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流传递方法，对流进行操作并返回对其的引用，以允许 *流畅编程*（链式方法调用）；例如 `distinct()`、`filter()`、`limit()`、`map()`、`peek()`、`sorted()`
    和 `unsorted()`。
- en: Stream-terminating methods, which conclude a streaming operation; examples include
    `collect()`, `count()`, `findFirst()`, `max()`, `min()`, `reduce()`, and `sum()`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流终止方法，结束流操作；例如 `collect()`、`count()`、`findFirst()`、`max()`、`min()`、`reduce()`
    和 `sum()`。
- en: In [Example 9-2](#javacook-fp-streams-ex), we have a list of `Hero` objects
    representing superheroes through the ages. We use the `Stream` mechanism to filter
    just the adult heroes and then sum their ages. We use it again to sort the heroes’
    names alphabetically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 9-2](#javacook-fp-streams-ex) 中，我们有一个表示超级英雄的 `Hero` 对象列表。我们使用 `Stream`
    机制来过滤出成年英雄，并计算他们的年龄总和。然后我们再次使用它来按字母顺序对英雄的名称进行排序。
- en: In both operations we start with a stream generator (`Arrays.stream()`); we
    run it through several steps, one of which involves a mapping operation (don’t
    confuse with `java.util.Map`!) that causes a different value to be sent along
    the pipeline. The stream is wrapped up by a terminal operation. The map and filter
    operations almost invariably are controlled by a lambda expression (inner classes
    would be too tedious to use in this style of programming!).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个操作中，我们从流生成器 (`Arrays.stream()`) 开始；我们通过几个步骤运行它，其中一个步骤涉及映射操作（不要与 `java.util.Map`
    混淆！），导致不同的值在管道中传递。流通过终端操作完成。映射和过滤操作几乎总是由 lambda 表达式控制（在这种编程风格中使用内部类会太麻烦！）。
- en: Example 9-2\. main/src/main/java/functional/SimpleStreamDemo.java
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. main/src/main/java/functional/SimpleStreamDemo.java
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And let’s run it to be sure it works:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一下，确保它能正常工作：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See the javadoc for the `java.util.stream.Stream` interface for a complete list
    of the operations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `java.util.stream.Stream` 接口的 javadoc，了解所有操作的完整列表。
- en: 9.4 Simplifying Streams with Collectors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 使用收集器（Collectors）简化流。
- en: Problem
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You construct Streams but they are complicated or inefficient.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建的流（Streams）过于复杂或效率低下。
- en: Solution
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `Collector`s.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Collector`。
- en: Discussion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Example 9-2](#javacook-fp-streams-ex) ended the first half with a call to
    `collect()`. The argument to `collect()` is of type `Collector`, which this recipe
    considers in more detail. `Collector`s are a form of what classical FP languages
    call [*folds*](https://en.wikipedia.org/wiki/Fold_(higher-order_function)). Folds
    are also called reduce, accumulate, aggregate, compress, or inject operations.
    A *fold* in functional programming is a terminal operation, analogous to collapsing
    a whole string of tickets into a flat pile (see [Figure 9-3](#javacook-fp-FIG-folds)).
    The string of tickets represents the `Stream`, the folding operation is represented
    by a function, and the final result is, well, the final result, all folded up.
    It will often include a combining operation, analogous to counting the tickets
    as they are folded.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-2](#javacook-fp-streams-ex) 在第一半部分以调用 `collect()` 结束。`collect()` 的参数是
    `Collector` 类型，本篇介绍将更详细地考虑这种类型。`Collector` 是经典的函数式编程语言称为 [*folds*](https://en.wikipedia.org/wiki/Fold_(higher-order_function))
    的一种形式。在函数式编程中，*fold* 也称为 reduce、accumulate、aggregate、compress 或 inject 操作。*Fold*
    是一种终端操作，类似于将整个票据串折叠成一堆平整的操作（见 [图 9-3](#javacook-fp-FIG-folds)）。票据串代表 `Stream`，折叠操作由一个函数表示，最终结果是折叠的全部结果。通常包括一个结合操作，类似于在折叠过程中对票据进行计数。'
- en: '![folds](assets/folds.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![折叠](assets/folds.png)'
- en: 'Figure 9-3\. Stream of tickets before folding, during folding, and after folding:
    a terminal operation'
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. 折叠前、折叠中和折叠后的票据流：终端操作
- en: Note that in the first panel of [Figure 9-3](#javacook-fp-FIG-folds) we don’t
    know how long the `Stream` is, but we expect that it will terminate eventually.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [图 9-3](#javacook-fp-FIG-folds) 的第一个面板中，我们不知道 `Stream` 的长度，但我们预期它最终会终止。
- en: '*Collector* as used in Java refers to a terminal function that analyses/summarizes
    the content of a `Stream`. Technically, `Collector` is an interface whose implementation
    is specified by three (or four) functions that work together to accumulate entries
    into a Collection or Map or other mutable result container, and optionally a final
    transform on the result. The functions are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，*Collector* 是指一个终端函数，用于分析/汇总 `Stream` 的内容。技术上讲，`Collector` 是一个接口，其实现由三（或四）个函数组成，这些函数共同工作将条目累积到集合、映射或其他可变结果容器中，并在最终结果上可选执行最终的转换。这些函数如下：
- en: Creating a new result container (the `supplier()`)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的结果容器（`supplier()`）。
- en: Adding a new data element into the result container (the `accumulator()`)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的数据元素添加到结果容器（`accumulator()`）中。
- en: Combining two result *containers* into one (the `combiner()`)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个结果 *容器* 合并为一个（`combiner()`）。
- en: Performing a final transform on the container (the `finisher()`, which is optional)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结果容器上执行最终转换（可选的 `finisher()`）。
- en: 'While you can easily compose your own `Collector` implementation, it is often
    expedient to use one of the many useful ones predefined in the `Collectors` class.
    Here are a couple of simple examples:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以轻松地组合自己的`Collector`实现，但通常使用`Collectors`类中预定义的许多有用的`Collector`更为方便。以下是一些简单示例：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In [Example 9-3](#javacook-functional-EX-wordfreq) I implement the classic
    *word frequency count* algorithm: take a text file, break it into individual words,
    count the occurrence of each word, and list the *n* most-used words, sorted by
    frequency in descending order.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 9-3](#javacook-functional-EX-wordfreq)中，我实现了经典的*单词频率统计*算法：获取文本文件，将其拆分为单个单词，计算每个单词的出现次数，并列出使用频率最高的*n*个单词，按出现频率降序排序。
- en: 'In Unix terms this could be implemented (assuming *n* = 20) as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix术语中，这可以实现为（假设*n* = 20）：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where `prep` is a script that uses the Unix tool `tr` to break lines into words
    and turn the words into lowercase.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`prep`是一个使用Unix工具`tr`将行分成单词并将单词转换为小写的脚本。
- en: Example 9-3\. main/src/main/java/functional/WordFreq.java
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3\. main/src/main/java/functional/WordFreq.java
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are two steps. First, create a map of the words and their frequencies.
    Second, sort these in reverse order, stop at number 20, and format them neatly
    and print.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个步骤。首先，创建单词及其频率的映射。其次，以相反的顺序排序这些，在第20个位置停止，并将它们整齐地格式化并打印出来。
- en: 'The first part uses `Files.lines()` from [Chapter 10](ch10.html#javacook-io)
    to get a `Stream` of `Strings`, which is broken into individual words using the
    `Stream` method `flatMap()` combined with the `String` method `split()` to break
    on one or more spaces. The result of that is collected into a map using a `Collector`.
    I had initially used a homemade collector:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分使用来自[第10章](ch10.html#javacook-io)的`Files.lines()`来获取`String`的`Stream`，使用`Stream`方法`flatMap()`与`String`方法`split()`结合，根据一个或多个空格进行拆分为单个单词。然后使用`Collector`将结果收集到一个映射中。我最初使用的是自制的收集器：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This form of `collect()` takes three arguments:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`collect()`接受三个参数：
- en: A `Supplier<R>` or factory method to create an empty container; here I’m just
    using the `HashMap` constructor.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Supplier<R>`或工厂方法来创建一个空容器；在这里，我只是使用`HashMap`构造函数。
- en: An accumulator of type `BiConsumer<R,? super T>` to add each element into the
    map, adding one each time the same word is found.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`BiConsumer<R,? super T>`的累加器，将每个元素添加到映射中，在发现相同的单词时每次添加一个。
- en: A Combiner of type `BiConsumer<R,R> combiner)` to combine all the collections
    used.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`BiConsumer<R,R> combiner)`的组合器，用于组合所有使用的集合。
- en: In the case of parallel streams (see [Recipe 9.5](#javacook-functional-parallel_collections)),
    the `Supplier` may be called multiple times to create multiple containers, and
    each part of the Stream’s content will be handled by one Accumulator into one
    of the containers. The `Combiner` will merge all the containers into one at the
    end of processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行流的情况下（参见[示例 9.5](#javacook-functional-parallel_collections)），`Supplier`可能会被多次调用以创建多个容器，并且流的每个部分将由一个`Accumulator`处理到一个容器中。`Combiner`将在处理结束时将所有容器合并为一个。
- en: 'However, Sander Mak pointed out that it’s easier to use the existing `Collectors`
    class’s predefined Collector `groupingBy`, combining the `toLowerCase()` call
    and the `collect()` call with this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，桑德·马克指出，使用现有的`Collectors`类的预定义`Collector` `groupingBy`更容易，将`toLowerCase()`调用和`collect()`调用与此结合：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To further simplify the code, you could combine the two statements into one,
    by doing the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化代码，你可以将这两个语句合并成一个，通过以下方式：
- en: Removing the return value and assignment `Map<String,Long> =`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从返回值和赋值`Map<String,Long> =`中移除
- en: Removing the semicolon from the end of the `collect` call
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`collect`调用的末尾去除分号
- en: Removing the `.map()` from the `entrySet()` call
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`entrySet()`调用中移除`.map()`
- en: Then you can say you’ve implemented something useful in a single Java statement!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可以说你在一个单独的Java语句中实现了一些有用的东西！
- en: 9.5 Improving Throughput with Parallel Streams and Collections
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 使用并行流和集合提高吞吐量
- en: Problem
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to combine `Stream`s with parallelism and still be able to use the
    non-thread-safe Collections API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将`Stream`与并行性结合，并且仍然能够使用非线程安全的集合API。
- en: Solution
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a parallel stream.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行流。
- en: Discussion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The standard Collections classes, such as most `List`, `Set`, and `Map` implementations,
    are not thread-safe for update; if you add or remove objects from one in one thread
    while another thread is accessing the objects stored in the collection, failure
    will result. Multiple threads reading from the same collection with no modification
    is OK. We discuss multithreading in [Chapter 16](ch16.html#javacook-threads).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的集合类，如大多数`List`、`Set`和`Map`实现，对于更新而言是不线程安全的；如果在一个线程中向其中添加或删除对象，而另一个线程同时访问存储在集合中的对象，则会导致失败。多个线程从同一个集合中读取而不修改是可以的。我们在[第16章](ch16.html#javacook-threads)中讨论了多线程。
- en: The Collections Framework does provide *synchronized wrappers*, which provide
    automatic synchronization but at the cost of adding thread contention, which reduces
    parallelism. To enable efficient operations, *parallel streams* let you use the
    non-thread-safe collections safely, as long as you do not modify the collection
    while you are operating on it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架提供了*同步包装器*，这些包装器提供自动同步，但会增加线程竞争，从而降低并行性。为了实现高效的操作，*并行流*允许您安全地使用非线程安全的集合，只要您在操作集合时不修改它。
- en: To use a parallel stream, you just ask the collection for it, using `parallelStream()`
    instead of the `stream()` method we used in [Recipe 9.3](#javacook-fp-streams1-1).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用并行流，只需请求集合，使用`parallelStream()`而不是我们在[Recipe 9.3](#javacook-fp-streams1-1)中使用的`stream()`方法。
- en: 'For example, suppose that our camera business takes off, and we need to find
    cameras by type and price range *quickly* (and with less code than we used before):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的相机业务起飞了，我们需要*快速*（而且比之前的代码更少）找到类型和价格范围内的相机：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-1)'
- en: Create a parallel stream from the `List` of `Camera` objects. The end result
    of the stream will be iterated over by the foreach loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Camera`对象的`List`创建并行流。流的最终结果将由foreach循环迭代。
- en: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-2)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-2)'
- en: Filter the cameras on price, using the same `Predicate` lambda that we used
    in [Recipe 9.1](#javacook-lambda-interfaces).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的`Predicate` lambda在价格上过滤相机，就像我们在[Recipe 9.1](#javacook-lambda-interfaces)中使用的一样。
- en: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-3)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-3)'
- en: Terminate the `Stream` by converting it to an array.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Stream`转换为数组来终止它。
- en: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-4)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-4)'
- en: 'The body of the foreach loop: print one `Camera` from the `Stream`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: foreach循环的主体：从`Stream`中打印一个`Camera`。
- en: '[![5](assets/5.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-5)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-5)'
- en: A more concise way of writing the search.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地编写搜索的方法。
- en: Warning
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This is reliable as long as no thread is modifying the data at the same time
    as the searching is going on. See the thread interlocking mechanisms in [Chapter 16](ch16.html#javacook-threads)
    to see how to ensure this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有线程在搜索进行时同时修改数据，这是可靠的。请查看[第16章](ch16.html#javacook-threads)中的线程交锁机制，了解如何确保这一点。
- en: 9.6 Using Existing Code as Functional with Method References
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 将现有代码作为方法引用使用函数式
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have existing code that matches a functional interface and want to use it
    without renaming methods to match the interface name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个与函数接口匹配的现有代码，并且希望在不重命名方法以匹配接口名称的情况下使用它。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use function references such as `MyClass::myFunc` or `someObj::someFunc`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数引用，例如`MyClass::myFunc`或`someObj::someFunc`。
- en: Discussion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The word *reference* is almost as overloaded in Java as the word *Session*.
    Consider the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用*这个词在Java中几乎像*Session*这个词一样被过载。考虑以下情况：'
- en: Ordinary objects are usually accessed with references.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通对象通常通过引用访问。
- en: Reference types such as `WeakReference` have defined semantics for garbage collection.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如 `WeakReference` 的引用类型已定义了垃圾收集的语义。
- en: And now, for something completely different, Java 8 lets you reference an individual
    method.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，来点完全不同的东西，Java 8 允许您引用单个方法。
- en: You can even reference what Oracle documentation calls “an Instance Method of
    an Arbitrary Object of a Particular Type.”
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您甚至可以引用 Oracle 文档中称为“特定类型的任意对象的实例方法”。
- en: The new syntax consists of an object or class name, two colons, and the name
    of a method that can be invoked in the context of the object or class name (as
    per the usual rules of Java, a class name can refer to static methods and an instance
    can refer to an instance method). To refer to a constructor as the method, you
    can use `new`—for example, `MyClass::new`. The reference creates a lambda that
    can be invoked, stored in a variable of a functional interface type, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法由对象或类名、两个冒号和可以在对象或类名上下文中调用的方法名组成（根据 Java 的常规规则，类名可以引用静态方法，实例可以引用实例方法）。要将构造函数引用为方法，可以使用`new`，例如`MyClass::new`。该引用创建了一个可以调用的
    lambda，存储在函数接口类型的变量中，等等。
- en: In [Example 9-4](#javacook-fp-refs-ex1), we create a `Runnable` reference that
    holds, not the usual `run` method, but a method with the same type and arguments
    but with the name `walk`. Note the use of `this` as the object part of the method
    reference. We then pass this `Runnable` into a `Thread` constructor and start
    the thread, with the result that `walk` is invoked where `run` would normally
    be.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 9-4](#javacook-fp-refs-ex1)中，我们创建了一个 `Runnable` 引用，它保存的不是通常的 `run` 方法，而是一个具有相同类型和参数但名称为
    `walk` 的方法。请注意，使用 `this` 作为方法引用的对象部分。然后，我们将此 `Runnable` 传递给 `Thread` 构造函数并启动线程，结果是
    `walk` 被调用，而通常情况下会调用 `run`。
- en: Example 9-4\. main/src/main/java/functional/ReferencesDemo.java
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. main/src/main/java/functional/ReferencesDemo.java
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 9-5](#javacook-fp-refs-ex2) creates an `AutoCloseable` for use in
    a try-with-resource. The normal `AutoCloseable` method is `close()`, but ours
    is named `cloz()`. The `AutoCloseable` reference variable `autoCloseable` is created
    inside the `try` statement, so its close-like method will be called when the body
    completes. In this example, we are in a static `main` method wherein we have a
    reference `rnd2` to an instance of the class, so we use this in referring to the
    `AutoCloseable`-compatible method.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](#javacook-fp-refs-ex2) 创建了一个`AutoCloseable`，以便在 try-with-resources
    中使用。通常的`AutoCloseable`方法是`close()`，但我们的方法名为`cloz()`。`AutoCloseable`引用变量`autoCloseable`在`try`语句内创建，因此当主体完成时将调用其类似关闭的方法。在此示例中，我们位于静态`main`方法中，其中有一个对该类实例的引用`rnd2`，因此我们在引用`AutoCloseable`兼容方法时使用了它。'
- en: Example 9-5\. main/src/main/java/functional/ReferencesDemo2.java
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. main/src/main/java/functional/ReferencesDemo2.java
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is, of course, possible to use this with your own functional interfaces,
    defined as in [“Roll Your Own Functional Interface”](#javacook-lambda-interfacesb-4).
    You’re also probably at least vaguely aware that any normal Java object reference
    can be passed to `System.out.println()` and you’ll get some description of the
    referenced object. [Example 9-6](#javacook-fp-refs-ex3) explores these two themes.
    We define a functional interface imaginatively known as `FunInterface` with a
    method with a bunch of arguments (merely to avoid it being mistaken for any existing
    functional interface). The method name is `process`, but as you now know the name
    is not important; our implementation method goes by the name `work`. The `work`
    method is static, so we could not state that the class `implements FunInterface`
    (even if the method names were the same; a static method may not hide an inherited
    instance method), but we can nonetheless create a lambda reference to the `work`
    method. We then print this out to show that it has a valid structure as a Java
    object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将其与您自己定义的函数接口一起使用，如[“自定义函数接口”](#javacook-lambda-interfacesb-4)所述。您可能至少模糊意识到，任何普通的
    Java 对象引用都可以传递给 `System.out.println()`，并且您将得到对所引用对象的某些描述。[示例 9-6](#javacook-fp-refs-ex3)探讨了这两个主题。我们定义了一个名为`FunInterface`的函数接口，其方法带有一堆参数（仅仅是为了避免它被误认为是任何现有的函数接口）。方法名为`process`，但如今您知道，名称并不重要；我们的实现方法名为`work`。`work`方法是静态的，因此即使方法名相同，我们也不能声明该类`implements
    FunInterface`（静态方法不能隐藏继承的实例方法），但我们仍然可以创建对`work`方法的 lambda 引用。然后我们将其打印出来，以展示它作为
    Java 对象具有有效的结构。
- en: Example 9-6\. main/src/main/java/functional/ReferencesDemo3.java
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. main/src/main/java/functional/ReferencesDemo3.java
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This generates the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下输出：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Lambda$1` in the name is structurally similar to the “$1” used in anonymous
    inner classes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中的`Lambda$1`在结构上类似于匿名内部类中使用的`$1`。
- en: The fourth way, “an Instance Method of an Arbitrary Object of a Particular Type,”
    may be the most esoteric thing in all of Java 8\. It allows you to declare a reference
    to an instance method but without specifying which instance. Because there is
    no particular instance in mind, you again use the class name. This means you can
    use it with any instance of the given class! In [Example 9-7](#javacook-fp-refs-ex4),
    we have an array of `String`s to sort. Because the names in this array can begin
    with a lowercase letter, we want to sort them using the `String` method `compareToIgnoreCase()`,
    which nicely ignores case differences for us.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方式，“特定类型的任意对象的实例方法”，可能是Java 8 中最神秘的东西。它允许您声明对实例方法的引用，但不指定哪个实例。因为没有特定的实例在脑海中，所以再次使用类名。这意味着您可以在给定类的任何实例上使用它！在[示例 9-7](#javacook-fp-refs-ex4)中，我们有一个要排序的`String`数组。因为该数组中的名称可以以小写字母开头，我们希望使用`String`方法`compareToIgnoreCase()`进行排序，这个方法很好地忽略了大小写差异。
- en: Because I want to show the sorting several different ways, I set up two array
    referencess, the original, unsorted one, and a working one that is re-created,
    sorted, and printed using a simple dump routine, which isn’t shown (it’s just
    a `for` loop printing the strings from the passed array).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我想展示几种不同的排序方式，所以我设置了两个数组引用，一个是原始的未排序数组，另一个是重新创建、排序并使用简单的转储例程打印的工作数组（未显示出来，它只是一个`for`循环打印传递的数组中的字符串）。
- en: Example 9-7\. main/src/main/java/functional/ReferencesDemo4.java
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. main/src/main/java/functional/ReferencesDemo4.java
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-1)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-1)'
- en: Using “an Instance Method of an Arbitrary Object of a Particular Type,” declares
    a reference to the `compareToIgnoreCase` method of any `String` used in the invocation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“特定类型的任意对象的实例方法”，声明了对调用中任何`String`的`compareToIgnoreCase`方法的引用。
- en: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-2)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-2)'
- en: Shows the equivalent lambda expression.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了等效的Lambda表达式。
- en: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-3)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-3)'
- en: Shows “Your grandparents’ Java” way of doing things.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了“你祖父母的Java”处理事情的方式。
- en: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-4)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-4)'
- en: Using the exported `Comparator` directly, just to show that there is always
    more than one way to do things.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用导出的`Comparator`，只是为了展示事情总有多种解决方法。
- en: 'Just to be safe, I ran the demo, and got the expected output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我运行了演示，并获得了预期的输出：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '9.7 Java Mixins: Mixing in Methods'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 Java混入：混合方法
- en: Problem
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve heard about mixins and want to apply them in Java.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经听说过混入（mixins），并希望在Java中应用它们。
- en: Solution
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use static imports. Or, declare one or more functional interfaces with a default
    method containing the code to execute, and simply implement it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入。或者，声明一个或多个包含执行代码的默认方法的功能接口，并简单地实现它。
- en: Discussion
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Developers from other languages sometimes deride Java for its inability to handle
    mixins, the ability to mix in bits of code from other classes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 来自其他语言的开发人员有时会嘲笑Java无法处理混入，即从其他类中混入代码段的能力。
- en: One way to implement mixins is with the *static import* feature, which has been
    in the language for a decade. This is often done in unit testing (see [Recipe
    1.10](ch01.html#javacook-getstarted-junit)). A limitation of this approach is
    that, as the name implies, the methods must be static methods, not instance methods.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实现混入的一种方法是使用*静态导入*功能，该功能已经在语言中存在了十年。这经常在单元测试中执行（见[食谱 1.10](ch01.html#javacook-getstarted-junit)）。此方法的限制是，正如其名称所示，方法必须是静态方法，而不是实例方法。
- en: 'A newer mechanism depends on an interesting bit of fallout from the Java 8
    language changes in support of lambdas: you can now mix in code from unrelated
    places into one class. Has Java finally abandoned its staunch opposition to multiple
    inheritance? It may seem that way when you first hear it, but relax: you can only
    pull methods from multiple interfaces, not from multiple classes. If you didn’t
    know that you could have methods defined (rather than merely declared) in interfaces,
    see [“Subclass, Abstract Class, or Interface?”](ch08.html#javacook-oo-SIDEBAR-1).
    Consider the following example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的机制依赖于Java 8语言更改的一个有趣的副产品：现在可以将来自不相关位置的代码混入一个类中。Java是否终于放弃了对多继承的坚决反对？当你第一次听到时可能会这样认为，但放松：你只能从多个接口中获取方法，而不能从多个类中获取。如果你不知道接口中可以定义方法（而不仅仅是声明），请参阅[“子类、抽象类或接口？”](ch08.html#javacook-oo-SIDEBAR-1)。考虑以下示例：
- en: '*main/src/main/java/lang/MixinsDemo.java*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/lang/MixinsDemo.java*'
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run this, we see the expected results:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们将看到预期的结果：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Presto—Java now supports mixins!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Presto — Java现在支持mixin！
- en: 'Does this mean you should go crazy trying to build interfaces with code in
    them? No. Remember this mechanism was designed to do the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你应该疯狂地尝试在接口中构建带有代码的功能吗？不是的。请记住，这个机制被设计用来做以下几件事：
- en: Provide the notion of functional interfaces for use in lambda calculations.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用于lambda计算的功能接口概念。
- en: Give the ability to retrofit interfaces with new methods, without having to
    change *old* implementations. As with many changes made in Java over the years,
    backward compatibility was a huge driver.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许为接口添加新方法，而不必改动*旧的*实现。和Java多年来的许多改变一样，向后兼容性是一个重要驱动因素。
- en: Used sparingly, functional interfaces can provide the ability to mix in code
    to build up applications in another way than direct inheritance, aggregation,
    or AOP. Overused, it can make your code heavy, drive pre–Java 8 developers crazy,
    and lead to chaos.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适度使用，功能接口可以提供一种通过代码混入来构建应用程序的能力，这种方式不同于直接继承、聚合或AOP。如果过度使用，会使你的代码变得臃肿，让那些Java
    8之前的开发者发疯，并导致混乱。
- en: ^([1](ch09.html#idm45290660939720-marker)) Haskell was used to write a fairly
    complete Twitter clone in a few hundred lines; see [*https://github.com/Gabriel439/simple-twitter*](https://github.com/Gabriel439/simple-twitter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#idm45290660939720-marker)) 使用Haskell编写了一个相当完整的Twitter克隆版本，代码只有几百行；请参阅[*https://github.com/Gabriel439/simple-twitter*](https://github.com/Gabriel439/simple-twitter)。
- en: ^([2](ch09.html#idm45290660596184-marker)) If you ever have to do this kind
    of thing where the data is stored in a relational database using the Java Persistence
    API (JPA), you should check out the [Spring Data](https://spring.io/projects/spring-data)
    or [Apache DeltaSpike](http://deltaspike.apache.org) frameworks. These allow you
    to define an `interface` with method names like `findCameraByInterchangeableTrueAndPriceLessThan(double
    price)` and have the framework implement these methods for you.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#idm45290660596184-marker)) 如果你曾经需要在关系数据库中使用Java Persistence
    API（JPA）存储数据，你应该考虑使用[Spring Data](https://spring.io/projects/spring-data)或[Apache
    DeltaSpike](http://deltaspike.apache.org)框架。这些框架允许你定义一个带有像`findCameraByInterchangeableTrueAndPriceLessThan(double
    price)`这样方法名的接口，并让框架为你实现这些方法。
- en: '^([3](ch09.html#idm45290660542184-marker)) If you’re just not that into cameras,
    the description “Interchangeable Lens Camera (ILC)” includes two categories of
    what you might find in a camera store: traditional DSLR (Digital Single Lens Reflex)
    cameras, and the newer category of “Compact System Cameras” like the Nikon 1 and
    Z series, Sony ILCE (formerly known as NEX), and the Canon EOS-M, all of which
    are smaller and lighter than the older DSLRs.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#idm45290660542184-marker)) 如果你对相机不感兴趣，那么“可换镜头相机（ILC）”的描述包括你在相机商店可能找到的两类产品：传统的单反相机（DSLR）和较新的“紧凑系统相机”，如尼康1和Z系列、索尼ILCE（前身为NEX）和佳能EOS-M，这些都比旧款DSLR相机更小更轻。
