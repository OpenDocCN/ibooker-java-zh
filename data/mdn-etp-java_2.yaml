- en: Chapter 2\. The Path to Cloud Native Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 通向云原生Java之路
- en: “Πάντα ῥεῖ” (Panta rei) is a famous aphorism from philosopher Heraclitus that
    describes the mutable condition of our existence where everything flows, where
    our call is to react and adapt. This perfectly describes the right approach to
    the evolution we are experiencing in the IT world in general, and specifically
    with programming languages and frameworks, where heterogeneous, distributed, multicloud
    workloads are more common and essential for business purposes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “Πάντα ῥεῖ”（一切都在流动）是哲学家赫拉克利特的一句著名格言，描述了我们存在的可变条件，一切都在流动，我们的呼唤是反应和适应。这完美地描述了我们在IT世界中以及具体到编程语言和框架中正在经历的演变的正确方法，其中异构、分布式、多云负载更加普遍且对业务目标至关重要。
- en: Java and Jakarta EE (formely known as Java EE), are evolving as well in that
    direction, balancing the benefits that come from the consolidated experience of
    enterprise solutions, together with the need for a fast-changing cloud-aware scenario
    where our applications can run in many clouds seamlessly. In this chapter, we
    will outline the components needed for a transition to cloud native Java, walking
    you through an ecommerce store Java implementation called Coolstore.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java和Jakarta EE（之前被称为Java EE），也在这个方向上不断发展，平衡来自企业解决方案的成熟经验所带来的好处，以及快速变化的云感知场景的需求，在这一章节中，我们将概述迁移到云原生Java所需的组件，引导您完成一个名为Coolstore的电子商务商店Java实现。
- en: Cloud Native Workshop
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生研讨会
- en: Microservices are an accepted and well-recognized practice nowadays. For JavaEE
    developers, this means a lift-and-shift change of the paradigm, where a single
    application server does not contain all our business logic. Instead, it gets split
    into different microservices running in their application servers, like Tomcat
    or Undertow, with a minimal footprint and optimizations to keep this coexistence
    functional and performant also in the cloud native world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种被广泛认可和接受的实践。对于JavaEE开发者来说，这意味着一种范式的提升和转变，单个应用服务器不再包含所有业务逻辑。相反，它被拆分成运行在各自应用服务器上的不同微服务，如Tomcat或Undertow，具有最小的足迹和优化，以保持在云原生世界中的功能和性能。
- en: The monolithic approach today can be refactored into a heterogeneous and even
    programming language agnostic model, where each module is managed by a specific
    component running in a different application. Beyond the best practices such as
    API-driven models, the challenge here is how to maintain this diversity. However,
    Java today provides a set of tools and frameworks that help us focus on our preferred
    tools and collaborate easily. In this chapter, you will learn how to develop and
    deploy a microservices-based application split across different Java frameworks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，单片式方法可以重构为异构甚至编程语言无关的模型，其中每个模块由在不同应用程序中运行的特定组件管理。除了像API驱动模型这样的最佳实践外，这里的挑战是如何维护这种多样性。然而，如今Java提供了一套工具和框架，帮助我们专注于我们喜爱的工具并轻松合作。在本章中，您将学习如何开发和部署基于微服务的应用程序，这些微服务跨越不同的Java框架。
- en: Architecture
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'Our ecommerce application Coolstore is a typical web app containing three components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子商务应用Coolstore是一个典型的Web应用程序，包含三个组件：
- en: Presentation layer
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层
- en: a frontend to show available items to acquire
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个前端用于显示可供获取的项目
- en: Model layer
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层
- en: a backend providing the business logic to catalog and index all items to sell
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个后端提供业务逻辑来目录化和索引所有要出售的项目
- en: Data layer
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层
- en: a database storing all records about transactions and items
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 存储所有交易和商品记录的数据库
- en: The outcome of these components is an online store with a catalog of product
    items and an inventory of stock that we can organize with the architecture shown
    in [Figure 2-1](#fig2-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件的结果是一个在线商店，具有产品项目目录和我们可以使用[图 2-1](#fig2-1)中展示的架构进行组织的库存。
- en: '![Coolstore Architecture](Images/moej_0201.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![酷店架构](Images/moej_0201.png)'
- en: Figure 2-1\. Coolstore architecture
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1 酷店架构
- en: 'We map the three previously mentioned components into several microservices,
    each one responsible for its layer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这三个先前提到的组件映射到多个微服务中，每个微服务负责其层：
- en: '*Catalog Service* uses a REST API to expose the content of a catalog stored
    in a relational database.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目录服务* 使用REST API公开存储在关系数据库中的目录内容。'
- en: '*Inventory Service* uses a REST API to expose the inventory of items stored
    in a relational database.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库存服务* 使用REST API公开存储在关系数据库中的商品库存。'
- en: '*Gateway Service* calls the *Catalog Service* and *Inventory Service* in an
    efficient way.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网关服务*以高效的方式调用*目录服务*和*库存服务*。'
- en: '*WebUI Service* calls *Gateway Service* to retrieve all the information.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebUI服务*调用*网关服务*以检索所有信息。'
- en: The Presentation and the Model layers are represented by such microservices,
    with the latter having an interface to the Data layer delegated to some DBMS.
    Our estore implementation is called Coolstore and looks like the picture in [Figure 2-2](#fig2-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表示这些微服务的演示层和模型层，后者具有与某些数据库管理系统委托的数据层接口。我们的电子商店实现称为Coolstore，并且看起来像[图2-2](#fig2-2)中的图片。
- en: '![Coolstore Dashboard](Images/moej_0202.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Coolstore仪表板](Images/moej_0202.png)'
- en: Figure 2-2\. Coolstore dashboard
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. Coolstore仪表板
- en: Create an Inventory Microservice with Quarkus
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus创建库存微服务
- en: '[Quarkus](https://quarkus.io) is a full stack, Kubernetes-native Java framework
    made for Java virtual machines (JVMs) and native compilation, optimizing Java
    specifically for containers and enabling it to become an effective platform for
    serverless, cloud, and Kubernetes environments.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quarkus](https://quarkus.io)是一个全栈、面向Kubernetes的Java框架，专为Java虚拟机（JVM）和本地编译而设计，优化Java特别适合容器，并使其成为服务器无服务、云和Kubernetes环境的有效平台。'
- en: It is designed to work with popular Java standards, frameworks, and libraries
    like Eclipse MicroProfile and Spring, as well as Apache Kafka, RESTEasy (JAX-RS),
    Hibernate ORM (JPA), Infinispan, Camel, and many more. It also provides the correct
    information to GraalVM (a universal virtual machine for running apps written in
    several languages, including Java and JavaScript) for a native compilation of
    your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它设计用于与流行的Java标准、框架和库（如Eclipse MicroProfile和Spring，以及Apache Kafka、RESTEasy（JAX-RS）、Hibernate
    ORM（JPA）、Infinispan、Camel等）一起使用。它还为GraalVM（用于运行多种语言编写的应用程序的通用虚拟机，包括Java和JavaScript）提供了正确的信息，以便对应用程序进行本地编译。
- en: Quarkus is a good choice for implementing microservices architectures, and it
    provides a set of tools that help developers debug and test at ease. For our ecommerce
    store, we will start using Quarkus for the Inventory microservice (as shown in
    [Figure 2-3](#fig2-3)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus是实施微服务架构的良好选择，并提供一套工具，帮助开发人员轻松调试和测试。对于我们的电子商店，我们将开始使用Quarkus来实现库存微服务（如图2-3所示）。
- en: '![Inventory Quarkus microservice](Images/moej_0203.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![库存Quarkus微服务](Images/moej_0203.png)'
- en: Figure 2-3\. Inventory Quarkus microservice
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 库存Quarkus微服务
- en: You can find all the source code for this example in the [book’s GitHub repository](https://oreil.ly/zqbWB).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[书的GitHub仓库](https://oreil.ly/zqbWB)找到此示例的所有源代码。
- en: Create Quarkus Maven Project
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Quarkus Maven项目
- en: With Quarkus, you can scaffold a new project either with Maven or Gradle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Quarkus，您可以使用Maven或Gradle创建一个新项目。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Both Maven and Gradle are popular ways to set up a Java project and manage all
    dependencies. They differ in their dependency management strategy and they have
    different configuration formats (XML versus Kotlin DSL), but they are mostly equivalent
    in terms of capabilities. In this book, we will use Maven as it has wider support
    through IDEs and tools.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Maven和Gradle都是设置Java项目和管理所有依赖项的流行方式。它们在依赖管理策略和配置格式（XML与Kotlin DSL）上有所不同，但在功能上基本相当。在本书中，我们将使用Maven，因为它通过IDE和工具具有更广泛的支持。
- en: 'We set up a new Maven project using `quarkus-maven-plugin` with this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令设置了一个新的Maven项目，使用`quarkus-maven-plugin`：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can also bootstrap a Quarkus app with the online configurator available
    at [*https://code.quarkus.io*](https://code.quarkus.io).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用[*https://code.quarkus.io*](https://code.quarkus.io)提供的在线配置器来引导一个Quarkus应用程序。
- en: This will create a skeleton project with an `InventoryResource` class that we
    will use for implementing our ecommerce Inventory microservice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有`InventoryResource`类的骨架项目，我们将用它来实现我们的电子商务库存微服务。
- en: 'Let’s have a look at the generated *pom.xml* file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下生成的*pom.xml*文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO1-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO1-1)'
- en: Here we set up `groupId`, `artifactId`, and `version`. For a full list of available
    options, please see [Table 2-1](#quarkus_maven_project_options).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了`groupId`、`artifactId`和`version`。有关可用选项的完整列表，请参见[表2-1](#quarkus_maven_project_options)。
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO1-2)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO1-2)'
- en: Here you find the import of the Quarkus BOM, allowing you to omit the version
    on the different Quarkus dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到Quarkus BOM的导入，允许您省略不同Quarkus依赖项的版本。
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO1-3)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO1-3)'
- en: 'Here you find all the dependencies for the project, which we expressed as extensions
    to add. We’ve included:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以找到项目的所有依赖项，我们将其表示为要添加的扩展。
- en: 'JSON REST Services: This allows you to [develop REST services](https://oreil.ly/hsHvV)
    to consume and produce JSON payloads.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON REST 服务：这使您能够 [开发 REST 服务](https://oreil.ly/hsHvV) 来消费和生成 JSON 负载。
- en: 'Hibernate ORM Panache: The de facto JPA implementation offers you the full
    breadth of an Object Relational Mapper. [Hibernate ORM with Panache](https://oreil.ly/zqJDh)
    focuses on simplifying the Hibernate-based Persistence layer, making your entities
    easier to write and maintain.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate ORM Panache：这个事实上的 JPA 实现为您提供了完整的对象关系映射功能。[Hibernate ORM with Panache](https://oreil.ly/zqJDh)
    专注于简化基于 Hibernate 的持久化层，使您的实体更易编写和维护。
- en: 'Datasources (H2): [Datasources](https://oreil.ly/Q5nGV) are the main way of
    obtaining connections to a database; in this example, we will use H2, an in-memory
    database ready to use for Java apps.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源（H2）：[数据源](https://oreil.ly/Q5nGV)是获取与数据库连接的主要方式；在这个例子中，我们将使用 H2，一个内存数据库，适用于
    Java 应用程序。
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO1-4)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO1-4)'
- en: The `quarkus-maven-plugin`, which is responsible for the packaging of the application
    and also for providing the development mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-maven-plugin` 负责应用程序的打包和提供开发模式。'
- en: Table 2-1\. Quarkus Maven Project Options
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. Quarkus Maven 项目选项
- en: '| Attribute | Default Value | Description |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `projectGroupId` | `com.redhat.cloudnative` | The group id of the created
    project. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `projectGroupId` | `com.redhat.cloudnative` | 创建项目的 group id。'
- en: '| `projectArtifactId` | *mandatory* | The artifact id of the created project.
    Not passing it triggers the interactive mode. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `projectArtifactId` | *必填* | 创建项目的 artifact id。如果不传递，则触发交互模式。'
- en: '| `projectVersion` | `1.0-SNAPSHOT` | The version of the created project. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `projectVersion` | `1.0-SNAPSHOT` | 创建项目的版本。'
- en: '| `platformGroupId` | `io.quarkus` | The group id of the target platform. Given
    that all the existing platforms are coming from io.quarkus, this one won’t be
    used explicitly. But it’s still an option. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `platformGroupId` | `io.quarkus` | 目标平台的 group id。考虑到所有现有的平台都来自 io.quarkus，这个不会被显式使用。但仍然是一个选项。'
- en: '| `platformArtifactId` | `quarkus-universe-bom` | The artifact id of the target
    platform BOM. It should be quarkus-bom in order to use the locally built Quarkus.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `platformArtifactId` | `quarkus-universe-bom` | 目标平台 BOM 的 artifact id。为了使用本地构建的
    Quarkus，应该是 quarkus-bom。'
- en: '| `platformVersion` | If it’s not specified, the latest one will be resolved.
    | The version of the platform you want the project to use. It can also accept
    a version range, in which case the latest from the specified range will be used.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `platformVersion` | 如果未指定，将解析最新版本。 | 项目希望使用的平台版本。它还可以接受版本范围，此时将使用指定范围内的最新版本。'
- en: '| `className` | *Not created if omitted* | The fully qualified name of the
    generated resource. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `className` | *如果省略则不创建* | 生成的资源的完全限定名。'
- en: '| `path` | `/hello` | The resource path, only relevant if className is set.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `path` | `/hello` | 资源路径，只有在设置 className 时才相关。'
- en: '| `extensions` | `[]` | The list of extensions to add to the project (comma-separated).
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `extensions` | `[]` | 要添加到项目中的扩展列表（以逗号分隔）。'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: 'To check all the extensions available, use this command from project dir: `./mvnw
    quarkus:list-extensions`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的扩展，请使用以下命令从项目目录运行：`./mvnw quarkus:list-extensions`。
- en: Create a Domain Model
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个领域模型
- en: It’s time to write some code now and create a *domain model* and a RESTful endpoint
    to create the Inventory service. Domain model is a popular pattern in software
    engineering, and it also fits very well in the cloud native world. The level of
    abstraction given by the pattern makes it still valid as an object-oriented way
    of modeling microservices business logic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一些代码了，创建一个 *领域模型* 和一个 RESTful 端点来创建 Inventory 服务。领域模型是软件工程中的一种流行模式，它在云原生世界中也非常合适。这种模式提供的抽象级别使其作为面向对象建模微服务业务逻辑的有效方式。
- en: You can find the domain model definition in the `Inventory` class in this [book’s
    GitHub repository](https://oreil.ly/JE6CD).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这本书的 GitHub 仓库中的 `Inventory` 类中找到领域模型的定义：[book’s GitHub repository](https://oreil.ly/JE6CD)。
- en: 'Our domain model implementation consists of an `Entity` mapped to the Persistence
    layer, representing an inventory of items:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域模型实现包括一个映射到持久化层的 `Entity`，代表一个物品清单：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO2-1)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO2-1)'
- en: '`@Entity` marks the class as a JPA entity.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`标记类为JPA实体。'
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO2-2)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO2-2)'
- en: '`@Table` customizes the table creation process by defining a table name and
    database constraint in this case it is `INVENTORY`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table`通过定义表名和数据库约束来自定义表创建过程，在这种情况下是`INVENTORY`。'
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO2-3)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO2-3)'
- en: Quarkus will generate `getter/setter` for you when using public attributes and
    when you extend `PanacheEntity`. Additionally, you have an `id` attribute automatically
    added.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus将在您使用公共属性并扩展`PanacheEntity`时为您生成`getter/setter`。此外，还会自动添加`id`属性。
- en: 'Once we define the model, we can update our Properties expressed in the *application.properties*
    file in order to provide the instructions on how to populate data for our microservice:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了模型，我们可以更新我们在*application.properties*文件中表示的属性，以便提供有关如何为我们的微服务填充数据的说明：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO3-1)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO3-1)'
- en: JDBC path for the in-memory DB; this can be changed for other types of DB like
    any RDBMS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于内存DB的JDBC路径；这可以更改为其他类型的DB，如任何RDBMS。
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO3-2)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO3-2)'
- en: 'A SQL script that we’ll use to populate the Coolstore with some data:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将使用的SQL脚本，用于向Coolstore填充一些数据：
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (100000, 0);`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (100000, 0);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (329299, 35);`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (329299, 35);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (329199, 12);`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (329199, 12);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165613, 45);`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (165613, 45);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165614, 87);`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (165614, 87);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165954, 43);`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (165954, 43);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (444434, 32);`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (444434, 32);`'
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (444435, 53);`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO INVENTORY(id, quantity) VALUES (444435, 53);`'
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO3-3)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO3-3)'
- en: An `uber-jar` contains all the dependencies required packaged in the jar to
    enable running the application with `java -jar`. By default, in Quarkus, the generation
    of the `uber-jar` is disabled. With the `%prod` prefix, this option is only activated
    when building the jar intended for deployments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`uber-jar`包含所有所需的依赖项，打包在jar中以便使用`java -jar`运行应用程序。在Quarkus中，默认情况下，`uber-jar`的生成已禁用。通过`%prod`前缀，此选项仅在构建供部署用的jar时激活。'
- en: Create a RESTful Service
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RESTful服务
- en: 'Quarkus uses the JAX-RS standard for building REST services. When scaffolding
    a new project as we saw before, a *hello* example service is created in the *className*
    path we defined. Now we want to expose REST service to retrieve the number of
    available items in the store from the inventory, using the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus使用JAX-RS标准构建REST服务。当我们像之前看到的那样脚手架一个新项目时，将在我们定义的*className*路径中创建一个*hello*示例服务。现在我们想要公开REST服务以从库存中检索可用项目的数量，使用以下内容：
- en: 'Path: */api/inventory/{itemId}*;'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：*/api/inventory/{itemId}*;
- en: 'HTTP Method: `GET`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法：`GET`
- en: This returns the quantity for a given item id present in the inventory database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回库存数据库中存在的给定项目ID的数量。
- en: 'Let’s change the `InventoryResource` class definition as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`InventoryResource`类定义更改为以下内容：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO4-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO4-1)'
- en: By extending `PanacheEntity`, we’re using the active record persistence pattern
    instead of a Data Access Obect (DAO). This means that all persistence methods
    are blended with our own `Entity`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`PanacheEntity`，我们使用活动记录持久性模式而不是数据访问对象（DAO）。这意味着所有持久化方法都与我们自己的`Entity`混合。
- en: We just implemented a parametric REST endpoint for our microservice, serving
    the JSON representation of the items contained in our Coolstore. In this way we
    provided a layer to query via HTTP `GET` requests our `Inventory` Data Model we
    implemented in the previous step.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的微服务实现了一个参数化的REST端点，服务于我们Coolstore中包含的项目的JSON表示。通过这种方式，我们提供了一个通过HTTP
    `GET`请求查询我们在上一步中实现的`Inventory`数据模型的层。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: With Quarkus, there is no need to create an `Application` class. It’s supported,
    but not required. In addition, only one instance of the resource is created and
    not one per request. You can configure this using the different Scoped annotations
    (`ApplicationScoped`, `RequestScoped`, etc).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus，无需创建 `Application` 类。虽然支持，但不是必需的。此外，只创建一个资源实例，而不是每个请求创建一个。您可以使用不同的作用域注解（`ApplicationScoped`、`RequestScoped`
    等）进行配置。
- en: Run the App in Dev Mode
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发模式下运行应用程序
- en: Development mode in Quarkus is one of the coolest features we have today for
    cloud native Java development. It enables hot deployment with background compilation,
    which means that when you modify your Java files or your resource files and then
    refresh your browser, the changes automatically take effect. This also works for
    resource files such as the configuration property file. In addition, refreshing
    the browser triggers a scan of the workspace, and if any changes are detected,
    the Java files are recompiled and the application is redeployed; your request
    is then serviced by the redeployed application. If there are any issues with compilation
    or deployment, an error page will let you know.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 中，开发模式是云原生 Java 开发中最酷的功能之一。它通过热部署和后台编译实现，这意味着当你修改 Java 文件或资源文件并刷新浏览器时，更改会自动生效。这对于配置属性文件等资源文件同样有效。此外，刷新浏览器会触发对工作区的扫描，如果检测到任何更改，将重新编译
    Java 文件并重新部署应用程序；然后由重新部署的应用程序处理您的请求。如果编译或部署有任何问题，错误页面将告诉你。
- en: 'You can start the app in dev mode with a built-in Maven goal named `quarkus:dev`.
    It enables hot deployment with background compilation, which means that when you
    modify your Java files or your resource files and refresh your browser, these
    changes will automatically take effect. This also works for resource files like
    the configuration property file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的 Maven 目标 `quarkus:dev` 在开发模式下启动应用程序。它启用了热部署和后台编译，这意味着当你修改 Java 文件或资源文件并刷新浏览器时，这些更改会自动生效。这对于配置属性文件等资源文件也同样有效：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After you start the app in dev mode, you should see an output like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在你启动应用程序的开发模式后，你应该会看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the output, you can see that `Hibernate` created a database with the name
    of our domain model and populated it with some initial data defined in our Properties
    file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，`Hibernate` 创建了一个数据库，名称与我们的领域模型相同，并使用我们属性文件中定义的一些初始数据进行了填充。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When we scaffolded the project at the beginning of this chapter, we included
    a series of dependencies like Panache and used it to map our data model as `Entity`
    into a database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章开头搭建项目时，我们包含了一系列依赖项，如 Panache，并将其用作 `Entity` 映射到数据库中的数据模型。
- en: We can also see that our app is up and running, listening to port 8080\. If
    you open your browser now at [*http://localhost:8080*](http://localhost:8080),
    you will see a Quarkus welcome page (as in [Figure 2-4](#fig2-4)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到我们的应用程序正在运行，并且正在监听端口 8080。如果现在在浏览器中打开 [*http://localhost:8080*](http://localhost:8080)，你将看到一个
    Quarkus 欢迎页面（如图 [2-4](#fig2-4) 所示）。
- en: '![Quarkus Welcome Page](Images/moej_0204.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus 欢迎页面](Images/moej_0204.png)'
- en: Figure 2-4\. Quarkus welcome page
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. Quarkus 欢迎页面
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can stop the app running in Dev mode by using Ctrl-C from the same terminal
    where you launched it. When you run Quarkus 2 in Dev mode, it enables by default
    the Continuous Testing feature, where tests run immediately after code changes
    have been saved.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在启动应用程序的同一终端上使用 Ctrl-C 来停止运行开发模式下的应用程序。当你在 Quarkus 2 的开发模式下运行时，默认启用了连续测试功能，即在保存代码更改后立即运行测试。
- en: You can now try querying one of the items we inserted from the *import.sql*
    file to test if our microservice is running properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试查询我们从 *import.sql* 文件中插入的项目之一，以测试我们的微服务是否正常运行。
- en: Just navigate to [*http://localhost:8080/api/inventory/329299*](http://localhost:8080/api/inventory/329299).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 只需导航到 [*http://localhost:8080/api/inventory/329299*](http://localhost:8080/api/inventory/329299)。
- en: 'You should have the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The REST API returned a JSON object representing the inventory count for this
    product. Congratulations on your first cloud native microservice with Quarkus!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 返回了一个 JSON 对象，表示此产品的库存数量。恭喜你完成了第一个使用 Quarkus 的云原生微服务！
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We are now going to develop the other microservices that will consume this one,
    so leave this open in order to have the Coolstore up and running at the end of
    this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开发其他将使用此微服务的微服务，因此请保持打开状态，以便在本章结束时使 Coolstore 运行起来。
- en: Create a Catalog Microservice with Spring Boot
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建目录微服务
- en: '[Spring Boot](https://spring.io/projects/spring-boot) is an opinionated framework
    that makes it easy to create stand-alone [Spring-based](https://spring.io) applications
    with embedded web containers such as Tomcat (or JBoss Web Server), Jetty, and
    Undertow that you can run directly on the JVM using `java -jar`. Spring Boot also
    allows production of a war file that can be deployed on stand-alone web containers.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Spring Boot](https://spring.io/projects/spring-boot)是一种主张的框架，可以轻松创建独立的[基于Spring的](https://spring.io)应用程序，其中包括内嵌的Web容器，如Tomcat（或JBoss
    Web Server）、Jetty和Undertow，可以直接在JVM上使用`java -jar`运行。Spring Boot还允许生成可以部署在独立Web容器上的war文件。'
- en: The opinionated approach means many choices about Spring platform and third-party
    libraries are already made by Spring Boot so that you can get started with minimum
    effort and configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种主张的方法意味着关于Spring平台和第三方库的许多选择已经由Spring Boot做出，因此您可以用最少的工作量和配置开始。
- en: Spring Boot is very popular for cloud native Java development because, quoting
    the official website, it makes it easy to create stand-alone, [production-grade
    Spring-based applications](https://oreil.ly/KYWe5) that you can “just run.” We
    will include Spring Boot in our architecture for a Catalog microservice (as shown
    in [Figure 2-5](#fig2-5)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot非常适合云原生Java开发，因为它可以轻松创建独立的、[面向生产的基于Spring的应用程序](https://oreil.ly/KYWe5)，可以“一键运行”。我们将在我们的架构中包括Spring
    Boot作为目录微服务（如[图 2-5](#fig2-5)所示）。
- en: '![Catalog Spring Boot microservice](Images/moej_0205.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Catalog Spring Boot微服务](Images/moej_0205.png)'
- en: Figure 2-5\. Catalog Spring Boot microservice
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. Catalog Spring Boot微服务
- en: You can find all the source code for creating the Spring Boot microservice in
    the [book’s GitHub repository](https://oreil.ly/M8ya6).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[书的GitHub存储库](https://oreil.ly/M8ya6)中找到创建Spring Boot微服务的所有源代码。
- en: Create a Maven Project
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Maven项目
- en: Also in this case you can bootstrap your Spring Boot project either with Maven
    or Gradle. The easiest way to do this is with [Spring Initializr](https://start.spring.io),
    an online configurator that helps generate the project structure with all the
    dependencies needed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用Maven或Gradle来启动Spring Boot项目的引导。最简单的方法是使用[Spring Initializr](https://start.spring.io)，这是一个在线配置器，帮助生成带有所有必要依赖项的项目结构。
- en: In this case, we will use a Red Hat-supported Spring Boot version from [Red
    Hat Maven repositories](https://oreil.ly/mAJRs), using the Project Metadata defined
    in [Table 2-2](#spring_boot_maven_project_options).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用来自[红帽Maven仓库](https://oreil.ly/mAJRs)支持的Spring Boot版本，使用在[表 2-2](#spring_boot_maven_project_options)中定义的项目元数据。
- en: Table 2-2\. Spring Boot Maven Project Options
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. Spring Boot Maven项目选项
- en: '| Key | Value | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `modelVersion` | `4.0.0` | POM model version (always 4.0.0). |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `modelVersion` | `4.0.0` | POM模型版本（始终为4.0.0）。 |'
- en: '| `groupId` | `com.redhat.cloudnative` | Group or organization that the project
    belongs to. Often expressed as an inverted domain name. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `groupId` | `com.redhat.cloudnative` | 项目所属的组或组织。通常表示为反转的域名。 |'
- en: '| `artifactId` | `catalog` | Name to be given to the project’s library artifact
    (for example, the name of its JAR or WAR file). |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `artifactId` | `catalog` | 项目库组件的名称（例如其JAR或WAR文件的名称）。 |'
- en: '| `version` | `1.0-SNAPSHOT` | Version of the project that is being built.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `version` | `1.0-SNAPSHOT` | 正在构建的项目版本。 |'
- en: '| `name` | `CoolStore Catalog Service` | Name of the app. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `name` | `CoolStore Catalog Service` | 应用程序的名称。 |'
- en: '| `description` | `CoolStore Catalog Service with Spring Boot` | A description
    for the app. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `description` | `CoolStore Catalog Service with Spring Boot` | 应用程序的描述。 |'
- en: 'Let’s have a look at our *pom.xml* file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的*pom.xml*文件：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO5-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO5-1)'
- en: Project metadata we generated by Initializr or manually
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Initializr或手动生成的项目元数据
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO5-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO5-2)'
- en: Spring Boot version used
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的Spring Boot版本
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO5-3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO5-3)'
- en: 'Dependencies we need:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的依赖项：
- en: 'JPA: Spring Data with JPA'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA：Spring Data与JPA
- en: '[Spring Cloud](https://oreil.ly/n4oSG): support and tooling from Spring for
    cloud native Java apps'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Spring Cloud](https://oreil.ly/n4oSG)：Spring用于云原生Java应用程序的支持和工具'
- en: 'H2: an in-memory database that we will use for this purpose'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H2：我们将用于此目的的内存数据库
- en: This is a minimal Spring Boot project with support for RESTful services and
    Spring Data with JPA for connecting to a database. Any new project contains no
    code other than the main class, in this case, the `CatalogApplication` class,
    which is there to bootstrap the Spring Boot application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个支持 RESTful 服务和使用 Spring Data 与 JPA 连接数据库的最小 Spring Boot 项目。任何新项目除了主类（在本例中为
    `CatalogApplication` 类，用于引导 Spring Boot 应用程序）外都不包含代码。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/FK15g):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的 GitHub 仓库中找到它：[book’s GitHub repository](https://oreil.ly/FK15g)：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO6-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO6-1)'
- en: A convenience annotation that adds autoconfiguration and component scan, and
    also enables defining extra configurations. It is equivalent to using `@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan` with their default attributes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的注解，它添加了自动配置和组件扫描，并且还可以定义额外的配置。它等同于使用 `@Configuration`、`@EnableAutoConfiguration`
    和 `@ComponentScan` 以它们的默认属性。
- en: Create a Domain Model
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个领域模型
- en: Next, we need to provide some data to consume for our microservice representing
    the catalog of our Coolstore ecommerce website. Also here, we define a domain
    model for the high-level interaction with the Persistence layer, and an interface
    that enables the communication between a REST endpoint to expose the service and
    the data model (as shown in [Figure 2-6](#fig2-6)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一些数据来消费我们电子商务网站 Coolstore 的目录微服务。同样在这里，我们定义了一个与持久化层高级交互的领域模型，以及一个接口，用于暴露服务的
    REST 端点和数据模型之间的通信（如 [Figure 2-6](#fig2-6) 所示）。
- en: '![Data Model flow](Images/moej_0206.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![数据模型流程](Images/moej_0206.png)'
- en: Figure 2-6\. Data model flow
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 数据模型流程
- en: The database is configured using the Spring application configuration file,
    which is located in the properties file `application.properties`. Let’s have a
    look at this file to see the database connection details.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是使用 Spring 应用程序配置文件进行配置的，该文件位于 `application.properties` 属性文件中。让我们查看此文件以查看数据库连接详细信息。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/cRnE6):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的 GitHub 仓库中找到它：[book’s GitHub repository](https://oreil.ly/cRnE6)：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO7-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO7-1)'
- en: JDBC URL for H2 DB
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: H2 数据库的 JDBC URL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO7-2)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO7-2)'
- en: Use of H2 in-memory database
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 H2 内存数据库
- en: Let’s create our domain model, which is similar to the one we created for the
    Inventory microservice before.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的领域模型，这与我们之前为库存微服务创建的模型类似。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/s971w):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的 GitHub 仓库中找到它：[book’s GitHub repository](https://oreil.ly/s971w)：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO8-1)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO8-1)'
- en: '`@Entity` marks the class as a JPA entity.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity` 将类标记为 JPA 实体。'
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO8-2)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO8-2)'
- en: '`@Table` customizes the table creation process by defining a table name and
    database constraint, in this case a table named *CATALOG*.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table` 通过定义表名和数据库约束（在本例中为一个名为 *CATALOG* 的表）自定义了表创建过程。'
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO8-3)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO8-3)'
- en: '`@Id` marks the primary key for the table.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id` 标记表的主键。'
- en: Create a Data Repository
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个数据仓库
- en: Spring Data repository abstraction simplifies dealing with data models in Spring
    applications by reducing the amount of boilerplate code required to implement
    data access layers for various persistence stores. [Repository and its subinterfaces](https://oreil.ly/wUh7w)
    are the central concept in Spring Data, which is a marker interface to provide
    data manipulation functionality for the entity class that is being managed. When
    the application starts, Spring finds all interfaces marked as repositories and
    for each interface found, the infrastructure configures the required persistent
    technologies and provides an implementation for the repository interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 仓库抽象简化了在 Spring 应用程序中处理数据模型的过程，通过减少实现各种持久性存储的数据访问层所需的样板代码量。[Repository
    及其子接口](https://oreil.ly/wUh7w) 是 Spring Data 的核心概念，是为正在管理的实体类提供数据操作功能的标记接口。应用程序启动时，Spring
    查找所有标记为仓库的接口，对于每个找到的接口，基础设施会配置所需的持久技术，并为仓库接口提供实现。
- en: We will now create a new Java interface named ProductRepository in the `com.redhat.cloudnative.catalog`
    package and extend the [CrudRepository interface](https://oreil.ly/gPUjj) in order
    to indicate to Spring that you want to expose a complete set of methods to manipulate
    the entity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`com.redhat.cloudnative.catalog`包中创建一个名为 ProductRepository 的新的 Java 接口，并扩展[CrudRepository
    接口](https://oreil.ly/gPUjj)以指示 Spring 想要公开一整套方法来操作实体。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/CIGc5):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本[书的 GitHub 仓库](https://oreil.ly/CIGc5)中找到它：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO9-1)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO9-1)'
- en: '[CrudRepository](https://oreil.ly/eRvCG): interface used to indicate to Spring
    that we want to expose a complete set of methods to manipulate the entity'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[CrudRepository](https://oreil.ly/eRvCG)：用于指示 Spring 我们想要公开一整套方法来操作实体的接口'
- en: Now that we have a domain model and a repository to retrieve the domain model,
    let’s create a RESTful service that returns the list of products.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个领域模型和一个用于检索领域模型的存储库，让我们创建一个返回产品列表的 RESTful 服务。
- en: Create a RESTful Service
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 RESTful 服务
- en: 'Spring Boot uses Spring Web MVC as the default RESTful stack in Spring applications.
    We will now create a new Java class named `CatalogController` in the `com.redhat.cloudnative.catalog`
    package for that, exposing a REST endpoint. We’ll use the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 在 Spring 应用程序中使用 Spring Web MVC 作为默认的 RESTful 栈。现在我们将在`com.redhat.cloudnative.catalog`包中创建一个名为`CatalogController`的新的
    Java 类，用于公开一个 REST 端点。我们将使用以下内容：
- en: 'Path: */api/catalog/*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：*/api/catalog/*
- en: 'HTTP Method: `GET`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法：`GET`
- en: This returns a catalog for all items available in the store, matching items
    from Inventory service with data from Catalog service.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了商店中所有可用项目的目录，匹配来自 Inventory 服务的项目与来自 Catalog 服务的数据。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/SjQ4h):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本[书的 GitHub 仓库](https://oreil.ly/SjQ4h)中找到它：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO10-1)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO10-1)'
- en: '`@RequestMapping` indicates the above REST service defines an endpoint that
    is accessible via HTTP `GET` at */api/catalog*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping`表示上述 REST 服务定义了一个通过 HTTP `GET` 可访问的端点，位于*/api/catalog*。'
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO10-2)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO10-2)'
- en: Spring Boot automatically provides an implementation for `ProductRepository`
    at runtime and injects it into the controller using the [`@Autowired` annotation](https://oreil.ly/nuvh0).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 在运行时自动为`ProductRepository`提供实现，并使用[`@Autowired`注解](https://oreil.ly/nuvh0)将其注入到控制器中。
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO10-3)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO10-3)'
- en: The `repository` attribute on the controller class is used to retrieve the list
    of products from the databases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类上的`repository`属性用于从数据库中检索产品列表。
- en: 'Everything is now ready to start our second microservice, which will listen
    to port 9000 to avoid conflicts with the other one:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以启动我们的第二个微服务了，它将监听端口 9000 以避免与其他端口冲突：
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see an output like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的输出：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Your app is now listening on port *9000* to the endpoint we configured; you
    can verify it by navigating to [*http://localhost:9000/api/catalog*](http://localhost:9000/api/catalog).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在正在监听端口*9000*以及我们配置的端点；您可以通过导航至[*http://localhost:9000/api/catalog*](http://localhost:9000/api/catalog)来验证。
- en: 'You should see this output from the REST API returning a JSON object representing
    the product list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到来自 REST API 返回表示产品列表的 JSON 对象的输出：
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The output has been formatted in *pretty* mode in the book’s code listing. You’ll
    notice the combination of our items from the Quarkus Inventory microservice with
    the description and the price from the Spring Boot Catalog microservice. If you
    recall the info from the previous test with item 329299, it’s a Quarkus T-shirt.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 书中代码清单中的输出已经以*pretty*模式进行了格式化。您将注意到我们从 Quarkus Inventory 微服务中获取的项目与 Spring Boot
    Catalog 微服务中的描述和价格的组合。如果您回想起先前对项目 329299 的测试信息，那就是一件 Quarkus T 恤。
- en: Congratulations on creating your second microservice; now it’s time to connect
    a frontend to our backends. In order to do it, we will use a software API gateway
    with reactive Java in the next section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺您创建了第二个微服务；现在是时候将前端连接到我们的后端了。为了做到这一点，我们将在下一节中使用具有反应式 Java 的软件 API 网关。
- en: Create a Gateway Service with Vert.x
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vert.x 创建网关服务
- en: '[Eclipse Vert.x](https://vertx.io) is an event-driven toolkit for building
    reactive applications on the Java Virtual Machine (JVM). Vert.x does not impose
    a specific framework or packaging model; it can be used within your existing applications
    and frameworks in order to add reactive functionality by just adding the Vert.x
    jar files to the application classpath.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eclipse Vert.x](https://vertx.io) 是一个在 Java 虚拟机（JVM）上构建反应式应用程序的事件驱动工具包。Vert.x
    不强加特定的框架或打包模型；它可以在现有应用程序和框架中使用，只需将 Vert.x jar 文件添加到应用程序类路径中即可添加反应式功能。'
- en: 'Eclipse Vert.x enables building reactive systems as defined by [The Reactive
    Manifesto](https://oreil.ly/jCg8t) and builds services that are:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Vert.x 使构建符合 [反应式宣言](https://oreil.ly/jCg8t) 定义的反应式系统成为可能，并构建了以下服务：
- en: 'Responsive: to handle requests in a reasonable time'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Responsive: 处理请求的响应时间合理'
- en: 'Resilient: to stay responsive in the face of failures'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Resilient: 面对故障仍能保持响应'
- en: 'Elastic: to stay responsive under various loads and be able to scale up and
    down'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Elastic: 在各种负载下保持响应，并能够进行纵向和横向扩展'
- en: 'Message-driven: components interact using asynchronous message passing'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Message-driven: 组件使用异步消息传递进行交互'
- en: It is designed to be event-driven and nonblocking. In fact, events are delivered
    into an event loop that must never be blocked. Unlike traditional applications,
    Vert.x uses a very small number of threads responsible for dispatching the events
    to event handlers. If the event loop is blocked, the events won’t be delivered
    anymore and therefore the code needs to be mindful of this execution model (as
    shown in [Figure 2-7](#fig2-7)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它被设计为事件驱动和非阻塞的。事实上，事件被传递到一个绝不能被阻塞的事件循环中。与传统应用程序不同，Vert.x 仅使用非常少量的线程负责将事件分派给事件处理程序。如果事件循环被阻塞，事件将不再被传递，因此代码需要注意这种执行模型（如[图 2-7](#fig2-7)所示）。
- en: '![Vert.x Event Loop](Images/moej_0207.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Vert.x 事件循环](Images/moej_0207.png)'
- en: Figure 2-7\. Vert.x event loop
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. Vert.x 事件循环
- en: In our architecture, this microservice will act as an asynchronous software
    API gateway, developed as a reactive Java microservice that efficiently routes
    and dispatches the traffic to the Inventory and Catalog component of our cloud
    native ecommerce website, as displayed in [Figure 2-8](#fig2-8).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构中，这个微服务将作为一个异步软件 API 网关，开发为一个反应式 Java 微服务，它能够高效地路由和分发流量到我们的云原生电子商务网站的库存和目录组件，如[图 2-8](#fig2-8)所示。
- en: '![API Gateway Vert.x microservice](Images/moej_0208.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![API 网关 Vert.x 微服务](Images/moej_0208.png)'
- en: Figure 2-8\. API gateway Vert.x microservice
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. API 网关 Vert.x 微服务
- en: You can find the source code of this microservice in this [book’s GitHub repository](https://oreil.ly/6pe8n).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的 [GitHub 仓库](https://oreil.ly/6pe8n) 中找到这个微服务的源代码。
- en: Create a Vert.x Maven Project
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Vert.x Maven 项目
- en: Vert.x supports both Maven and Gradle, and the easiest way to bootstrap a new
    Vert.x Maven project is through [a template project structure offered by the Vert.x
    community](https://oreil.ly/fuaVI). In our case, we are using Red Hat Maven repositories
    and added the settings shown in [Table 2-3](#vertx_maven_project_options).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 支持 Maven 和 Gradle，而启动一个新的 Vert.x Maven 项目的最简单方法是通过 [Vert.x 社区提供的模板项目结构](https://oreil.ly/fuaVI)。在我们的案例中，我们使用了
    Red Hat Maven 仓库，并添加了 [表 2-3](#vertx_maven_project_options) 中显示的设置。
- en: Table 2-3\. Vert.x Maven Project Options
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. Vert.x Maven 项目选项
- en: '| Key | Value | Description |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| Key | Value | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `modelVersion` | `4.0.0` | POM model version (always 4.0.0). |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `modelVersion` | `4.0.0` | POM 模型版本（始终为 4.0.0）。 |'
- en: '| `groupId` | `com.redhat.cloudnative` | Group or organization that the project
    belongs to. Often expressed as an inverted domain name. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `groupId` | `com.redhat.cloudnative` | 项目所属的组织或机构。通常表示为倒置的域名。 |'
- en: '| `artifactId` | `gateway` | Name to be given to the project’s library artifact
    (a JAR in this case). |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `artifactId` | `gateway` | 项目库artifact（本例中为JAR文件）的名称。 |'
- en: '| `version` | `1.0-SNAPSHOT` | Version of the project that is being built.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `version` | `1.0-SNAPSHOT` | 正在构建的项目版本。 |'
- en: '| `name` | `CoolStore Gateway Service` | Name of the app. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `name` | `CoolStore 网关服务` | 应用程序的名称。 |'
- en: 'Let’s have a look at how the *pom.xml* will look:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *pom.xml* 的内容：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO11-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO11-1)'
- en: Project metadata
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 项目元数据
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO11-2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO11-2)'
- en: Vert.x version used
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的 Vert.x 版本
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO11-3)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO11-3)'
- en: '`GatewayVerticle`: the name of the main verticle; it’s the entry point for
    our app'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GatewayVerticle`：主verticle的名称；它是我们应用程序的入口点'
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO11-4)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO11-4)'
- en: 'A list of dependecies:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖列表：
- en: 'Vert.x libraries: *vertx-core*, *vertx-config*, *vertx-web*, *vertx-web-client*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x库：*vertx-core*, *vertx-config*, *vertx-web*, *vertx-web-client*
- en: '[Rx support for Vert.x](https://oreil.ly/ynXXu): vertx-rx-java2'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rx支持Vert.x](https://oreil.ly/ynXXu)：vertx-rx-java2'
- en: Create an API Gateway
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个API网关
- en: Next, we want to create an API gateway as the entry point for the web frontend
    of our website, to access all backend services from a single place. This pattern
    is predictably called [API gateway](https://oreil.ly/6oZaE) and is a common practice
    in microservices architecture.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望创建一个API网关作为我们网站的Web前端的入口点，以从一个地方访问所有后端服务。这种模式可预见地称为[API网关](https://oreil.ly/6oZaE)，在微服务架构中是一种常见做法。
- en: The unit of deployment in Vert.x is called a *verticle*. A verticle processes
    incoming events over an event loop, where events can be anything such as receiving
    network buffers, timing events, or messages sent by other verticles.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x中，部署单位称为*verticle*。 verticle在事件循环上处理传入事件，事件可以是任何内容，例如接收网络缓冲区，计时事件或其他verticle发送的消息。
- en: 'We define our main verticle as GatewayVerticle as we declared it previously
    in the *pom.xml*, and expose the REST endpoint that will be routed to the Catalog
    `/api/catalog`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主verticle定义为GatewayVerticle，因为我们之前在*pom.xml*中声明过它，并公开REST端点，该端点将路由到Catalog的`/api/catalog`：
- en: 'Path: */api/catalog/*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：*/api/catalog/*
- en: 'HTTP Method: `GET`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法：`GET`
- en: This routes the traffic to Catalog and returns a JSON object containing all
    items available in the store, matching items from Inventory service with data
    from Catalog service.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将流量路由到Catalog，并返回一个JSON对象，其中包含商店中所有可用的商品，将Inventory服务的匹配商品与Catalog服务的数据匹配。
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/vkevU):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这本[书的GitHub存储库](https://oreil.ly/vkevU)中找到它：
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO12-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO12-1)'
- en: A `Verticle` is created by extending from `AbstractVerticle` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`AbstractVerticle`类来创建一个`Verticle`。
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO12-2)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO12-2)'
- en: The `start()` method creates an HTTP server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`方法创建一个HTTP服务器。'
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO12-3)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO12-3)'
- en: A `Router` is retrieved for mapping the REST endpoints.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 检索`Router`以映射REST端点。
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO12-4)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO12-4)'
- en: A REST endpoint is created for mapping `/api/catalog` Catalog endpoint through
    a `product()` function that will retrieve the content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个REST端点，通过`product()`函数映射`/api/catalog` Catalog端点以检索内容。
- en: '[![5](Images/5.png)](#co_the_path_to_cloud_native_java_CO12-5)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_the_path_to_cloud_native_java_CO12-5)'
- en: An HTTP Server is created that listens on port 8090.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在端口8090上监听的HTTP服务器。
- en: '[![6](Images/6.png)](#co_the_path_to_cloud_native_java_CO12-6)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_the_path_to_cloud_native_java_CO12-6)'
- en: Give `Inventory` microservice a hostname and port to connect to.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Inventory`微服务提供主机名和端口以连接。
- en: '[![7](Images/7.png)](#co_the_path_to_cloud_native_java_CO12-7)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_the_path_to_cloud_native_java_CO12-7)'
- en: The microservice supports ENV vars to change its hostname and port from Properties;
    this is important for the portability of our architecture across clouds.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该微服务支持通过Properties更改其主机名和端口的ENV vars；这对我们的架构在云中的可移植性非常重要。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We use port 8090 to avoid conflict while running it in local development. The
    port number can also be changed with a property file as described in [the Vert.x
    Config doc](https://oreil.ly/OgGIP). When developing with microservices, the use
    of environment variables to map hosts and ports is highly encouraged; we use them
    to map Inventory and Catalog endpoints dynamically.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用端口8090来避免在本地开发中发生冲突。端口号也可以通过属性文件更改，如[Vert.x配置文档](https://oreil.ly/OgGIP)中所述。在使用微服务开发时，强烈建议使用环境变量来动态映射主机和端口；我们使用它们来动态映射Inventory和Catalog端点。
- en: 'We are now ready to start our API gateway:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备启动我们的API网关：
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output should be similar to this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于此：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s verify it is up and running and correctly routing traffic by navigating
    to [*http://localhost:8090/api/products*](http://localhost:8090/api/products).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到[*http://localhost:8090/api/products*](http://localhost:8090/api/products)来验证它是否已启动并正确路由流量。
- en: 'You should get the JSON object from Catalog’s endpoint, in the pretty format:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从目录的端点获取 JSON 对象，格式为漂亮的格式：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our backend is now complete. We are ready to provide some data to show from
    a nice frontend.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端现在已经完成。我们准备好提供一些数据，以展示一个漂亮的前端。
- en: Create a Frontend with Node.js and AngularJS
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 和 AngularJS 创建前端
- en: '[Node.js](https://nodejs.org) is a popular open source framework for asynchronous
    event-driven JavaScript development. Even if this is a book about modern Java
    development, in microservices architecture it is common to have a heterogeneous
    environment with multiple programming languages and frameworks involved. The challenge
    here is how to let them communicate efficiently. One solution is having a common
    interface like API gateway exchanging messages via REST calls or queue systems.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[Node.js](https://nodejs.org) 是一个流行的开源框架，用于异步事件驱动的 JavaScript 开发。即使这是一本关于现代
    Java 开发的书籍，在微服务架构中，通常会涉及多种编程语言和框架的异构环境。这里的挑战在于如何让它们有效地进行通信。一种解决方案是通过 REST 调用或队列系统交换消息的
    API 网关提供一个共同的接口。'
- en: AngularJS is a JavaScript-based frontend web framework whose goal is to simplify
    both the development and the testing of such applications by providing a framework
    for client-side model–view–controller (MVC) and model–view–viewmodel (MVVM) architectures,
    as illustrated in [Figure 2-9](#fig2-9). When used with Node.js, it provides a
    fast way to easily bootstrap a frontend.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 是一个基于 JavaScript 的前端 Web 框架，其目标是通过提供客户端模型-视图-控制器（MVC）和模型-视图-视图模型（MVVM）架构的框架，简化这类应用程序的开发和测试，如
    [Figure 2-9](#fig2-9) 所示。与 Node.js 一起使用时，它提供了一个快速启动前端的方式。
- en: '![Node.js + AngularJS Dashboard](Images/moej_0209.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js + AngularJS 仪表板](Images/moej_0209.png)'
- en: Figure 2-9\. Node.js + AngularJS Dashboard
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. Node.js + AngularJS 仪表板
- en: You can find the source code of this microservice in this [book’s GitHub repository](https://oreil.ly/fv5aa).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这本 [书籍的 GitHub 仓库](https://oreil.ly/fv5aa) 中找到这个微服务的源代码。
- en: Run the Frontend
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行前端
- en: All the HTML and JavaScript code has been prepared, and we are ready to link
    this frontend to our backends showing our Coolstore app up and running.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 HTML 和 JavaScript 代码已准备好，我们准备将此前端与我们的后端连接起来，显示我们的 Coolstore 应用程序已经运行。
- en: Get NPM
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 NPM
- en: '[NPM](https://oreil.ly/aN4J3) is a package manager for JavaScript, similar
    to Maven, that will help us download all dependencies and start our frontend.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[NPM](https://oreil.ly/aN4J3) 是一个类似于 Maven 的 JavaScript 包管理器，将帮助我们下载所有依赖项并启动我们的前端。'
- en: Install dependencies
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'We can resolve all dependencies within the `web-nodejs` directory and by launching
    the `npm` command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `web-nodejs` 目录中解析所有依赖项，并通过启动 `npm` 命令来完成。
- en: '[PRE23]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get an output like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到这样的输出：
- en: '[PRE24]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Start the app
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: We are now ready to verify if our frontend can correctly consume the backend
    services through the API gateway, mapping images with the data received. Since
    we are in local development, we will use the environment variable to change the
    Node.js default port to avoid conflicts. We will also use an environment variable
    to map the API gateway REST endpoint, as shown in [Table 2-4](#frontend_environment_variables).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已准备好验证我们的前端是否能正确地通过 API 网关消费后端服务，映射图像与接收到的数据。由于我们处于本地开发环境，我们将使用环境变量将 Node.js
    的默认端口更改为避免冲突。我们还将使用一个环境变量来映射 API 网关的 REST 端点，如 [Table 2-4](#frontend_environment_variables)
    所示。
- en: Table 2-4\. Frontend environment variables
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. 前端环境变量
- en: '| ENV | Value | Description |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| ENV | Value | Description |'
- en: '| --- | --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `PORT` | 3000 | Global env for Node.js to map the port to use for starting
    the process; we use 3000 in this case. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `PORT` | 3000 | 全局环境变量，用于 Node.js 映射用于启动进程的端口；在这种情况下我们使用 3000。'
- en: '| `COOLSTORE_GW_ENDPOINT` | `http://localhost:8090` | Enviroment variable defined
    in the frontend to map the API gateway service hostname. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `COOLSTORE_GW_ENDPOINT` | `http://localhost:8090` | 在前端定义的环境变量，用于映射 API 网关服务的主机名。'
- en: 'Start the app with this command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动应用程序：
- en: '[PRE25]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Navigate to the address where we exposed our Node.js app at [*http://localhost:3000*](http://localhost:3000).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 转到我们公开的 Node.js 应用程序的地址 [*http://localhost:3000*](http://localhost:3000)。
- en: Congratulations! Your cloud native Coolstore ecommerce website is up and running
    now; you can verify it in [Figure 2-10](#fig2-10).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的云原生 Coolstore 电子商务网站现在已经运行起来了；您可以在 [Figure 2-10](#fig2-10) 中验证它。
- en: '![Coolstore Demo complete](Images/moej_0210.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Coolstore 演示完成](Images/moej_0210.png)'
- en: Figure 2-10\. Coolstore demo complete
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. Coolstore 演示完成
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through a complete microservices-based architecture
    implementation, using different Java frameworks for different components. We gave
    an overview on how to split the typical monolithic approach into a more diverse
    and heterogeneous environment, lightweight and ready to run in multiple contexts
    such as local development or production systems. This is an example of what we
    call cloud native development.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们走过了一个完整的基于微服务的架构实现，使用不同的Java框架来实现各个组件。我们概述了如何将典型的单片式方法拆分为更多样化和异构化的环境，轻量且能够在多种场景下运行，比如本地开发或生产系统。这是我们所称的云原生开发的一个示例。
