- en: Chapter 4\. The Document Management System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。文档管理系统
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: After successfully implementing an advanced Bank Statements Analyzer for Mark
    Erbergzuck you decide to run some errands—including going to an appointment with
    your dentist. Dr. Avaj has run her practice successfully for many years. Her happy
    patients retain their white teeth well into old age. The downside of such a successful
    practice is that every year more and more patient documents get generated. Every
    time she needs to find a record of prior treatment, her assistants spend longer
    and longer searching their filing cabinets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 成功为Mark Erbergzuck实施了先进的银行对账单分析器后，您决定做些杂事——包括去看牙医。Avaj博士成功地经营了她的诊所多年。她的快乐患者在老年时依然保持着洁白的牙齿。这样一个成功实践的缺点是，每年都会生成更多的患者文件。每次她需要找到早期治疗记录时，她的助手们花费的时间越来越长。
- en: She realizes that it’s time to automate the process of managing these documents
    and keeping track of them. Luckily, she has a patient who can do that for her!
    You are going to help by writing software for her that manages these documents
    and enables her to find the information that will allow her practice to thrive
    and grow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 她意识到现在是自动化管理这些文件并跟踪它们的时间了。幸运的是，她有一个可以为她做这些的患者！您将通过为她编写软件来管理这些文件，并使她能够找到信息，以便她的实践能够茁壮成长。
- en: The Goal
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: In this chapter you’ll be learning about a variety of different software development
    principles. Key to the design of managing documents is an inheritance relationship,
    which means extending a class or implementing an interface. In order to do this
    the right way you’ll get to understand the Liskov Substitution Principle, named
    after famed computer scientist Barbara Liskov.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习各种软件开发原则。管理文档设计的关键在于继承关系，这意味着扩展一个类或实现一个接口。为了正确地做到这一点，您将了解Liskov替换原则，这是以著名计算机科学家芭芭拉·利斯科夫命名的。
- en: Your understanding of when to use inheritance will get fleshed out with a discussion
    of the “Composition over Inheritance” principle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过讨论“组合优于继承”原则，您将进一步了解何时使用继承。
- en: Finally, you’ll extend your knowledge of how to write automated test code by
    understanding what makes a good and maintainable test. Now that we’ve spoiled
    the plot of this chapter, let’s get back to understanding what requirements Dr.
    Avaj has for the Document Management System.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过理解如何编写良好且易维护的自动化测试代码来扩展你的知识。既然我们已经剧透了这一章的内容，让我们回到理解Avaj博士对文档管理系统的需求。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If at any point you want to look at the source code for this chapter, you can
    look at the package `com.iteratrlearning.shu_book.chapter_04` in the book’s code
    repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想随时查看本章的源代码，可以查看书的代码库中的`com.iteratrlearning.shu_book.chapter_04`包。
- en: Document Management System Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档管理系统需求
- en: 'A friendly cup of tea with Dr. Avaj has revealed that she has the documents
    that she wants to manage as files on her computer. The Document Management System
    needs to be able to import these files and record some information about each
    file that can be indexed and searched. There are three types of documents that
    she cares about:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与Avaj博士友好地喝茶后，她透露她希望将她想要管理的文件作为计算机上的文件。文档管理系统需要能够导入这些文件，并记录每个文件的一些信息，这些信息可以被索引和搜索。她关心的文档类型有三种：
- en: Reports
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 报告
- en: A body of text detailing some consultation of operation on a patient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述对患者进行的某些咨询或手术的文本内容。
- en: Letters
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 信件
- en: A text document that gets sent to an address. (You’re probably familiar with
    these already, come to think of it.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到地址的文本文档。（想想看，你可能已经很熟悉这些了。）
- en: Images
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图像
- en: The dental practice often records x-rays or photos of teeth and gums. These
    have a size.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 牙科实践经常记录牙齿和牙龈的X光或照片。这些都有一个大小。
- en: In addition, all documents need to record the path to the file that is being
    managed and what patient the document is about. Dr. Avaj needs to be able to search
    these documents, and query whether each of the attributes about a different type
    of document contains certain pieces of information; for example, to search for
    letters where the body contains “Joe Bloggs.”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有文档都需要记录被管理文件的路径以及文档所涉及的患者。Avaj博士需要能够搜索这些文档，并查询关于不同类型文档的每个属性是否包含某些信息；例如，搜索正文包含“Joe
    Bloggs”的信件。
- en: During the conversation, you also established that Dr. Avaj might wish to add
    other types of documents in the future.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈话中，你还确认 Avaj 博士可能希望在将来添加其他类型的文档。
- en: Fleshing Out the Design
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善设计
- en: When approaching this problem, there are lots of big design choices to make
    and modeling approaches that we could take. These choices are subjective, and
    you’re welcome to try to code up a solution to Dr. Avaj’s problem before or after
    reading this chapter. In [“Alternative Approaches”](#alternative_approaches) you
    can see the reasons why we avoid different choices and the overarching principles
    behind them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题时，有很多重要的设计选择和建模方法可以选择。这些选择是主观的，你可以在阅读本章之前或之后尝试编写解决 Avaj 博士问题的解决方案。在[“替代方法”](#alternative_approaches)中，你可以看到我们避免不同选择的原因以及背后的基本原则。
- en: One good first step to approaching any program is to start with test-driven
    development (TDD), which is what we did when writing the book’s sample solution.
    We won’t be covering TDD until [Chapter 5](ch05.xhtml#chapter_05), so let’s begin
    with thinking about the behaviors that your software needs to perform and incrementally
    fleshing out the code that implements these behaviors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接近任何程序的一个很好的第一步是采用测试驱动开发（TDD），这也是我们在编写书中示例解决方案时所做的。我们将在第5章[第5章](ch05.xhtml#chapter_05)介绍TDD，所以让我们开始考虑你的软件需要执行的行为，并逐步完善实现这些行为的代码。
- en: 'The Document Management System should be able to import documents on request
    and add them into its internal store of documents. In order to fulfill this requirement,
    let’s create the `DocumentManagementSystem` class and add two methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文档管理系统应该能够根据请求导入文档，并将它们添加到其内部的文档存储中。为了满足这一要求，让我们创建 `DocumentManagementSystem`
    类并添加两个方法：
- en: '`void importFile(String path)`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`void importFile(String path)`'
- en: Takes a path to a file that our user wants to import to the Document Management
    System. As this is a public API method that might take input from users in a production
    system, we take our path as a `String` rather than relying on a more type-safe
    class like `java.nio.Path` or `java.io.File`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户想要导入到文档管理系统的文件的路径。由于这是一个公共API方法，在生产系统中可能会接收来自用户的输入，所以我们将路径作为 `String` 而不是依赖更类型安全的类，如
    `java.nio.Path` 或 `java.io.File`。
- en: '`List<Document> contents()`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<Document> contents()`'
- en: Returns a list of all the documents that the Document Management System currently
    stores.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文档管理系统当前存储的所有文档的列表。
- en: You’ll notice that `contents()` returns a list of some `Document` class. We’ve
    not said what this class entails yet, but it’ll reappear in due course. For now,
    you can pretend that it’s an empty class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `contents()` 返回一个 `Document` 类的列表。我们尚未说明这个类包含什么，但它会适时出现。目前，你可以假装它是一个空类。
- en: Importers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入器
- en: A key characteristic of this system is that we need to be able to import documents
    of different types. For the purposes of this system you can rely on the files’
    extensions in order to decide how to import them, since Dr. Avaj has been saving
    files with very specific extensions. All her letters have the *.letter* extension,
    reports have *.report*, and *.jpg* is the only image format used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的一个关键特性是，我们需要能够导入不同类型的文档。为了这个系统的目的，你可以依赖文件的扩展名来决定如何导入它们，因为 Avaj 博士一直在保存具有非常特定扩展名的文件。她所有的信件都使用
    *.letter* 扩展名，报告使用 *.report*，而 *.jpg* 是唯一使用的图片格式。
- en: The simplest thing to do would be to just throw all the code for the importing
    mechanism into a single method, as shown in [Example 4-1](#bad_eg_switch).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的做法是将所有导入机制的代码都放在一个方法中，就像[示例4-1](#bad_eg_switch)中所示。
- en: Example 4-1\. Switch of extension example
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-1\. 扩展名切换示例
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach would have solved the problem in question but would be hard to
    extend. Every time you want to add another type of file that gets processed you
    would need to implement another entry in the `switch` statement. Over time this
    method would become intractably long and hard to read.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以解决问题，但很难扩展。每次想要添加另一种要处理的文件类型时，你都需要在 `switch` 语句中实现另一个条目。随着时间的推移，这种方法会变得难以管理和阅读。
- en: If you keep your main class nice and simple and split out different implementation
    classes for importing different types of documents, then it’s easy to locate and
    understand each importer in isolation. In order to support different document
    types, an `Importer` interface is defined. Each `Importer` will be a class that
    can import a different type of file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保持你的主类简单明了，并分割出不同的实现类来导入不同类型的文档，那么很容易找到并理解每个导入器的作用。为了支持不同的文档类型，定义了一个`Importer`接口。每个`Importer`将是一个可以导入不同类型文件的类。
- en: 'Now that we know we need an interface to import the files, how should we represent
    the file that is going to be imported? We have a couple of different options:
    use a plain `String` to represent the path of the file, or use a class that represents
    a file, like `java.io.File`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们需要一个接口来导入文件，那么应该如何表示将要导入的文件呢？我们有几种不同的选择：使用简单的`String`表示文件的路径，或者使用表示文件的类，例如`java.io.File`。
- en: 'You could make the case that we should apply the principle of strong typing
    here: take a type that represents the file and reduce the scope for errors versus
    using a `String`. Let’s take that approach and use a `java.io.File` object as
    the parameter in our `Importer` interface to represent the file being imported,
    as shown in [Example 4-2](#importer_definition).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说我们应该在这里应用强类型原则：选择一个表示文件并减少错误范围的类型，而不是使用`String`。让我们采用这种方法，并在我们的`Importer`接口中使用`java.io.File`对象作为表示要导入的文件的参数，如[示例 4-2](#importer_definition)所示。
- en: Example 4-2\. Importer
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 导入器
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You might be asking, *Why don’t you use a `File` for the public API of `DocumentManagementSystem`
    as well then?* Well, in the case of this application, our public API would probably
    be wrapped up in some kind of user interface, and we aren’t sure what form that
    is taking files in. As a result we kept things simple and just used a `String`
    type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，*为什么你不在`DocumentManagementSystem`的公共API中也使用`File`呢？*好吧，在这个应用程序的情况下，我们的公共API可能会被包装在某种用户界面中，我们不确定以文件形式存在的形式。因此，我们保持事情简单，只使用了`String`类型。
- en: The Document Class
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档类
- en: Let’s also define the `Document` class at this point in time. Each document
    will have multiple attributes that we can search on. Different documents have
    different types of attributes. We have several different options that we can consider
    the pros and cons of when defining the `Document`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一时间点上，让我们也定义`Document`类。每个文档将有多个我们可以搜索的属性。不同的文档有不同类型的属性。在定义`Document`时，我们有几个不同的选项可以权衡其利弊。
- en: The first and simplest way to represent a document would be to use a `Map<String,
    String>`, which is a map from attribute names to values associated with those
    attributes. So why not just pass a `Map<String, String>` around through the application?
    Well, introducing a domain class to model a single document is not just drinking
    the OOP Koolaid, but also provides a series of practical improvements in application
    maintability and readability.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表示文档的第一种最简单的方法是使用`Map<String, String>`，这是一个从属性名称到与这些属性相关联的值的映射。那么为什么不在整个应用程序中传递一个`Map<String,
    String>`呢？引入一个领域类来模拟单个文档不仅仅是在遵循面向对象编程思想，而且还提供了一系列实际的应用程序维护性和可读性的改进。
- en: For a start, the value of giving concrete names to components within an application
    cannot be overstated. Communication is King! Good teams of software developers
    use a *Ubiquitous Language* to describe their software. Matching the vocabulary
    that you use within the code of your application to the vocabulary that you use
    to talk to clients like Dr. Avaj makes things a lot easier to maintain. When you
    have a conversation with a colleague or client you will invariably need to agree
    upon some common language with which to describe different aspects of the software.
    By mapping this to the code itself, it makes it really easy to know what part
    of the code to change. This is called *discoverability*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，给应用程序中的组件起具体的名称的价值无法估量。沟通至上！优秀的软件开发团队使用*普遍语言*来描述他们的软件。将你在应用程序代码中使用的词汇与与像阿瓦吉博士这样的客户交流时使用的词汇相匹配，可以极大地简化维护工作。当你与同事或客户交流时，你必须一致同意描述软件不同方面的一些共同语言。通过将其映射到代码本身，可以轻松知道需要更改代码的哪一部分。这被称为*可发现性*。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The term *Ubiquitous Language* was coined by Eric Evans and originates in *Domain
    Driven Design*. It refers to the use of a common language that is clearly degined
    and shared between both developers and users.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*普遍语言*这个术语是由Eric Evans创造的，起源于*领域驱动设计*。它指的是一种清晰定义且在开发人员和用户之间共享的通用语言。'
- en: 'Another principle that should encourage you to introduce a class to model a
    document is strong typing. Many people use this term to refer to the nature of
    a programming language, but here we’re talking about the more practical use of
    strong typing in implementing your software. Types allow us to restrict the way
    in which data is used. For example, our `Document` class is immutable: once it
    has been created you can’t change, or *mutate*, any of its attributes. Our `Importer`
    implementations create the documents; nothing else modifies them. If you ever
    see a `Document` with an error in one of its attributes, you can narrow the source
    of the bug down to the specific `Importer` that created the `Document`. You can
    also infer from the immutability that it’s possible to index or cache any information
    associated with the `Document` and you know that it will be correct forever, since
    documents are immutable.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 引入一个类来模拟文档的原则之一是强类型。许多人使用这个术语来指代编程语言的性质，但这里我们讨论的是在实现软件时强类型的更实际用途。类型允许我们限制数据的使用方式。例如，我们的`Document`类是不可变的：一旦创建，就无法改变或*突变*其任何属性。我们的`Importer`实现创建文档；没有其他东西可以修改它们。如果你看到某个`Document`中有错误的属性，你可以将bug的来源缩小到特定创建该`Document`的`Importer`。你还可以从不可变性推断出，可以对与`Document`关联的任何信息进行索引或缓存，并且知道它将永远正确，因为文档是不可变的。
- en: Another design choice that developers might consider when modeling their `Document`
    would be make the `Document` extend `HashMap<String, String>`. At first that seems
    great because the `HashMap` has all the functionality you need to model a `Document`.
    However, there are several reasons why this is a bad choice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在建模其`Document`时可能考虑的另一个设计选择是将`Document`扩展为`HashMap<String, String>`。乍看之下，这似乎很棒，因为`HashMap`具有建模`Document`所需的所有功能。然而，有几个理由说明这是一个糟糕的选择。
- en: Software design is often as much about restricting functionality that is undesirable
    as it is about building things that you do want. We would have instantly thrown
    away the aforementioned benefits from immutability by allowing anything in the
    application to modify the `Document` class if it were just a subclass of `HashMap`.
    Wrapping the collection also gives us an opportunity to give more meaningful names
    to the methods, instead of, for example, looking up an attribute by calling the
    `get()` method, which doesn’t really mean anything! Later on we’ll go into more
    detail about inheritance versus composition, because this is really a specific
    example of that discussion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计往往不仅仅是关于构建所需功能，还涉及限制不希望的功能。如果仅仅是`HashMap`的子类，我们将立即丢弃不可变性带来的前述好处。包装集合还为我们提供了一个机会，可以为方法提供更有意义的名称，而不是例如通过调用`get()`方法查找属性，这实际上并不意味着任何东西！稍后我们将更详细地讨论继承与组合，因为这实际上是该讨论的一个具体例子。
- en: In short, domain classes allow us to name a concept and restrict the possible
    behaviors and values of this concept in order to improve discoverability and reduce
    the scope for bugs. As a result, we’ve chosen to model the `Document` as shown
    in [Example 4-3](#document_definition). If you’re wondering why it isn’t `public`
    like most interfaces, this is discussed later in [“Scoping and Encapsulation Choices”](#importer_scoping).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，领域类允许我们命名一个概念，并限制该概念的行为和值的可能性，以提高发现性并减少错误的范围。因此，我们选择如示例[4-3](#document_definition)中所示地对`Document`进行建模。如果你想知道为什么它不像大多数接口那样是`public`，这将在[“作用域和封装选择”](#importer_scoping)中讨论。
- en: Example 4-3\. Document
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 文档
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One final thing to note about `Document` is that it has a package-scoped constructor.
    Often Java classes make their constructor `public`, but this can be a bad choice
    as it allows code anywhere in your project to create objects of that type. Only
    code in the Document Management System should be able to create `Documents`, so
    we keep the constructor package scoped and restrict access to only the package
    that the Document Management System lives in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，`Document` 类具有包范围的构造函数。通常情况下，Java 类会将它们的构造函数设置为 `public`，但这可能是一个不好的选择，因为它允许项目中任何位置的代码创建该类型的对象。只有文档管理系统中的代码应该能够创建
    `Documents`，因此我们将构造函数的访问权限限制在包内，并仅限于文档管理系统所在的包。
- en: Attributes and Hierarchical Documents
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和分层文档
- en: In our `Document` class we used `Strings` for attributes. Doesn’t this go against
    the principle of strong typing? The answer here is yes and no. We are storing
    attributes as text so that they can be searched through a text-based search. Not
    only that, but we want to ensure that all attributes are created in a very generic
    form that is independent of the `Importer` that created them. `Strings` aren’t
    a bad choice as such in this context. It should be noted that passing `Strings`
    around throughout an application in order to represent information is often considered
    a bad idea. In contrast with something being strongly typed, this is termed stringly
    typed!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Document` 类中，我们使用 `Strings` 来表示属性。这难道不违背了强类型的原则吗？答案既是肯定的，也是否定的。我们将属性存储为文本，以便可以通过基于文本的搜索进行搜索。不仅如此，我们还希望确保所有属性都以非常通用的形式创建，这种形式与创建它们的
    `Importer` 无关。在这种上下文中，`Strings` 并不是一个坏选择。应该注意的是，在整个应用程序中传递 `Strings` 以表示信息通常被认为是一个不好的做法。与强类型相比，这被称为“stringly
    typed”！
- en: In particular, if more complicated use was being made of the attribute values,
    then having different attribute types parsed out would be useful. For example,
    if we wanted to be able to find addresses within a certain distance or images
    with a height and width less than a certain size, then having strongly typed attributes
    would be a boon. It would be a lot easier to make comparisons with a width value
    that is an integer. In the case of this Document Management System, however, we
    simply don’t need that functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果属性值的使用更加复杂，那么解析出不同的属性类型将会很有用。例如，如果我们想要在某个距离内找到地址，或者找到高度和宽度小于某个尺寸的图片，那么拥有强类型的属性将会是一个福音。使用整数作为宽度值进行比较会更加容易。然而，在这个文档管理系统的情况下，我们并不需要那种功能。
- en: You could design the Document Management System with a class hierarchy for `Documents`
    that models the `Importer` hierarchy. For example, a `ReportImporter` imports
    instances of the `Report` class that extends the `Document` class. This passes
    our basic sanity check for subclassing. In other words, it allows you to say a
    `Report` is a `Document` and it makes sense as a sentence. We chose not to go
    down that direction, however, as the right way to model classes in an OOP setting
    is to think in terms of behavior and data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设计文档管理系统，为 `Documents` 创建一个类层次结构，该结构模拟了 `Importer` 的层次结构。例如，`ReportImporter`
    导入扩展了 `Document` 类的 `Report` 类的实例。这通过了我们的基本合理性检查，即它允许您说 `Report` 是一个 `Document`，这在语义上是有意义的。然而，我们选择不沿着这个方向继续进行，因为在面向对象编程设置中，正确的类建模方法是从行为和数据的角度思考。
- en: 'The documents are all modeled very generically in terms of named attributes,
    rather than specific fields that exist within different subclasses. Additionally,
    as far as this system is concerned, documents have very little behavior associated
    with them. There was simply no point in adding a class hierarchy here when it
    provided no benefit. You might think that this statement in and of itself is a
    little arbitrary, but it informs us of another principle: KISS.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文档都以命名属性的通用方式进行建模，而不是在不同子类中存在的特定字段。此外，在该系统中，文档几乎没有关联的行为。在这里添加类层次结构毫无意义。您可能认为这个说法本身有些武断，但它告诉我们另一个原则：KISS。
- en: You learned about the KISS principle in [Chapter 2](ch02.xhtml#chapter_02).
    KISS means that designs are better if they are kept simple. It’s often very hard
    to avoid unnecessary complexity, but it’s worth trying hard to do so. Whenever
    someone says, “we might need X” or “it would be cool if we also did Y,” just say
    No. Bloated and complex designs are paved with good intentions around extensibility
    and code that is a nice-to-have rather than must-have.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第2章](ch02.xhtml#chapter_02)学到了KISS原则。KISS的意思是如果设计保持简单，就会更好。要避免不必要的复杂往往非常困难，但努力尝试是值得的。每当有人说“我们可能需要X”或者“如果我们也做Y会很酷”的时候，只需要说不。臃肿和复杂的设计往往以扩展性和代码“好玩而非必需”的良好意图铺成了路。
- en: Implementing and Registering Importers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现和注册导入者
- en: You can implement the `Importer` interface to look up different types of files.
    [Example 4-4](#image_importer_definition) shows the way that images are imported.
    One of the great things about Java’s core library is that it provides a lot of
    built-in functionality right out of the box. Here we read an image file using
    the `ImageIO.read` method and then extract the width and height of the image from
    the resulting `BufferedImage` object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实现`Importer`接口来查找不同类型的文件。[示例 4-4](#image_importer_definition)展示了导入图像的方式。Java核心库的一个伟大之处在于它提供了很多开箱即用的内置功能。在这里，我们使用`ImageIO.read`方法读取图像文件，然后从生成的`BufferedImage`对象中提取图像的宽度和高度。
- en: Example 4-4\. ImageImporter
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. ImageImporter
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Attribute names are constants defined in the `Attributes` class. This avoids
    bugs where different importers end up using different strings for the same attribute
    name; for example, `"Path"` versus `"path"`. Java itself doesn’t have a direct
    concept of a constant as such, [Example 4-5](#constant_example) shows the commonly
    used idiom. This constant is `public` because we want to be able to use it from
    different importers, though you may well have a `private` or `package` scoped
    constant instead. The use of the `final` keyword ensures that it can’t be reassigned
    to and `static` ensures that there is only a single instance per class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称在`Attributes`类中被定义为常量。这样做可以避免不同的导入者使用相同属性名称的不同字符串而导致的错误；例如，`"Path"`和`"path"`。Java本身没有常量的直接概念，[示例 4-5](#constant_example)展示了通常使用的习语。这个常量是`public`的，因为我们希望能够从不同的导入者中使用它，尽管您可能更喜欢使用`private`或`package`作用域的常量。使用`final`关键字确保它不可重新赋值，`static`确保每个类只有一个实例。
- en: Example 4-5\. How to define a constant in Java
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 如何在Java中定义常量
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are importers for all three different types of files and you will see
    the other two implemented in [“Extending and Reusing Code”](#extending_and_iterating).
    Don’t worry, we’re not hiding anything up our sleeves. In order to be able to
    use the `Importer` classes when we import files, we also need to register the
    importers to look them up. We use the extension of the file that we want to import
    as the key of the `Map`, as shown in [Example 4-6](#importer_lookup).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三种不同类型的文件都有导入者，您将看到其他两种实现在[“扩展和重用代码”](#extending_and_iterating)中。别担心，我们没有任何花招。为了能够在导入文件时使用`Importer`类，我们还需要注册导入者以进行查找。我们使用要导入的文件的扩展名作为`Map`的键，如[示例 4-6](#importer_lookup)所示。
- en: Example 4-6\. Registering the importers
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 注册导入者
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you know how to import documents, we can implement search. We won’t
    be focusing on the most efficient way to implement searching of documents here
    since we’re not trying to implement Google, just get the information to Dr. Avaj
    that she requires. A conversation with Dr. Avaj revealed that she wanted to be
    able to look up information about different attributes of a `Document`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何导入文档，我们可以实现搜索。我们不会在这里专注于实现文档搜索的最有效方法，因为我们并不打算实现Google，只是将所需信息传递给Avaj博士。与Avaj博士的对话表明，她希望能够查找`Document`的不同属性的信息。
- en: Her requirements could be met by just being able to find subsequences within
    attribute values. For example, she might want to search for documents that have
    a patient called Joe, and with *Diet Coke* in the body. We thus devised a very
    simple query language that consisted of a series of attribute name and substring
    pairs separated by commas. Our aforementioned query would be written as `"patient:Joe,body:Diet
    Coke"`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 她的需求可能仅仅是能够在属性值中查找子序列。例如，她可能希望搜索具有名为Joe的患者和体内有*Diet Coke*的文档。因此，我们设计了一个非常简单的查询语言，由一系列以逗号分隔的属性名称和子字符串对组成。我们之前提到的查询将被编写为`"patient:Joe,body:Diet
    Coke"`。
- en: Since the search implementation keeps things simple rather than trying to be
    highly optimized, it just does a linear scan over all the documents recorded in
    the system and tests each one against the query. The query `String` that is passed
    to the `search` method is parsed into a `Query` object that can then be tested
    against each `Document`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于搜索实现保持简单而不是试图高度优化，它只是在系统中记录的所有文档上进行线性扫描，并测试每个文档是否符合查询。传递给`search`方法的查询`String`被解析为一个`Query`对象，然后可以与每个`Document`进行测试。
- en: The Liskov Substitution Principle (LSP)
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则（LSP）
- en: We’ve talked about a few specific design decisions related to classes—for example,
    modeling different `Importer` implementations with classes, and why we didn’t
    introduce a class hierarchy for the `Document` class and why we didn’t just make
    `Document` extend `HashMap`. But really there’s a broader principle at stake here,
    one that allows us to generalize these examples into an approach that you can
    use in any piece of software. This is called the *Liskov Substitution Principle*
    (LSP) and it helps us understand how to subclass and implement interfaces correctly.
    LSP forms the L of the SOLID principles that we’ve been referring to throughout
    this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了与类相关的一些特定设计决策，例如，使用类来建模不同的`Importer`实现，以及为什么我们没有为`Document`类引入类层次结构，也为什么我们没有将`Document`直接扩展为`HashMap`。但实际上这里涉及到一个更广泛的原则，一个允许我们将这些例子推广到任何软件片段的原则。这就是*里氏替换原则*（LSP），它帮助我们正确地子类化和实现接口。LSP是我们在整本书中一直在提到的SOLID原则中的L。
- en: 'The Liskov Substitution Principle is often stated in these very formal terms,
    but is actually a very simple concept. Let’s demystify some of this terminology.
    If you hear *type* in this context, just think of a class or an interface. The
    term *subtype* means establish a parent-to-child relationship between types; in
    other words, extend a class or implement an interface. So informally you can think
    of this as meaning that child classes should maintain the behavior they inherit
    from their parents. We know, we know—it sounds like an obvious statement, but
    we can be more specific and split out LSP into four distinct parts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 里氏替换原则通常以非常正式的术语来陈述，但实际上是一个非常简单的概念。让我们揭开其中的一些术语。如果在这个背景下听到*类型*，只需将其视为类或接口。术语*子类型*意味着在类型之间建立了父子关系；换句话说，扩展了一个类或实现了一个接口。因此，你可以非正式地将其视为子类应该保持从父类继承的行为。我们知道，听起来像是一个显而易见的陈述，但我们可以更具体地将LSP分解为四个不同的部分：
- en: Preconditions cannot be strengthened in a subtype
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件不能在子类型中被加强。
- en: A precondition establishes the conditions under which some code will work. You
    can’t just assume what you’ve written will work anyway, anyhow, anywhere. For
    example, all our `Importer` implementations have the precondition that the file
    being imported exists and is readable. As a result, the `importFile` method has
    validation code before any `Importer` is invoked, as can be seen in [Example 4-7](#importFile_validation).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件建立了某些代码将工作的条件。你不能仅仅假设你所写的无论如何都会工作。例如，我们所有的`Importer`实现都有一个前置条件，即要导入的文件存在且可读。因此，在调用任何`Importer`之前，`importFile`方法都有验证代码，正如在[示例 4-7](#importFile_validation)中所示。
- en: Example 4-7\. importFile definition
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. importFile定义
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: LSP means that you can’t require any more restrictive preconditions than your
    parent required. So, for example, you can’t require your document to be smaller
    than 100KB in size if your parent should be able to import any size of document.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: LSP意味着你不能要求比你的父类更严格的前置条件。因此，例如，如果你的父类应该能够导入任何大小的文档，你就不能要求你的文档大小必须小于100KB。
- en: Postconditions cannot be weakened in a subtype
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件不能在子类型中被削弱。
- en: This might sound a bit confusing because it reads a lot like the first rule.
    Postconditions are things that have to be true after some code has run. For example,
    after `importFile()` has run, if the file in question is valid it must be in the
    list of documents returned by `contents()`. So if the parent has some kind of
    side effect or returns some value, then the child must do so as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点混淆，因为它读起来很像第一条规则。后置条件是在某些代码运行后必须为真的事物。例如，在运行`importFile()`后，如果所讨论的文件有效，则它必须在`contents()`返回的文档列表中。因此，如果父类具有某种副作用或返回某个值，则子类也必须如此。
- en: Invariants of the supertype must be preserved in a subtype
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 超类型的不变量必须在子类型中被保留。
- en: An invariant is something that never changes, like the ebb and flow of the tides.
    In the context of inheritance, we want to make sure that any invariants that are
    expected to be maintained by the parent class should also be maintained by the
    children.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是永远不会改变的东西，就像潮汐的涨落一样。在继承的上下文中，我们希望确保父类预期维护的任何不变性也应该由子类维护。
- en: The History Rule
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 历史规则
- en: This is the hardest aspect of LSP to understand. In essence, the child class
    shouldn’t allow state changes that your parent disallowed. So, in our example
    program we have an immutable `Document` class. In other words, once it has been
    instantiated you can’t remove, add, or alter any of the attributes. You shouldn’t
    subclass this `Document` class and create a mutable `Document` class. This is
    because any user of the parent class would expect certain behavior in response
    to calling methods on the `Document` class. If the child were mutable, it could
    violate callers’ expectations about what calling those methods does.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理解 LSP 最困难的方面。本质上，子类不应允许状态变更，而父类不允许。因此，在我们的示例程序中，我们有一个不可变的 `Document` 类。换句话说，一旦被实例化，就不能删除、添加或修改任何属性。你不应该派生这个
    `Document` 类并创建一个可变的 `Document` 类。这是因为父类的任何用户都期望在调用 `Document` 类的方法时得到特定的行为。如果子类是可变的，它可能会违反调用者对调用这些方法时所期望的行为。
- en: Alternative Approaches
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代方法
- en: You could have taken a completely different approach when it comes to designing
    the Document Management System. We’ll take a look at some of these alternatives
    now as we think they are instructive. None of the choices could be considered
    wrong as such, but we do think the chosen approach is best.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计文档管理系统时，您完全可以采取完全不同的方法。我们现在将介绍一些这些替代方法，因为我们认为它们是有教育意义的。这些选择没有一个可以被认为是错的，但我们确实认为选择的方法是最好的。
- en: Making Importer a Class
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Importer 设计为一个类
- en: You could have chosen to make a class hierarchy for importers, and have a class
    at the top for the `Importer` rather than an interface. Interfaces and classes
    provide a different set of capabilities. You can implement multiple interfaces,
    while classes can contain instance fields and it’s more usual to have method bodies
    in classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择为导入器创建一个类层次结构，而不是一个接口。接口和类提供了不同的功能集。您可以实现多个接口，而类可以包含实例字段，并且在类中具有方法体更为常见。
- en: In this case the reason to have a hierarchy is to enable different importers
    to be used. You’ve already heard about our motivation for avoiding brittle class-based
    inheritance relationships, so it should be pretty clear that using interfaces
    is a better choice here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构建层次结构的原因是为了使不同的导入器能够被使用。您已经听说过我们避免脆弱的基于类的继承关系的动机，因此在这里使用接口应该是一个很明智的选择。
- en: That’s not to say that classes wouldn’t be a better choice elsewhere. If you
    want to model a strong *is a* relationship in your problem domain that involves
    state or a lot of behavior, then class-based inheritance is more appropriate.
    It’s just not the choice we think is most appropriate here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说在其他地方类不是更好的选择。如果您想在涉及状态或大量行为的问题域中建模强大的 *是一个* 关系，则基于类的继承更合适。只是我们认为在这里使用接口是更合适的选择。
- en: Scoping and Encapsulation Choices
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域和封装选择
- en: If you have taken the time to peruse the code you might notice that the `Importer`
    interface, its implementations, and our `Query` class are all package scoped.
    Package scope is the default scope, so if you see a class file with `class Query`
    at the top you know it’s package scoped, and if it says `public class Query` it’s
    public scoped. Package scoping means that other classes within the same package
    can *see* or *have access* to the class, but no one else can. It’s a cloaking
    device.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您花时间查看代码，您可能会注意到 `Importer` 接口、它的实现以及我们的 `Query` 类都具有包范围。包范围是默认范围，因此如果您看到一个类文件顶部是
    `class Query`，您就知道它是包范围的；如果它说 `public class Query`，则是公共范围。包范围意味着同一包中的其他类可以*看到*或*访问*该类，但其他人不能。这是一种隐身装置。
- en: A strange thing about the Java ecosystem is that even though package scope is
    the default scope, whenever we’ve been involved in software development projects
    there are always more `public`-scoped classes than package-scoped ones. Perhaps
    the default should have been `public` all along, but either way package scope
    is a really useful tool. It helps you encapsulate these kinds of design decisions.
    A lot of this section has commented on the different choices that are available
    to you around designing the system, and you may want to refactor to one of these
    alternative designs when maintaining the system. This would be harder if we leaked
    details about this implementation outside of the package in question. Through
    diligent use of package scoping you can stop classes outside of the package making
    so many assumptions about that internal design.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Java 生态系统的一个奇怪之处在于，尽管包范围是默认范围，但每当我们参与软件开发项目时，始终有比包范围更多的`public`范围的类。也许默认应该一直是`public`，但无论如何，包范围确实是一个非常有用的工具。它帮助您封装这些设计决策。本节大部分内容都评论了围绕设计系统可用的不同选择，并且在维护系统时可能希望重构为其中一种替代设计。如果我们泄露有关此包之外实现的详细信息，这将更加困难。通过勤奋地使用包范围，您可以阻止包外的类对内部设计做出过多假设。
- en: We think it’s also worth reiterating that this is simply a justification and
    explanation of these design choices. There’s nothing inherently wrong with making
    other choices listed in this section—they may work out to be more appropriate
    depending on how the application evolves over time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为值得重申的是，这只是对这些设计选择的辩解和解释。在本节列出的其他选择中，没有任何本质上的错误—它们可能会根据应用程序随时间演变而更合适。
- en: Extending and Reusing Code
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和重用代码
- en: When it comes to software, the only constant is change. Over time you may want
    to add features to your product, customer requirements may change, and regulations
    could force you alter your software. As we alluded to earlier, there may be more
    documents that Dr. Avaj would like to add to our Document Management System. In
    fact, when we first came to showcase the software that we’ve written for her she
    immediately realized that invoicing clients was something that she also wanted
    to keep track of in this system. An invoice is a document with a body and an amount
    and has an *.invoice* extension. [Example 4-8](#eg_invoice) shows an example invoice.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到软件，唯一不变的是变化。随着时间的推移，您可能希望向产品添加功能，客户需求可能会改变，法规可能会强制您修改软件。正如我们早些时候所提到的，阿瓦博士可能希望将更多文档添加到我们的文档管理系统中。事实上，当我们首次展示为她编写的软件时，她立即意识到要在此系统中跟踪客户发票。发票是一个具有正文和金额的文档，并具有
    *.invoice* 扩展名。[示例 4-8](#eg_invoice) 展示了一个发票示例。
- en: Example 4-8\. Invoice example
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 发票示例
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fortunately for us, all of Dr. Avaj’s invoices are in the same format. As you
    can see, we need to extract an amount of money from this, and the amount line
    starts with the `Amount:` prefix. The person’s name is at the beginning of the
    letter on a line with the prefix `Dear`. In fact, our system implements a general
    method of finding the suffix of a line with a given prefix, shown in [Example 4-9](#addLineSuffix).
    In this example, the field `lines` has already been initialized with the lines
    of the file that we’re importing. We pass this method a `prefix`—for example,
    “Amount:”—and it associates the rest of the line, the suffix, with a provided
    attribute name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，阿瓦博士的所有发票都采用相同的格式。正如您所见，我们需要从中提取一笔金额，而金额行以`Amount:`为前缀开始。信件的收件人姓名位于以`Dear`为前缀的行开头。事实上，我们的系统实现了一种通用的方法来查找给定前缀行的后缀，如
    [示例 4-9](#addLineSuffix) 所示。在这个例子中，字段`lines`已经初始化为我们正在导入的文件的行。我们向这个方法传递一个`prefix`—例如，“Amount:”—它将将行的其余部分，即后缀，与提供的属性名称关联起来。
- en: Example 4-9\. addLineSuffix definition
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. addLineSuffix 定义
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We in fact have a similar concept when we try to import a letter. Consider the
    example letter presented in [Example 4-10](#eg_letter). Here you can extract the
    name of the patient by looking for a line starting with `Dear`. Letters also have
    addresses and bodies of text that you want to extract from the contents of the
    text file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们尝试导入一封信时，我们有类似的概念。考虑 [示例 4-10](#eg_letter) 中提供的示例信件。在这里，您可以通过查找以`Dear`开头的行来提取患者的姓名。信件还具有地址和文本主体，您希望从文本文件的内容中提取出来。
- en: Example 4-10\. Letter example
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 信件示例
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We also have a similar problem when it comes to importing patient reports. Dr.
    Avaj’s reports prefix the name of the patient with `Patient:` and have a body
    of text to include, just like letters. You can see an example of a report in [Example 4-11](#eg_report).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及导入患者报告时，我们也面临类似的问题。Avaj博士的报告将患者的姓名前缀设置为`Patient:`，并包含一段要包含的文本，就像信件一样。你可以在[Example 4-11](#eg_report)中看到一个报告示例。
- en: Example 4-11\. Report example
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 报告示例
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So one option here would be to have all three text-based importers implement
    the same method to find the suffixes of text lines with a given prefix that was
    listed in [Example 4-9](#addLineSuffix). Now if we were charging Dr. Avaj based
    on the number of lines of code that we had written, this would be a great strategy.
    We could triple the amount of money that we would make for basically the same
    work!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的一个选择是让所有三个基于文本的导入器实现同一个方法，用于查找带有在[Example 4-9](#addLineSuffix)中列出的前缀的文本行的后缀。现在，如果我们按照编写的代码行数向Avaj博士收费，这将是一个很好的策略。我们可以为基本相同的工作三倍赚取更多的钱！
- en: 'Sadly (or maybe not so sadly, given the aforementioned incentives), customers
    rarely pay based on the number of lines of code produced. What matters are the
    requirements that the customer wants. So we really want to be able to reuse this
    code across the three importers. In order to reuse the code we need to actually
    have it live in some class. You have essentially three options to consider, each
    with pros and cons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（或者说幸运的是，考虑到上述的激励因素），客户很少根据所产生的代码行数付费。重要的是客户想要的需求。所以我们真的希望能够在三个导入器之间重用这段代码。为了重用这段代码，我们需要确实将其放在某个类中。你基本上有三个选择，每个选择都有其利弊：
- en: Use a *utility* class
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*实用*类
- en: Use *inheritance*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*继承*
- en: Use a domain class
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用领域类
- en: The simplest option to start with is to create a utility class. You could call
    this `ImportUtil`. Then every time you wanted to have a method that needs to be
    shared between different importers it could go in this utility class. Your utility
    class would end up being a bag of static methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的开始选项是创建一个实用类。你可以称其为`ImportUtil`。然后，每当你想要在不同的导入器之间共享方法时，可以将其放入此实用类中。你的实用类最终将成为一堆静态方法的集合。
- en: While a utility class is nice and simple, it’s not exactly the pinnacle of object-oriented
    programming. The object-oriented style involves having concepts in your application
    be modeled by classes. If you want to create a thing, then you invoke `new Thing()`
    for whatever your thing is. Attributes and behavior associated with the thing
    should be methods on the `Thing` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实用类很简单，但它并不完全是面向对象编程的顶峰。面向对象的风格包括通过类来模拟应用程序中的概念。如果你想创建一个东西，那么你调用`new Thing()`，用于你的东西。与该东西相关的属性和行为应该是`Thing`类的方法。
- en: If you follow this principle of modeling real-world objects as classes, it does
    genuinely make it easier to understand your application because it gives you a
    structure and maps a mental model of your domain onto your code. You want to alter
    the way that letters are imported? Well then edit the `LetterImporter` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循将现实世界对象建模为类的原则，确实会更容易理解你的应用程序，因为它为你提供了一个结构，并将你领域的心理模型映射到你的代码中。你想改变信件导入的方式？那么就编辑`LetterImporter`类。
- en: Utility classes violate this expectation and often end up turning into bundles
    of procedural code with no single responsibility or concept. Over time, this can
    often lead to the appearance of a God Class in our codebase; in other words, a
    single large class that ends up hogging a lot of responsibility.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实用类违反了这一预期，通常最终会变成一堆过程化代码，没有单一的责任或概念。随着时间的推移，这往往会导致我们代码库中出现上帝类的出现；换句话说，一个单一的大类最终会占据大量责任。
- en: So what should you do if you want to associate this behavior to a concept? Well,
    the next most obvious approach might be to use inheritance. In this approach you
    would have the different importers extend a `TextImporter` class. You could then
    place all the common functionality on that class and reuse it in subclasses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你想将这种行为与一个概念关联起来，你该怎么办？嗯，下一个最明显的方法可能是使用继承。在这种方法中，你可以让不同的导入器扩展`TextImporter`类。然后你可以将所有共同的功能放在这个类上，并在子类中重用它。
- en: Inheritance is a perfectly solid choice of design in many circumstances. You’ve
    already seen the Liskov Substitution Principle and how it puts constraints on
    the correctness of our inheritance relationship. In practice, inheritance is often
    a poor choice when the inheritance fails to model some real-world relationship.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，继承是一种非常稳固的设计选择。您已经看到了 Liskov 替换原则及其如何对我们的继承关系的正确性施加约束。在实践中，当继承关系未能模拟某些真实世界的关系时，继承往往是一个不好的选择。
- en: In this case, a `TextImporter` is an `Importer` and we can ensure that our classes
    follow the LSP rules, but it doesn’t really seem like a strong concept to work
    with. The issue with inheritance relationships that don’t correspond to real-world
    relationships is that they tend to be brittle. As your application evolves over
    time you want abstractions that evolve with the application rather than against
    it. As a rule of thumb, it’s a bad idea to introduce an inheritance relationship
    purely to enable code reuse.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`TextImporter` 是一个 `Importer`，我们可以确保我们的类遵循 LSP 规则，但这似乎并不是一个很强的概念来进行工作。继承关系不符合真实世界关系的问题在于它们往往是脆弱的。随着应用程序随时间的演变，您希望抽象与应用程序一起演变，而不是相反。作为一个经验法则，纯粹为了启用代码重用而引入继承关系是一个不好的想法。
- en: Our final choice is to model the text file using a domain class. To use this
    approach we would model some underlying concept and build out our different importers
    by invoking methods on top of the underlying concept. So what’s the concept in
    question here? Well, what we’re really trying to do is manipulate the contents
    of a text file, so let’s call the class a `TextFile`. It’s not original or creative,
    but that’s the point. You know where the functionality for manipulating text files
    lies, because the class is named in a really dead simple manner.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终选择是使用域类来建模文本文件。要使用这种方法，我们将模拟一些基础概念，并通过调用顶层方法来构建不同的导入器。那么这里问题的概念是什么？嗯，我们真正想做的是操作文本文件的内容，所以让我们称这个类为
    `TextFile`。这并不是原创或创意，但这正是重点所在。您知道在哪里找到操作文本文件的功能，因为类的命名非常简单明了。
- en: '[Example 4-12](#textfile_definition) shows the definition of the class and
    its fields. Note that this isn’t a subclass of a `Document` because a document
    shouldn’t be coupled to just text files—we may import binary files like images
    as well. This is just a class that models the underlying concept of a text file
    and has associated methods for extracting data from text files.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-12](#textfile_definition) 显示了该类及其字段的定义。请注意，这不是 `Document` 的子类，因为文档不应仅限于文本文件
    - 我们可能还会导入诸如图像等的二进制文件。这只是一个模拟文本文件的基础概念的类，并具有从文本文件中提取数据的相关方法。'
- en: Example 4-12\. TextFile definition
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. TextFile 定义
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the approach that we pick in the case of importers. We think this allows
    us to model our problem domain in a flexible way. It doesn’t tie us into a brittle
    inheritance hierarchy, but still allows us to reuse the code. [Example 4-13](#invoice_importer_impl)
    shows how to import invoices. The suffixes for the name and amount are added,
    along with setting the type of the invoice to be an amount.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在导入器案例中选择的方法。我们认为这样可以以灵活的方式对我们的问题域进行建模。它不会将我们束缚在脆弱的继承层次结构中，但仍然允许我们重用代码。[示例 4-13](#invoice_importer_impl)
    展示了如何导入发票。为名称和金额添加了后缀，并设置发票类型为金额。
- en: Example 4-13\. Importing invoices
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 导入发票
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can also see another example of an importer that uses the `TextFile` class
    in [Example 4-14](#letter_importer_impl). No need to worry about how `TextFile.addLines`
    is implemented; you can see an explanation of that in [Example 4-15](#addLines_definition).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到另一个使用 `TextFile` 类的导入器示例在 [示例 4-14](#letter_importer_impl)。不需要担心 `TextFile.addLines`
    的实现方式；您可以在 [示例 4-15](#addLines_definition) 中看到对其的解释。
- en: Example 4-14\. Importing letters
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 导入信件
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These classes weren’t first written like this, though. They evolved into their
    current state. When we started coding up the Document Management System, the first
    text-based importer, the `LetterImporter`, had all of its text extraction logic
    written inline in the class. This is a good way to start. Trying to seek out code
    to reuse often results in inappropriate abstractions. Walk before you run.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类一开始并不是这样编写的。它们逐渐演变到当前的状态。当我们开始编写文档管理系统时，第一个基于文本的导入器 `LetterImporter`，它的所有文本提取逻辑都是内联编写在类中的。这是一个很好的开始。试图寻找可以重用的代码通常会导致不适当的抽象化。先学会走再考虑奔跑。
- en: As we started writing the `ReportImporter` it become increasingly apparent that
    a lot of the text extraction logic could be shared between the two importers,
    and that really they should be written in terms of method invocations upon some
    common domain concept that we have introduced here—the `TextFile`. In fact, we
    even copy and pasted the code that was to be shared between the two classes to
    begin with.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写 `ReportImporter` 时，越来越明显的是文本提取逻辑可以在这两个导入器之间共享，并且它们实际上应该是基于我们在这里引入的某些共同领域概念的方法调用—`TextFile`。事实上，我们甚至复制并粘贴了最初要在两个类之间共享的代码。
- en: That isn’t to say that copy and pasting code is good—far from it. But it’s often
    better to duplicate a little bit of code when you start writing some classes.
    Once you’ve implemented more of the application, the right abstraction—e.g., a
    `TextFile` class will become apparent. Only when you know a little bit more about
    the right way to remove duplication should you go down the route of removing the
    duplication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着复制粘贴代码是好的——远非如此。但是，当您开始编写某些类时，往往最好复制少量的代码。一旦您实现了更多的应用程序，正确的抽象—例如 `TextFile`
    类将变得显而易见。只有当您对去除重复代码的正确方法有了更多了解后，才应该采用去重复的路线。
- en: In [Example 4-15](#addLines_definition) you can see how the `TextFile.addLines`
    method was implemented. This is common code used by different `Importer` implementations.
    Its first argument is a `start` index, which tells you which line number to start
    on. Then there’s an `isEnd` predicate that is applied to the line and returns
    `true` if we’ve reached the end of the line. Finally, we have the name of the
    attribute that we’re going to associate with this value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 4-15](#addLines_definition) 中，您可以看到 `TextFile.addLines` 方法的实现方式。这是不同 `Importer`
    实现中常见的代码。它的第一个参数是一个 `start` 索引，用于指示从哪一行开始。接着是一个 `isEnd` 断言，用于检查是否到达行的结尾并返回 `true`。最后，我们有要与此值关联的属性名称。
- en: Example 4-15\. addLines definition
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. addLines 定义
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Test Hygiene
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试卫生
- en: As you learned in [Chapter 2](ch02.xhtml#chapter_02), writing automated tests
    has a lot of benefits in terms of software maintainability. It enables us to reduce
    the scope for regressions and understand which commit caused them. It also enables
    us to refactor our code with confidence. Tests aren’t a magic panacea, though.
    They require that we write and maintain a lot of code in order to get these benefits.
    As you know, writing and maintaining code is a difficult proposition, and many
    developers find that when they first start writing automated tests that they can
    take a lot of developer time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [第二章](ch02.xhtml#chapter_02) 中所学到的，编写自动化测试在软件可维护性方面有很多好处。它使我们能够减少回归范围，并了解导致回归的提交。它还使我们能够自信地重构我们的代码。然而，测试并不是一个神奇的灵丹妙药。它们要求我们编写并维护大量的代码，以便获得这些好处。众所周知，编写和维护代码是一个困难的任务，许多开发者发现，当他们开始编写自动化测试时，这会占用大量的开发时间。
- en: In order to solve the problem of test maintainability you need to get to grips
    with *test hygiene*. Test hygiene means to keep your test code clean and ensure
    that it is maintained and improved along with your codebase under test. If you
    don’t maintain and treat your tests, over time they will become a burden on your
    developer productivity. In this section you’ll learn about a few key points that
    can help to keep tests hygienic.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决测试可维护性的问题，您需要掌握*测试卫生*。测试卫生意味着保持您的测试代码整洁，并确保随着受测试的代码库一起进行维护和改进。如果您不维护和处理您的测试，随着时间的推移，它们将成为影响开发者生产力的负担。在本节中，您将了解到一些关键点，这些点可以帮助保持测试的卫生。
- en: Test Naming
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试命名
- en: The first thing to think about when it comes to tests is their naming. Developers
    can get highly opinionated about naming—it’s an easy topic to talk about a lot
    because everyone can relate to it and think about the problem. We think the thing
    to remember is that there’s rarely a clear, really good name for something, but
    there are many, many, bad names.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到测试时，首先要考虑的是它们的命名。开发者对命名可能有很强的个人意见——因为每个人都可以与此相关并思考这个问题，所以这是一个容易大谈特谈的话题。我们认为需要记住的是，很少有一个清晰、真正好的名称可以适用于某件事情，但有很多很多个糟糕的名称。
- en: The first test we wrote for the Document Management System was testing that
    we import a file and create a `Document`. This was written before we had introduced
    the concept of an `Importer` and weren’t testing `Document`-specific attributes.
    The code is in [Example 4-16](#shouldImportFile).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文档管理系统编写的第一个测试是测试我们导入一个文件并创建一个`Document`。这是在我们引入`Importer`概念之前编写的，并且没有测试`Document`特定的属性。代码在[示例 4-16](#shouldImportFile)中。
- en: Example 4-16\. Test for importing files
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 导入文件的测试
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This test was named `shouldImportFile`. The key driving principles when it comes
    to test naming are readability, maintainability, and acting as *executable documentation*.
    When you see a report of a test class being run, the names should act as statements
    that document what functionality works and what does not. This allows a developer
    to easily map from application behavior to a test that asserts that this behavior
    is implemented. By reducing the impedence mismatch between behavior and code,
    we make it easier for other developers to understand what is happening in the
    future. This is a test that confirms that the document management system imports
    a file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试被命名为`shouldImportFile`。在测试命名方面的关键驱动原则是可读性、可维护性和作为*可执行文档*的功能。当您看到测试类运行的报告时，这些名称应该作为说明文档，记录哪些功能可用，哪些不可用。这允许开发人员轻松地从应用程序行为映射到断言该行为被实现的测试。通过减少行为和代码之间的阻抗不匹配，我们使其他开发人员更容易理解未来发生的情况。这是一个确认文档管理系统导入文件的测试。
- en: There are lots of naming anti-patterns, however. The worst anti-pattern is to
    name a test something completely nondescript—for example, `test1`. What on earth
    is `test1` testing? The reader’s patience? Treat people who are reading your code
    like you would like them to treat you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有很多命名反模式。最糟糕的反模式是给一个测试命名为完全不明确的东西——例如，`test1`。`test1`在测试什么？读者的耐心？对待阅读你代码的人，就像你希望他们对待你一样。
- en: Another common test naming anti-pattern is just named after a concept or a noun—for
    example, `file` or `document`. Test names should describe the behavior under test,
    not a concept. Another test naming anti-pattern is to simply name the test after
    a method that is invoked during testing, rather than the behavior. In this case
    the test might be named `importFile`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的测试命名反模式是仅以概念或名词命名，例如，`file`或`document`。测试名称应描述测试的行为，而不是一个概念。另一个测试命名反模式是仅将测试命名为在测试期间调用的方法，而不是行为。在这种情况下，测试可能被命名为`importFile`。
- en: You might ask, by naming our test `shouldImportFile` haven’t we committed this
    sin here? There’s some merit to the accusation, but here we’re just describing
    the behavior under test. In fact, the `importFile` method is tested by various
    tests; for example, `shouldImportLetterAttributes`, `shouldImportReportAttributes`,
    and `shouldImportImageAttributes`. None of those tests are called `importFile`—they
    are all describing more specific behaviors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，通过将我们的测试命名为`shouldImportFile`，我们是否在这里犯了这个罪？这种指责有一定的道理，但在这里我们只是描述了正在测试的行为。事实上，`importFile`方法由各种测试进行测试；例如，`shouldImportLetterAttributes`、`shouldImportReportAttributes`和`shouldImportImageAttributes`。这些测试都没有被称为`importFile`——它们都描述了更具体的行为。
- en: 'OK, now you know what bad naming looks like, so what is good test naming? You
    should follow three rules of thumb and use them to drive test naming:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你知道了不良命名是什么样子，那么好的测试命名是什么呢？您应该遵循三个经验法则，并使用它们来驱动测试命名：
- en: Use domain terminology
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用领域术语
- en: Align the vocabulary used in your test names with that used when describing
    the problem domain or referred by the application itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试名称中使用的词汇与描述问题域或应用程序本身引用的词汇保持一致。
- en: Use natural language
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自然语言
- en: Every test name should be something that you can easily read as a sentence.
    It should always describe some behavior in a readable way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试名称都应该是您可以轻松读成一句话的东西。它应该以可读的方式描述某种行为。
- en: Be descriptive
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性
- en: Code will be read many times more often than it is written. Don’t skimp on spending
    more time thinking of a good name that’s descriptive up front and easier to understand
    later down the line. If you can’t think of a good name, why not ask a colleague?
    In golf, you win by putting in the fewest shots. Programming isn’t like that;
    shortest isn’t necessarily best.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将被阅读的次数比被编写的次数多得多。不要吝惜花更多时间考虑一个好的、描述性的名字，这样后来理解起来会更容易。如果你想不出一个好的名字，为什么不问问同事呢？在高尔夫球中，你通过尽量少的击球次数来获胜。编程不是这样的；最短的不一定是最好的。
- en: You can follow the convention used in the `DocumentManagementSystemTest` of
    prefixing test names with the word “should,” or choose not to; that’s merely a
    matter of personal preference.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照`DocumentManagementSystemTest`中使用的约定，使用“should”作为测试名称的前缀，也可以选择不这样做；这只是个人偏好的问题。
- en: Behavior Not Implementation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为而非实现
- en: If you’re writing a test for a class, a component, or even a system, then you
    should only be testing the *public behavior* of whatever is being tested. In the
    case of the Document Management System, we only have tests for the behavior of
    our public API in the form of `DocumentManagementSystemTest`. In this test we
    test the public API of the `DocumentManagementSystem` class and thus the whole
    system. The API can be seen in [Example 4-17](#dms_api).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为一个类、一个组件甚至是一个系统编写测试，那么你应该只测试被测试对象的*公共行为*。在文档管理系统的情况下，我们只测试我们的公共 API 的行为，其形式为`DocumentManagementSystemTest`。在这个测试中，我们测试了`DocumentManagementSystem`类的公共
    API，因此也测试了整个系统。你可以在[示例 4-17](#dms_api)中查看该 API。
- en: Example 4-17\. Public API of the DocumentManagementSystem class
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. `DocumentManagementSystem`类的公共 API
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our tests should only invoke these public API methods and not try to inspect
    the internal state of the objects or the design. This is one of the key mistakes
    made by developers that leads to hard-to-maintain tests. Relying on specific implementation
    details results in brittle tests because if you change the implementation detail
    in question, the test can start to fail even if the behavior is still working.
    Take a look at the test in [Example 4-18](#shouldImportLetterAttributes).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试应该只调用这些公共 API 方法，而不应尝试检查对象或设计的内部状态。这是开发人员常犯的一个关键错误，导致难以维护的测试。依赖于特定的实现细节会导致脆弱的测试，因为如果更改了相关的实现细节，即使行为仍然正常，测试也可能开始失败。查看[示例 4-18](#shouldImportLetterAttributes)中的测试。
- en: Example 4-18\. Test for importing letters
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 导入信函的测试
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One way of testing this letter-importing functionality would have been to write
    the test as a unit test on the `LetterImporter` class. This would have looked
    fairly similar: importing an example file and then making an assert about the
    result returned from the importer. In our tests, though, the mere existence of
    the `LetterImporter` is an implementation detail. In [“Extending and Reusing Code”](#extending_and_iterating),
    you saw numerous other alternative choices for laying out our importer code. By
    laying out our tests in this manner, we give ourselves the choice to refactor
    our internals to a different design without breaking our tests.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个信函导入功能的一种方式本来可以写成一个关于`LetterImporter`类的单元测试。这看起来可能非常相似：导入一个示例文件，然后对导入器返回的结果进行断言。然而，在我们的测试中，`LetterImporter`的存在本身就是一个实现细节。在[“扩展和重用代码”](#extending_and_iterating)中，你看到了许多其他布局导入器代码的选择。通过这种方式布置我们的测试，我们给自己提供了在不破坏测试的情况下重构内部结构的选择。
- en: So we’ve said that relying on the behavior of a class relies on using the public
    API, but there’s also some parts of the behavior that aren’t usually restricted
    just through making methods public or private. For example, we might not want
    to rely on the order of documents being being returned from the `contents()` method.
    That isn’t a property that’s restricted by the public API of the `DocumentManagementSystem`
    class, but simply something that you need to be careful to avoid doing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们说依赖于类的行为是通过使用公共 API 来实现的，但也有一些行为部分通常不仅仅通过使方法公共或私有来限制。例如，我们可能不希望依赖于从`contents()`方法返回的文档顺序。这不是`DocumentManagementSystem`类的公共
    API 的属性，而只是需要小心避免的事情。
- en: A common anti-pattern in this regard is exposing otherwise private state through
    a getter or setter in order to make testing easier. You should try to avoid doing
    this wherever possible as it makes your tests brittle. If you have exposed this
    state to make testing superficially easier, then you end up making maintaining
    your application harder in the long run. This is because any change to your codebase
    that involves changing the way this internal state is represented now also requires
    altering your tests. This is sometimes a good indication that you need to refactor
    out a new class that can be more easily and effectively tested.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面的一个常见反模式是通过getter或setter公开本来是私有状态以便于测试。尽可能避免这样做，因为这会使您的测试变得脆弱。如果您已经公开了这个状态以使测试表面上更容易，那么最终会使得长期维护您的应用程序变得更加困难。这是因为任何涉及更改内部状态表示方式的代码库更改现在也需要修改您的测试。有时这是需要重构出一个新类来更容易和有效地进行测试的一个很好的指示。
- en: Don’t Repeat Yourself
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: '[“Extending and Reusing Code”](#extending_and_iterating) extensively discusses
    how we can remove duplicate code from our application and where to place the resulting
    code. The exact same reasoning around maintenance applies equally to test code.
    Sadly, developers often simply don’t bother to remove duplication from tests in
    the same way as they would for application code. If you take a look at [Example 4-19](#shouldImportImageAttributes)
    you’ll see a test that repeatedly makes asserts about the different attributes
    that a resulting `Document` has.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[“扩展和重用代码”](#extending_and_iterating)广泛讨论了如何从我们的应用程序中删除重复代码以及放置生成代码的位置。关于维护的确切推理同样适用于测试代码。不幸的是，开发人员通常简单地不去像处理应用程序代码一样去除测试中的重复代码。如果您查看[示例 4-19](#shouldImportImageAttributes)，您会看到一个测试重复地对生成的`Document`的不同属性进行断言。'
- en: Example 4-19\. Test for importing images
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-19\. 导入图片的测试
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Normally you would have to look up the attribute name for every attribute and
    assert that it is equal to an expected value. In the case of the tests here, this
    is a common enough operation that a common method, `assertAttributeEquals`, was
    extracted with this logic. Its implementation is shown in [Example 4-20](#assertAttributeEquals).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您需要查找每个属性的属性名称并断言它是否等于预期值。在这些测试中，这是一个足够常见的操作，一个通用方法`assertAttributeEquals`被提取出来具备这种逻辑。其实现在[示例 4-20](#assertAttributeEquals)中展示。
- en: Example 4-20\. Implementing a new assertion
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20\. 实现一个新的断言
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Good Diagnostics
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的诊断信息
- en: Tests would be no good if they didn’t fail. In fact, if you’ve never seen a
    test fail how do you know if it’s working at all? When writing tests the best
    thing to do is to optimize for failure. When we say optimize, we don’t mean make
    the test run faster when it fails—we mean ensure that it is written in a way that
    makes understanding why and how it failed as easy as possible. The trick to this
    is good *diagnostics*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试永远不失败，那就没有好的测试。事实上，如果您从未见过测试失败，那么怎么知道它是否有效呢？在编写测试时，最好的做法是优化失败情况。当我们说优化时，我们并不是指测试在失败时运行得更快——而是确保测试编写方式使得理解为什么以及如何失败尽可能容易。这其中的技巧在于良好的*诊断信息*。
- en: By diagnostics we mean the message and information that gets printed out when
    a test fails. The clearer this message is about what has failed, the easier it
    is to debug the test failure. You might ask why even bother with this when a lot
    of the time Java tests are run from within modern IDEs that have debuggers built
    in? Well, sometimes tests may be run within continuous integration environments,
    and sometimes they may be from the command line. Even if you’re running them within
    an IDE it is still helpful to have good diagnostic information. Hopefully, we’ve
    convinced you of the need for good diagnostics, but what do they look like in
    code?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过诊断信息，我们指的是测试失败时打印出的消息和信息。消息越清晰说明失败原因，调试测试失败就越容易。你可能会问，为什么要在现代 IDE 中运行 Java
    测试时还要打印诊断信息？有时测试可能在持续集成环境中运行，有时可能从命令行运行。即使在 IDE 中运行，拥有良好的诊断信息仍然非常有帮助。希望我们已经说服了您需要良好诊断信息的重要性，那么在代码中它们是什么样的呢？
- en: '[Example 4-21](#onlyDocument) shows a method that asserts that the system only
    contains a single document. We will explain the `hasSize()` method in a little
    bit.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-21](#onlyDocument)展示了一种断言系统仅包含单个文档的方法。稍后我们会解释`hasSize()`方法。'
- en: Example 4-21\. Test that the system contains a single document
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 测试系统是否包含单个文档
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The simplest type of assert that JUnit offers us is `assertTrue()`, which will
    take a boolean value that it expects to be true. [Example 4-22](#eg_assertTrue)
    shows how we could have just used `assertTrue` to implement the test. In this
    case the value is being checked to equal `0` so that it will fail the `shouldImportFile`
    test and thus demonstrate the failure diagnostics. The problem with this is that
    we don’t get very good diagnostics—just an `AssertionError` with no information
    in the message shown in [Figure 4-1](#fig0401). You don’t know what failed, and
    you don’t know what values were being compared. You know nothing, even if your
    name isn’t Jon Snow.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit提供给我们的最简单的断言类型是`assertTrue()`，它将采取一个期望为真的布尔值。[示例4-22](#eg_assertTrue)展示了我们如何只使用`assertTrue`来实现测试。在这种情况下，正在检查的值等于`0`，以便它将使`shouldImportFile`测试失败，从而展示失败的诊断。问题在于我们得不到很好的诊断信息——只是一个没有任何信息的`AssertionError`在[图4-1](#fig0401)中显示。你不知道什么失败了，也不知道比较了什么值。你一无所知，即使你的名字不是乔恩·雪诺。
- en: Example 4-22\. assertTrue example
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-22\. `assertTrue`示例
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![assertTrue example](Images/rwsd_0401.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![assertTrue示例](Images/rwsd_0401.png)'
- en: Figure 4-1\. Screenshot of assertTrue failing
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. `assertTrue`失败的截图
- en: The most commonly used assertion is `assertEquals`, which takes two values and
    checks they are equal and is overloaded to support primitive values. So here we
    can assert that the size of the `documents` list is `0`, as shown in [Example 4-23](#eg_assertEquals).
    This produces a slightly better diagnostic as shown in [Figure 4-2](#eg_assertEquals_img),
    you know that the expected value was `0` and the actual value was `1`, but it
    still doesn’t give you any meaningful context.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的断言是`assertEquals`，它接受两个值并检查它们是否相等，并重载以支持原始值。因此，我们可以断言`documents`列表的大小为`0`，如[示例4-23](#eg_assertEquals)所示。这产生了稍微好一点的诊断，如[图4-2](#eg_assertEquals_img)所示，您知道期望的值是`0`，实际值是`1`，但它仍然没有给出任何有意义的上下文。
- en: Example 4-23\. assertEquals example
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-23\. `assertEquals`示例
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![assertEquals example](Images/rwsd_0402.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![assertEquals示例](Images/rwsd_0402.png)'
- en: Figure 4-2\. Screenshot of assertEquals example failing
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-2\. `assertEquals`示例失败的截图
- en: The best way of making an assert about the size itself is to use a *matcher*
    for asserting the collection size as this provides the most descriptive diagnostics.
    [Example 4-24](#eg_assertThat) has our example written in that style and demonstrates
    the output as well. As [Figure 4-3](#eg_assertThat_img) shows, this is much clearer
    as to what went wrong without you needing to write any more code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大小本身进行断言的最佳方法是使用*matcher*来断言集合的大小，因为这提供了最具描述性的诊断。[示例4-24](#eg_assertThat)采用了这种样式编写的示例，并演示了输出。正如[图4-3](#eg_assertThat_img)所示，这样更清晰地说明了出了什么问题，而无需再编写任何代码。
- en: Example 4-24\. assertThat example
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-24\. `assertThat`示例
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![assertThat example](Images/rwsd_0403.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![assertThat示例](Images/rwsd_0403.png)'
- en: Figure 4-3\. Screenshot of assertThat example failing
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. `assertThat`示例失败的截图
- en: What is going on here is that JUnit’s `assertThat()` is being used. The method
    `assertThat()` takes a value as its first parameter and a `Matcher` as its second.
    The `Matcher` encapsulates the concept of whether a value matches some property
    and also its associated diagnostics. The `hasSize` matcher is statically imported
    from a `Matchers` utility class that contains a bundle of different matchers and
    checks that the size of a collection is equal to its parameter. These matchers
    come from the [Hamcrest library](http://hamcrest.org/), which is a very commonly
    used Java library that enables cleaner testing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了JUnit的`assertThat()`方法。方法`assertThat()`的第一个参数是一个值，第二个参数是一个`Matcher`。`Matcher`封装了一个值是否符合某些属性以及相关诊断的概念。`hasSize`匹配器是从`Matchers`实用程序类中静态导入的，该类包含一系列不同的匹配器，并检查集合的大小是否等于其参数。这些匹配器来自[Hamcrest库](http://hamcrest.org/)，这是一个非常常用的Java库，可以实现更清晰的测试。
- en: Another example of how you can build better diagnostics was shown in [Example 4-20](#assertAttributeEquals).
    Here an `assertEquals` would have given us the diagnostic for the attribute’s
    expected value and actual value. It wouldn’t have told us what the name of the
    attribute was, so this was added into the message string to help us understand
    failure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个构建更好诊断的示例是在[示例4-20](#assertAttributeEquals)中展示的。在这里，`assertEquals`会为我们提供属性的预期值和实际值的诊断。它不会告诉我们属性的名称是什么，因此将其添加到消息字符串中以帮助我们理解失败。
- en: Testing Error Cases
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试错误情况
- en: One of the absolute worst and most common mistakes to make when writing software
    is only to test the beautiful, golden, happy path of your application—the code
    path that is executed when the sun is shining on you and nothing goes wrong. In
    practice lots of things can go wrong! If you don’t test how your application behaves
    in these situations, you’re not going to end up with software that will work reliably
    in a production setting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 写软件时最严重且最常见的错误之一是仅测试你的应用程序的美丽、黄金、幸福路径——即在阳光照耀你，一切都顺利进行的代码路径。 实际上很多事情可能会出错！ 如果你不测试应用程序在这些情况下的行为，你就无法得到在生产环境中可靠运行的软件。
- en: When it comes to importing documents into our Document Management System there
    are a couple of error cases that might happen. We might try to import a file that
    doesn’t exist or can’t be read, or we might try to import a file that we don’t
    know how to extract text from or read.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及将文档导入我们的文档管理系统时，可能会出现几种错误情况。 我们可能尝试导入一个不存在或无法读取的文件，或者我们可能尝试导入一个我们不知道如何从中提取文本或读取的文件。
- en: Our `DocumentManagementSystemTest` has a couple of tests, shown in [Example 4-25](#errorTests),
    that test these two scenarios. In both cases we try to import a path file that
    will expose the problem. In order to make an assert about the desired behavior
    we use the `expected =` attribute of JUnit’s `@Test` annotation. This enables
    you to say *Hey listen, JUnit, I’m expecting this test to throw an exception,
    it’s of a certain type*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DocumentManagementSystemTest`有一些测试，显示在[示例 4-25](#errorTests)中，测试这两种情况。 在这两种情况下，我们尝试导入一个会暴露问题的路径文件。
    为了对所需行为进行断言，我们使用了JUnit的`@Test`注解的`expected =`属性。 这使您可以说*嘿，JUnit，我期望这个测试抛出一个特定类型的异常*。
- en: Example 4-25\. Testing for error cases
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-25\. 错误案例测试
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may want an alternative behavior to simply throwing an exception in the
    case of an error, but it’s definitely helpful to know how to assert that an exception
    is thrown.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在错误情况下想要替代行为，而不仅仅是抛出异常，了解如何断言异常被抛出肯定是有帮助的。
- en: Constants
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: Constants are values that do not change. Let’s face it—they are one of the few
    well-named concepts when it comes to computer programming. The Java programming
    language doesn’t use an explicit `const` keyword like C++ does, but conventionally
    developers create `static field` fields in order to represent constants. Since
    many tests consist of examples of how a part of your computer program should be
    used, they often consist of many constants.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是不变的值。 让我们面对现实——在计算机编程中，它们是少数命名得当的概念之一。 Java编程语言不像C++那样使用显式的`const`关键字，但是开发人员通常创建`static
    field`字段来代表常量。 由于许多测试由如何使用计算机程序的一部分的示例组成，它们通常包含许多常量。
- en: It’s a good idea when it comes to constants that have some kind of nonobvious
    meaning to give them a proper name that can be used within tests. We do that extensively
    through the `DocumentManagementSystemTest`, and in fact, have a block at the top
    dedicated to declaring constants, shown in [Example 4-26](#eg_constants).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有某种非明显含义的常量，给它们一个适当的名称是个好主意，这样它们可以在测试中使用。 我们通过`DocumentManagementSystemTest`广泛使用这种方式，在顶部有一个专门声明常量的块，显示在[示例 4-26](#eg_constants)中。
- en: Example 4-26\. Constants
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-26\. 常量
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Takeaways
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: You learned how to build a Document Management System.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学会了如何构建文档管理系统。
- en: You recognized the different trade-offs between different implementation approaches.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你意识到了不同实现方法之间的不同权衡。
- en: You understood several principles that drive the design of software.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你理解了驱动软件设计的几个原则。
- en: You were introduced to the Liskov Substitution Principle as a way to think about
    inheritance.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你被介绍了里斯科夫替换原则，作为思考继承的一种方式。
- en: You learned about situations where inheritance wasn’t appropriate.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解了继承不适合的情况。
- en: Iterating on You
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代在您身上
- en: 'If you want to extend and solidify the knowledge from this section you could
    try one of these activities:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要扩展和巩固本节的知识，可以尝试以下活动之一：
- en: Take the existing sample code and add an implementation for importing prescription
    documents. A prescription should have a patient, a drug, a quantity, a date, and
    state the conditions for taking a drug. You should also write a test that checks
    that the prescription import works.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取现有的示例代码，并添加一个导入处方文档的实现。 处方应包含患者、药品、数量、日期，并说明服药条件。 你还应该编写一个检查处方导入工作的测试。
- en: Try implementing the [Game of Life Kata](https://oreil.ly/RrxJU).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试实现[生命游戏 Kata](https://oreil.ly/RrxJU)。
- en: Completing the Challenge
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: Dr. Avaj is really pleased with your Document Management System and she now
    uses it extensively. Her needs are effectively met by the features because you
    drove your design from her requirements toward application behavior and into your
    implementation details. This is a theme that you will return to when TDD is introduced
    in the next chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 博士 Avaj 对你的文档管理系统非常满意，现在她已经广泛使用它。系统的特性有效地满足了她的需求，因为你从她的需求出发，推动设计朝向应用行为，并进入实现细节。在下一章节引入
    TDD 时，你将会回顾这一主题。
