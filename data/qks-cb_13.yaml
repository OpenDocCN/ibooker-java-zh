- en: Chapter 13\. Quarkus REST Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章 Quarkus REST 客户端
- en: In [Chapter 3](ch03.xhtml#developing_restful_services_chapter), you learned
    about developing RESTful services, but in this chapter, you’ll learn about communication
    between RESTful web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml#developing_restful_services_chapter)，您已经学习了如何开发 RESTful
    服务，但在本章中，您将学习如何在 RESTful Web 服务之间进行通信。
- en: Using any service-based architecture inevitably means that you need to communicate
    with external services. These services might be internal services (you control
    the life cycle of the service and they are usually deployed in the same cluster)
    or external services (third-party services).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何基于服务的架构都意味着您需要与外部服务进行通信。这些服务可能是内部服务（您控制服务的生命周期，通常部署在同一集群中）或外部服务（第三方服务）。
- en: 'If these services are implemented as RESTful web services, then you need a
    client to interact with these services. Quarkus offers two ways to do that: JAX-RS
    Web Client, which is the standard Java EE way of communicating with RESTful service;
    and MicroProfile REST Client, which is the new way of communicating with RESTful
    services.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些服务实现为 RESTful Web 服务，则需要客户端与这些服务进行交互。Quarkus 提供了两种方法：JAX-RS Web 客户端，这是与
    RESTful 服务通信的标准 Java EE 方式；以及 MicroProfile REST 客户端，这是与 RESTful 服务通信的新方式。
- en: 'This chapter will include recipes for the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括以下示例：
- en: Communicate to other RESTful services using the JAX-RS client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 客户端与其他 RESTful 服务进行通信
- en: Communicate to other RESTful services using the MicroProfile Rest Client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Rest 客户端与其他 RESTful 服务进行通信
- en: Secure the communication between RESTful services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地在 RESTful 服务之间进行通信
- en: 13.1 Using the JAX-RS Web Client
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.1 使用 JAX-RS Web 客户端
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to communicate with another RESTful web service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要与另一个 RESTful Web 服务进行通信。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JAX-RS web client to communicate with other RESTful web services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JAX-RS Web 客户端与其他 RESTful Web 服务进行通信。
- en: Let’s look at how to communicate with other RESTful services using the JAX-RS
    spec.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 JAX-RS 规范与其他 RESTful 服务进行通信。
- en: The external service we are going to connect with, the [World Clock API](https://oreil.ly/wl2IE),
    returns the current date/time by time zone. You’ll need to get the current date/time
    exposed by the [API](https://oreil.ly/7M0tf).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要连接的外部服务是[世界时钟 API](https://oreil.ly/wl2IE)，它通过时区返回当前日期/时间。您需要获取由[API](https://oreil.ly/7M0tf)公开的当前日期/时间。
- en: 'You need to add extensions for using a REST client and the JAX-B/Jackson for
    marshalling/unmarshalling JSON and Java objects:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加扩展来使用 REST 客户端以及 JAX-B/Jackson 用于 JSON 和 Java 对象的编组/解组。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, if you are creating from empty directory, run the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您是从空目录创建，请运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can start using the JAX-RS REST Client for communicating with an external
    Rest API. Let’s see what the interaction with the world clock service looks like.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始使用 JAX-RS REST 客户端与外部 REST API 进行通信。让我们看看与世界时钟服务的交互是什么样子的。
- en: 'Open `org.acme.quickstart.WorldClockResource.java` and add the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `org.acme.quickstart.WorldClockResource.java` 并添加以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO1-1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO1-1)'
- en: Makes service host configurable
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使服务主机可配置
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO1-2)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO1-2)'
- en: Creates a new REST Client
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 REST 客户端
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO1-3)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO1-3)'
- en: Sets the host
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置主机
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO1-4)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO1-4)'
- en: Sets the path to the service
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 设置到服务的路径
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO1-5)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO1-5)'
- en: Resolves the `timezone` placeholder to the one provided
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `timezone` 占位符解析为所提供的时区
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO1-6)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO1-6)'
- en: Executes a `GET` HTTP method
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET` HTTP 方法
- en: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO1-7)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO1-7)'
- en: Transforms the JSON output to the provided POJO
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 输出转换为提供的 POJO
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending a request to the `GET` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开新的终端窗口，启动 Quarkus 应用程序，并发送请求到 `GET` 方法来尝试它：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In similar way, you can make requests to other HTTP methods. For example, to
    do a POST request, you call the `post` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，您可以对其他 HTTP 方法发出请求。例如，要执行 POST 请求，您调用 `post` 方法：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also use the `javax.ws.rs.core.Response` to get all the response details
    instead of just the body:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `javax.ws.rs.core.Response` 来获取所有响应细节，而不仅仅是响应体：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See Also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can further explore the JAX-RS REST Client at the following pages on Oracle’s
    website:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步在Oracle网站上的以下页面探索JAX-RS REST客户端：
- en: '[Accessing REST Resources with the JAX-RS Client API](https://oreil.ly/7neQm)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用JAX-RS客户端API访问REST资源](https://oreil.ly/7neQm)'
- en: '[Using the Client API in the JAX-RS Example Applications](https://oreil.ly/QA8lA)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在JAX-RS示例应用程序中使用客户端API](https://oreil.ly/QA8lA)'
- en: 13.2 Using the MicroProfile REST Client
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.2 使用MicroProfile REST客户端
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to communicate with another RESTful web service without going into
    low-level details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望与另一个RESTful Web服务通信，而不需了解低级细节。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use MicroProfile REST Client to communicate with other RESTful web services.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MicroProfile REST客户端与其他RESTful Web服务通信。
- en: So far, you’ve seen how to use the JAX-RS `Web Client` to communicate with other
    REST APIs, but it is not type-safe, and you need to deal with low-level parameters
    instead of focusing on message communication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解到如何使用JAX-RS `Web Client` 与其他REST API进行通信，但这并不是类型安全的，并且需要处理低级参数而不是专注于消息通信。
- en: The MicroProfile REST Client provides a type-safe approach to invoke RESTful
    services over HTTP using as much of the JAX-RS 2.0 spec as possible. The REST
    client is defined as a Java interface, making it type-safe and providing the network
    configuration using JAX-RS annotations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile REST客户端尽可能地使用JAX-RS 2.0规范，提供了一种类型安全的方法来通过HTTP调用RESTful服务。 REST客户端定义为Java接口，使其类型安全，并使用JAX-RS注解提供网络配置。
- en: We will use the same World Clock API that was used in the previous section here,
    too. Remember to get the [current date/time](https://oreil.ly/7M0tf).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此处继续使用在前一节中使用的相同的世界时钟API。 记得获取[当前日期/时间](https://oreil.ly/7M0tf)。
- en: 'Create the `org.acme.quickstart.WorldClockService` interface that is responsible
    for interacting with the external service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建负责与外部服务交互的 `org.acme.quickstart.WorldClockService` 接口：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO2-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO2-1)'
- en: The global path
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 全局路径
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO2-2)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO2-2)'
- en: Sets the interface as REST client
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将接口设置为REST客户端
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO2-3)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO2-3)'
- en: The request uses the `GET` HTTP method
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请求使用 `GET` HTTP 方法
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO2-4)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO2-4)'
- en: The subpath with a path parameter
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有路径参数的子路径
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO2-5)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO2-5)'
- en: The media type requested
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的媒体类型
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO2-6)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO2-6)'
- en: The path parameter is resolved with the passed argument
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传递的参数解析路径参数
- en: 'Open `org.acme.quickstart.WorldClockResource.java` and add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `org.acme.quickstart.WorldClockResource.java` 并添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO3-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO3-1)'
- en: Injects the REST client
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注入REST客户端
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO3-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO3-2)'
- en: Calls the external service
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 调用外部服务
- en: You still need to set the host of the external service. MicroProfile REST Client
    has a configuration property to set it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然需要设置外部服务的主机。 MicroProfile REST客户端有一个配置属性用于设置它。
- en: 'Open *application.properties*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *application.properties*：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The attribute name uses the following format: `*fully_qualified_name_rest_client*/mp-rest/url`,
    and the value is the hostname (or the root of the URL):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称使用以下格式：`*fully_qualified_name_rest_client*/mp-rest/url`，其值为主机名（或URL的根）：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Discussion
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can also convert a response with a status code equal to or greater than
    400 into an exception by implementing the `org.eclipse.microprofile.rest.client.ex.ResponseExceptionMapper`
    interface. If multiple mappers are registered, then you need to set a priority
    with `javax.annotation.Priority` annotation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `org.eclipse.microprofile.rest.client.ex.ResponseExceptionMapper` 接口，您还可以将状态码大于或等于400的响应转换为异常。
    如果注册了多个映射器，则需要使用 `javax.annotation.Priority` 注解设置优先级。
- en: 'Create the following `ResponseExecptionMapper` class to have it registered,
    and have the application throw `IOExecptions` for status codes in the 400s:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `ResponseExecptionMapper` 类以注册它，并使应用程序对400状态码抛出 `IOExceptions`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO4-1)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO4-1)'
- en: Implements the mapper interface
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现映射器接口
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO4-2)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO4-2)'
- en: Does the conversion to an exception
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应转换为异常
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO4-3)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO4-3)'
- en: Default is to transform any response with status code ≥ 400, but you can override
    the method to provide a smaller range
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，会将状态码 ≥ 400 的任何响应转换，但您可以覆盖该方法以提供更小的范围。
- en: '`ResponseExceptionMapper` is an extension point specifically from the MicroProfile
    REST Client specification, but you can also use the extension model provided by
    the JAX-RS specification:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseExceptionMapper` 是专门从 MicroProfile REST Client 规范中的扩展点，但您也可以使用 JAX-RS
    规范提供的扩展模型：'
- en: '`ClientRequestFilter`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientRequestFilter`'
- en: The filter invoked when the request is made to the external service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调用请求发送到外部服务时触发的过滤器。
- en: '`ClientResponseFilter`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientResponseFilter`'
- en: The filter invoked when the response is received from the external service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部服务接收到响应时调用的过滤器。
- en: '`MessageBodyReader`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBodyReader`'
- en: Reads the entity after invocation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 调用后读取实体。
- en: '`MessageBodyWriter`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBodyWriter`'
- en: Writes a request body in the operations that support bodies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持主体的操作中编写请求主体。
- en: '`ParamConverter`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParamConverter`'
- en: Converts a parameter in the resource to a format to be used in a request or
    response.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将资源中的参数转换为请求或响应中使用的格式。
- en: '`ReadInterceptor`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadInterceptor`'
- en: The listener fired when the response is received from the external service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当从外部服务接收到响应时触发的监听器。
- en: '`WriteInterceptor`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteInterceptor`'
- en: The listener fired when the request is sent on the external service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请求发送到外部服务时触发的监听器。
- en: 'You can also mock the `WorldClockService` interface by using the `@InjectMock`
    together with `@RestClient`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`@InjectMock`与`@RestClient`一起模拟`WorldClockService`接口：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See Also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The MicroProfile Rest Client specification can be found at the following website:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网站找到 MicroProfile Rest Client 规范：
- en: '[Eclipse REST Client for MicroProfile](https://oreil.ly/7D0Zv)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Eclipse MicroProfile 的 REST 客户端](https://oreil.ly/7D0Zv)'
- en: 13.3 Implementing a CRUD Client
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.3 实现 CRUD 客户端
- en: Problem
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to communicate with another RESTful web service with CRUD operations
    exposed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望与另一个提供 CRUD 操作的 RESTful web 服务通信。
- en: Solution
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use MicroProfile REST Client and JAX-RS annotations to implement a CRUD client.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MicroProfile REST Client 和 JAX-RS 注解实现 CRUD 客户端。
- en: So far, you’ve seen how to use MicroProfile REST Client to get information from
    external services. When the service is an internal service, more often than not
    you need to implement more operations like insert, delete, or update.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到如何使用 MicroProfile REST Client 从外部服务获取信息。当服务是内部服务时，通常需要实现更多操作，如插入、删除或更新。
- en: 'To implement these operations, you can use JAX-RS annotations on a MicroProfile
    REST Client. Let’s see an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些操作，可以在 MicroProfile REST Client 上使用 JAX-RS 注解。让我们看一个例子：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO5-1)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO5-1)'
- en: Requests and responses are in JSON format
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应以 JSON 格式。
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO5-2)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO5-2)'
- en: Uses the `HEAD` HTTP method
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HEAD` HTTP 方法。
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO5-3)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO5-3)'
- en: Uses the `POST` HTTP method
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`POST` HTTP 方法。
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO5-4)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO5-4)'
- en: Sets `Authorization` header
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Authorization` 头
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO5-5)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO5-5)'
- en: Developer content is sent as the body
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员内容作为主体发送
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO5-6)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO5-6)'
- en: Uses the `DELETE` HTTP method
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DELETE` HTTP 方法。
- en: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO5-7)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO5-7)'
- en: Sets `AuthToken` cookie
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`AuthToken` cookie
- en: Discussion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Notice how the JAX-RS annotations are used to configure how the requests are
    sent to the other services. You never need to do anything programmatically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JAX-RS 注解如何用于配置请求如何发送到其他服务。您无需编写任何程序代码。
- en: This approach is developer-friendly and helps to reduce the boilerplate code
    that you might end up using with the JAX-RS Web Client.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对开发人员友好，有助于减少使用 JAX-RS Web 客户端时可能使用的样板代码。
- en: Of course, it also has some drawbacks. For example, methods can contain a huge
    number of parameters because of the number of path parameters, headers to set,
    and cookies. To fix this, pass a POJO with all of the required fields (instead
    of setting them in the method).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它也有一些缺点。例如，方法可能包含大量参数，因为有许多路径参数、要设置的标头和 cookie。为了解决此问题，请传递一个带有所有必需字段的 POJO（而不是在方法中设置它们）。
- en: 'Let’s create a Java class for the `PUT` requirements (i.e., an authorization
    header and a path parameter):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`PUT`需求创建一个Java类（即，授权头和路径参数）：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO6-1)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO6-1)'
- en: Sets the `Authorization` header
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Authorization`头部
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO6-2)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO6-2)'
- en: Sets the `path` parameter to resolve
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 设置解析的`path`参数
- en: 'The `interface` method using the previous class is the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述类的`interface`方法如下：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO7-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO7-1)'
- en: The `BeanParam` is used to indicate that this class is a *parameter aggregator*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanParam`用于指示此类是*参数聚合器*'
- en: 13.4 Manipulating Headers
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.4 操纵头部
- en: Problem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to manipulate and propagate headers from the incoming request to the
    outgoing service (service-to-service authentication).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从传入请求中操纵和传播头部到传出服务（服务到服务认证）。
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the MicroProfile REST Client feature that manipulates headers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MicroProfile REST Client功能操作头部。
- en: When you need to communicate to other RESTful web services, you might want to
    pass through some headers from the incoming request to the outgoing/downstream
    service. One of these typical cases is the `Authorization` header to do service-to-service
    authentication. Authentication and authorization in services architecture are
    usually solved by propagating a token, often a JWT token, through all services
    that compose the application. You can see the idea in [Figure 13-1](#s2sauth).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要与其他RESTful Web服务进行通信时，可能需要将一些请求头传递给传出/下游服务。其中一个典型情况是通过`Authorization`头部进行服务间认证。服务架构中的认证和授权通常通过传播令牌来解决，通常是JWT令牌，通过应用程序中所有服务进行传递。您可以在[图 13-1](#s2sauth)中看到这个想法。
- en: '![qucb 1301](Images/qucb_1301.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![qucb 1301](Images/qucb_1301.png)'
- en: Figure 13-1\. Service-to-service authentication
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-1\. 服务到服务认证
- en: The MicroProfile REST Client simplifies all these operations by allowing you
    to propagate and manipulate headers either at a static level by using annotations
    or at a programmatic level by implementing `ClientHeadersFactory` interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile REST Client通过允许您使用注解在静态级别或通过实现`ClientHeadersFactory`接口在编程级别来传播和操作头部，简化了所有这些操作。
- en: 'To set a header on a method or on all the methods defined in an interface,
    you can use the `org.eclipse.microprofile.rest.client.annotation.ClientHeaderParam`
    annotation at method level or class level to set a header with a static value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在接口定义的一个方法或所有方法上设置头部，您可以使用`org.eclipse.microprofile.rest.client.annotation.ClientHeaderParam`注解在方法级别或类级别设置具有静态值的头部：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO8-1)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO8-1)'
- en: Sets `user-agent` to the request
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将`user-agent`设置为请求
- en: 'The `value` can be a method invocation where the return value would be the
    header’s value:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`可以是方法调用，其中返回值将是头部的值：'
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO9-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO9-1)'
- en: Sets the method to invoke
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要调用的方法
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO9-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO9-2)'
- en: The header name is the first argument of the method
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 头部名称是方法的第一个参数
- en: These approaches offer a basic manipulation of headers but don’t help in propagating
    headers from the incoming request to the outgoing service. It is also possible
    to add or propagate headers by implementing the `ClientHeadersFactory` interface
    and registering it with the `RegisterClientHeaders` annotation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法提供了基本的头部操作，但不会帮助传播从传入请求到传出服务的头部。还可以通过实现`ClientHeadersFactory`接口并将其注册到`RegisterClientHeaders`注解来添加或传播头部。
- en: 'Suppose that your service receives the authentication token from your upstream
    service in a header named `x-auth`, and your downstream service requires that
    this value is set to the `Authorization` header. Let’s implement this rename of
    headers in a MicroProfile REST Client:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的服务从上游服务的头部`x-auth`接收认证令牌，并且您的下游服务要求将此值设置为`Authorization`头部。让我们在MicroProfile
    REST Client中实现这些头部的重命名：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO10-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO10-1)'
- en: The headers from the inbound JAX-RS request
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 来自入站JAX-RS请求的头部
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO10-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO10-2)'
- en: The headers parameters specified on the client interface
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端接口上指定的头部参数
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO10-3)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO10-3)'
- en: Adds all headers
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加所有头部
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO10-4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO10-4)'
- en: Renames the header value
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名头部值
- en: 'Finally, you need to register this factory in the client by using the `R⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠C⁠l⁠i⁠e⁠n⁠t​H⁠e⁠a⁠d⁠e⁠r⁠s`
    annotation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要使用`R⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠C⁠l⁠i⁠e⁠n⁠t​H⁠e⁠a⁠d⁠e⁠r⁠s`注解将此工厂注册到客户端：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO11-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO11-1)'
- en: Registers the headers factory for this client
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为此客户端注册头部工厂
- en: Discussion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you want to propagate the headers only as is, without any modification, you
    can do it by just annotating the REST client with `@RegisterClientHeaders` without
    specifying any factory. Then the default headers factory is used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想按原样传播头部而不做任何修改，可以通过只用`@RegisterClientHeaders`注解 REST 客户端来实现。然后将使用默认头部工厂。
- en: 'This default factory will propagate specified headers from the inbound JAX-RS
    request to the outbound request. To configure which headers are propagated, you
    need to set them as comma-separated values under the `org.eclipse.microprofile.rest.client.propagateHeaders`
    property:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认工厂将从入站 JAX-RS 请求中传播指定的头部到出站请求。要配置要传播的头部，您需要将它们设置为逗号分隔的值，放置在`org.eclipse.microprofile.rest.client.propagateHeaders`属性下：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 13.5 Using REST Client for Multipart Messages
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.5 使用 REST 客户端处理多部分消息
- en: Problem
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to send multipart content to interact with the REST APIs requiring
    it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望发送多部分内容与需要其的 REST API 进行交互。
- en: Solution
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use RESTEasy multipart support to deal with multipart messages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RESTEasy 多部分支持处理多部分消息。
- en: Sometimes the service you need to connect with requires that you send multiple
    content bodies embedded into one message, usually using the `multipart/form-data`
    MIME-type. The easiest way to work with multipart mime-types is using the RESTEasy
    multipart provider, which integrates with the MicroProfile REST client.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要连接的服务要求您发送多个内容主体嵌入到一个消息中，通常使用`multipart/form-data` MIME 类型。处理多部分 MIME
    类型最简单的方法是使用 RESTEasy 多部分提供程序，该提供程序与 MicroProfile REST 客户端集成。
- en: Important
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要
- en: This feature is specific of RESTEasy/Quarkus and is not under MicroProfile REST
    client spec.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能特定于 RESTEasy/Quarkus，不属于 MicroProfile REST 客户端规范。
- en: 'Before you start developing, you need to add the `resteasy-multipart-provider`
    dependency in your build tool:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发之前，您需要在构建工具中添加`resteasy-multipart-provider`依赖项：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then you need to create the model object that defines the payload of the message.
    Let’s define a multipart message with two parts, one as a binary content and another
    one as a string:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建定义消息有效负载的模型对象。让我们定义一个包含两个部分的多部分消息，一个作为二进制内容，另一个作为字符串：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO12-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO12-1)'
- en: JAX-RS annotation to define the form parameter contained inside the request
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 注解来定义包含在请求内部的表单参数
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO12-2)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO12-2)'
- en: RESTEasy annotation to define the content type of the part
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 注解来定义部分内容类型
- en: 'Finally, you need to declare a new method using the `MultipartDeveloperModel`
    object as a parameter annotated with `org.jboss.resteasy.annotations.providers.multipart.MultipartForm`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要声明一个新方法，该方法使用`MultipartDeveloperModel`对象作为参数，并注解为`org.jboss.resteasy.annotations.providers.multipart.MultipartForm`：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO13-1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO13-1)'
- en: Sets the output mime-type as multipart
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 设置输出 MIME 类型为多部分
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO13-2)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO13-2)'
- en: Defines the parameter as a `multipart/form-type` mime-type
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数定义为`multipart/form-type` MIME 类型
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO13-3)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO13-3)'
- en: Multipart data
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 多部分数据
- en: 13.6 Using REST Client to Configure SSL
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.6 使用 REST 客户端配置 SSL
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to configure REST client to use SSL.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要配置 REST 客户端以使用 SSL。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The MicroProfile REST Client provides a way to configure SSL for communication
    with other services.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile REST 客户端提供了一种配置 SSL 以与其他服务通信的方式。
- en: By default, the MicroProfile REST Client uses the JVM trust store to verify
    the certificates when HTTPS connections are used. But sometimes, especially in
    cases of internal services, the certificates cannot be validated using the JVM
    trust store and you need to provide your custom trust store.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MicroProfile REST 客户端在使用 HTTPS 连接时使用 JVM 信任库来验证证书。但有时，特别是在内部服务的情况下，无法使用
    JVM 信任库验证证书，因此需要提供自定义信任库。
- en: 'The MicroProfile REST Client accepts setting custom trust stores by using the
    `trustStore` configuration property:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile REST Client 可以通过使用 `trustStore` 配置属性来设置自定义信任存储：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO14-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO14-1)'
- en: '`trustStore` sets the trust store location; this can be a class path resource
    (`classpath:`) or a file (`file:`)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`trustStore` 设置信任存储位置；这可以是一个类路径资源（`classpath:`）或一个文件（`file:`）'
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO14-2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO14-2)'
- en: '`trustStorePassword` sets the password for the trust store'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`trustStorePassword` 设置信任存储的密码'
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO14-3)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO14-3)'
- en: '`trustStoreType` sets the type of trust store'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`trustStoreType` 设置信任存储的类型'
- en: Keystores are also provided, which are really useful in two-way SSL connections.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Keystores 也提供了，在双向 SSL 连接中非常有用。
- en: MicroProfile REST Client accepts setting custom key stores by using the `keyStore`
    configuration property.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile REST Client 可以通过使用 `keyStore` 配置属性来设置自定义密钥库。
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO15-1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO15-1)'
- en: '`keyStore` sets the key store location; this can be a class path resource (`classpath:`)
    or a file (`file:`)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyStore` 设置密钥存储的位置；这可以是一个类路径资源（`classpath:`）或一个文件（`file:`）'
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO15-2)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO15-2)'
- en: '`keyStorePassword` sets the password for the trust store'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyStorePassword` 设置信任存储的密码'
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO15-3)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO15-3)'
- en: '`keyStoreType` sets the type of key store'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyStoreType` 设置密钥存储的类型'
- en: Finally, you can implement `javax.net.ssl.HostnameVerifier` to override the
    behavior when the URL’s hostname and the server’s identification hostname mismatch.
    Then the implementation of this interface can determine whether this connection
    should be allowed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以实现 `javax.net.ssl.HostnameVerifier` 接口来覆盖当 URL 的主机名与服务器的识别主机名不匹配时的行为。然后，该接口的实现可以确定是否应允许此连接。
- en: 'The following is an example of hostname verifier:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主机名验证器的示例：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You need to enable it in the configuration file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在配置文件中启用它：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Most of the time, when you are running tests locally, you might not have installed
    all the trust stores or key stores required to connect to an external service.
    In these cases, you might run tests against the HTTP version of the service. This
    is not always possible, however, and in some third-party services, only the HTTPS
    protocol is enabled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当您在本地运行测试时，可能没有安装所有连接到外部服务所需的信任存储或密钥存储。在这些情况下，您可能会针对服务的 HTTP 版本运行测试。然而，并非总是可能，在某些第三方服务中，只启用了
    HTTPS 协议。
- en: 'One possible solution to this problem is to configure the MicroProfile REST
    Client to trust any certificate. To do this, you need to configure the client
    and provide a custom trust manager:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一个可能方案是配置 MicroProfile REST Client 以信任任何证书。为此，您需要配置客户端并提供自定义信任管理器：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO16-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO16-1)'
- en: Creates a CDI bean; you need to use `@Inject` instead of `@RestClient` to make
    use of it
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 CDI bean；您需要使用 `@Inject` 而不是 `@RestClient` 来使用它
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO16-2)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO16-2)'
- en: Disable host verification
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用主机验证
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO16-3)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO16-3)'
- en: Trust all certificates without doing any verification
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在不进行任何验证的情况下信任所有证书
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO16-4)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO16-4)'
- en: Customize `SSLContext` with an empty trust manager, effectively negating all
    SSL checks
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空信任管理器自定义 `SSLContext`，有效地取消所有 SSL 检查
- en: Then if you inject this instance instead of the production one, every HTTPS
    request is valid independently of the certificate used by the external service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您注入此实例而不是生产实例，则每个 HTTPS 请求都是有效的，不论外部服务使用的证书是什么。
