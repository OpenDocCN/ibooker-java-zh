- en: 'Chapter 14\. A Very Graphic Story: Getting Gui'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章：一个非常图形化的故事：获取 GUI
- en: '![image](Images/f0461-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0461-01.png)'
- en: '**Face it, you need to make GUIs**. If you’re building applications that other
    people are going to use, you *need* a graphical interface. If you’re building
    programs for yourself, you *want* a graphical interface. Even if you believe that
    the rest of your natural life will be spent writing server-side code, where the
    client user interface is a web page, sooner or later you’ll need to write tools,
    and you’ll want a graphical interface. Sure, command-line apps are retro, but
    not in a good way. They’re weak, inflexible, and unfriendly. We’ll spend two chapters
    working on GUIs and learn key Java language features along the way including **Event
    Handling** and **Inner Classes** and **lambdas**. In this chapter, we’ll put a
    button on the screen, and make it do something when you click it. We’ll paint
    on the screen, we’ll display a JPEG image, and we’ll even do some (crude) animation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面对现实吧，你需要制作 GUI**。如果你正在构建其他人会使用的应用程序，你*需要*一个图形界面。如果你为自己构建程序，你*想要*一个图形界面。即使你相信你未来的生活将全都花在编写服务器端代码上，其中客户端用户界面是一个网页，早晚你也会需要编写工具，并且你会想要一个图形界面。当然，命令行应用程序很复古，但并不是一种好方式。它们弱小、缺乏灵活性，并且不友好。我们将花费两章的时间来学习
    GUI，并在此过程中学习关键的 Java 语言特性，包括**事件处理**、**内部类**和**Lambda 表达式**。在本章中，我们将在屏幕上放置一个按钮，并使其在点击时执行某些操作。我们将在屏幕上绘制，显示
    JPEG 图像，甚至进行一些（简陋的）动画。'
- en: It all starts with a window
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切从一个窗口开始
- en: '![image](Images/f0462-02.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0462-02.png)'
- en: '**She’s asked a couple of really good questions.** In a few pages we’ll address
    these questions with an extra-special “No Dumb Questions.”'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**她问了几个非常好的问题。** 几页之后我们将通过一个特别的“无愚蠢问题”的部分来回答这些问题。'
- en: A JFrame is the object that represents a window on the screen. It’s where you
    put all the interface things like buttons, check boxes, text fields, and so on.
    It can have an honest-to-goodness menu bar with menu items. And it has all the
    little windowing icons for whatever platform you’re on, for minimizing, maximizing,
    and closing the window.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JFrame 是代表屏幕上窗口的对象。在这里你可以放置所有的界面元素，如按钮、复选框、文本字段等。它可以拥有一个真正的菜单栏，其中包含菜单项。而且它有所有的窗口图标，无论你使用的是哪个平台，包括最小化、最大化和关闭窗口的按钮。
- en: 'The JFrame looks different depending on the platform you’re on. This is a JFrame
    on an old Mac OS X:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同平台上，JFrame 的外观各不相同。这是旧版 Mac OS X 上的 JFrame：
- en: '![image](Images/f0462-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0462-01.png)'
- en: Put widgets in the window
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在窗口中放置小部件
- en: Once you have a JFrame, you can put things (“widgets”) in it by adding them
    to the JFrame. There are a ton of Swing components you can add; look for them
    in the javax.swing package. The most common include JButton, JRadioButton, JCheckBox,
    JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable. Most are
    really simple to use, but some (like JTable) can be a bit more complicated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 JFrame，你可以通过将它们添加到 JFrame 中来将事物（“小部件”）放入其中。你可以在 javax.swing 包中找到许多 Swing
    组件。最常见的包括 JButton、JRadioButton、JCheckBox、JLabel、JList、JScrollPane、JSlider、JTextArea、JTextField
    和 JTable。大多数都很简单易用，但有些（如 JTable）可能会复杂一些。
- en: '**Making a GUI is easy:**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作 GUI 很容易：**'
- en: '![images](Images/1.png) Make a frame (a JFrame)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图像](Images/1.png) 制作一个框架（JFrame）'
- en: '`**JFrame frame = new JFrame();**`'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**JFrame frame = new JFrame();**`'
- en: '![images](Images/2.png) Make a widget (button, text field, etc.)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图像](Images/2.png) 制作一个小部件（按钮、文本字段等）'
- en: '`**JButton button = new JButton("click me");**`'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**JButton button = new JButton("click me");**`'
- en: '![images](Images/3.png) Add the widget to the frame'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/3.png) 将小部件添加到框架中'
- en: '`**frame.getContentPane().add(button);**`'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**frame.getContentPane().add(button);**`'
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t add things to the frame directly. Think of the frame as the trim around
    the window, and you add things to the window pane.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不直接向框架添加东西。把框架想象成窗口周围的装饰框，把东西添加到窗口窗格中。
- en: '![images](Images/4.png) Display it (give it a size and make it visible)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图像](Images/4.png) 显示它（给它一个尺寸并使其可见）'
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your first GUI: a button on a frame'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个 GUI：一个按钮在框架上
- en: '![image](Images/f0463-01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0463-01.png)'
- en: '**Let’s see what happens when we run it:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们看看运行时会发生什么：**'
- en: '`%java SimpleGui1`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`%java SimpleGui1`'
- en: '![image](Images/f0463-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0463-02.png)'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Whoa! That’s a Really Big Button.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**哇！那是一个非常大的按钮。**'
- en: The button fills all the available space in the frame. Later we’ll learn to
    control where (and how big) the button is on the frame.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮填满了框架中所有可用的空间。稍后我们将学习如何控制按钮在框架中的位置（及大小）。
- en: But nothing happens when I click it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但是当我点击它时什么也没发生...
- en: That’s not exactly true. When you press the button, it shows that “pressed”
    or “pushed in” look (which changes depending on the platform look and feel, but
    it always does *something* to show when it’s being pressed).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那不完全正确。当您按下按钮时，它会显示“按下”或“按下”的外观（这取决于平台的外观和感觉，但它总是*做某事*来显示它正在被按下）。
- en: The real question is, “How do I get the button to do something specific when
    the user clicks it?”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是，“我怎样才能让按钮在用户点击时执行特定的操作？”
- en: '**We need two things:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们需要两件事：**'
- en: '![images](Images/1.png) A ***method*** to be called when the user clicks (the
    thing you want to happen as a result of the button click).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 当用户点击时调用的***方法***（按钮点击后希望发生的事情）。'
- en: '![images](Images/2.png) A way to ***know*** when to trigger that method. In
    other words, a way to know when the user clicks the button!'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 一种***知道***何时触发那个方法的方法。换句话说，一种知道用户何时点击按钮的方法！'
- en: Getting a user event
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户事件
- en: 'Imagine you want the text on the button to change from *click me* to *I’ve
    been clicked* when the user presses the button. First we can write a method that
    changes the text of the button (a quick look through the API will show you the
    method):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当用户按下按钮时，按钮上的文本从*click me*变为*I’ve been clicked*。首先，我们可以编写一个方法来改变按钮的文本（快速浏览API会显示给你这个方法）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But *now* what? How will we *know* when this method should run? ***How will
    we know when the button is clicked?***
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但*现在*呢？我们怎么*知道*这个方法应该运行？***我们怎么知道按钮被点击了？***
- en: In Java, the process of getting and handling a user event is called *event-handling*.
    There are many different event types in Java, although most involve GUI user actions.
    If the user clicks a button, that’s an event. An event that says “The user wants
    the action of this button to happen.” If it’s a “Slow the Tempo” button, the user
    wants the slow-the-music-tempo action to occur. If it’s a Send button on a chat
    client, the user wants the send-my-message action to happen. So the most straightforward
    event is when the user clicked the button, indicating they want an action to occur.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，获取和处理用户事件的过程称为*事件处理*。在Java中有许多不同的事件类型，尽管大多数涉及GUI用户操作。如果用户点击按钮，那就是一个事件。一个事件表明“用户希望这个按钮的操作发生。”如果是“减慢速度”按钮，用户希望减慢音乐速度的操作发生。如果是聊天客户端上的发送按钮，用户希望发送消息的操作发生。所以最直接的事件就是用户点击按钮，表示他们希望发生某个动作。
- en: With buttons, you usually don’t care about any intermediate events like button-is-being-pressed
    and button-is-being-released. What you want to say to the button is, “I don’t
    care how the user plays with the button, how long they hold the mouse over it,
    how many times they change their mind and roll off before letting go, etc. ***Just
    tell me when the user means business!*** In other words, don’t call me unless
    the user clicks in a way that indicates he wants the darn button to do what it
    says it’ll do!”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮来说，通常不关心按钮被按下和释放等中间事件。你想对按钮说的是：“我不在乎用户如何玩弄按钮，他们按住鼠标多久，他们多少次改变主意然后再放开，等等。***告诉我当用户认真对待按钮时！***换句话说，除非用户点击按钮表示他想要按钮做它所说要做的事情，否则不要叫我！”
- en: '**First, the button needs to know that we care.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，按钮需要知道我们关心它。**'
- en: '![image](Images/f0465-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0465-02.png)'
- en: '**Second, the button needs a way to call us back when a button-clicked event
    occurs.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**其次，按钮需要一种方法在按钮点击事件发生时回调我们。**'
- en: '**If you care about the button’s events, **implement an interface** that says,
    “I’m **listening** for your events.”**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您关心按钮的事件，**实现一个接口**来表明：“我正在**监听**你的事件。”**'
- en: A **listener interface** is the bridge between the **listener** (you) and **event
    source** (the button).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听器接口**是**监听器**（您）与**事件源**（按钮）之间的桥梁。'
- en: The Swing GUI components are event sources. In Java terms, an event source is
    an object that can turn user actions (click a mouse, type a key, close a window)
    into events. And like virtually everything else in Java, an event is represented
    as an object. An object of some event class. If you scan through the java.awt.event
    package in the API, you’ll see a bunch of event classes (easy to spot—they all
    have ***Event*** in the name). You’ll find MouseEvent, KeyEvent, WindowEvent,
    ActionEvent, and several others.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Swing GUI组件是事件源。在Java术语中，事件源是一个能将用户动作（点击鼠标，键入键盘，关闭窗口）转换为事件的对象。就像Java中的几乎所有东西一样，事件被表示为对象。某个事件类的对象。如果你浏览API中的java.awt.event包，你会看到一堆事件类（很容易发现——它们的名字都带有***Event***）。你会找到MouseEvent，KeyEvent，WindowEvent，ActionEvent等几个事件类。
- en: An event ***source*** (like a button) creates an ***event object*** when the
    user does something that matters (like *click* the button). Most of the code you
    write (and all the code in this book) will *receive* events rather than *create*
    events. In other words, you’ll spend most of your time as an event *listener*
    rather than an event *source*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事件***源***（如按钮）在用户执行重要操作（如*点击*按钮）时创建一个***事件对象***。大多数你编写的代码（以及本书中的所有代码）将*接收*事件而不是*创建*事件。换句话说，你将大部分时间作为事件*监听器*而不是事件*源*。
- en: Every event type has a matching listener interface. If you want MouseEvents,
    implement the MouseListener interface. Want WindowEvents? Implement WindowListener.
    You get the idea. And remember your interface rules—to implement an interface
    you *declare* that you implement it (class Dog implements Pet), which means you
    must *write implementation methods* for every method in the interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每种事件类型都有一个匹配的监听器接口。如果你想要MouseEvents，就实现MouseListener接口。想要WindowEvents？就实现WindowListener接口。你明白了吧。并且记住你的接口规则——要实现一个接口，你要*声明*你实现了它（类Dog实现Pet），这意味着你必须为接口中的每个方法*编写实现方法*。
- en: Some interfaces have more than one method because the event itself comes in
    different flavors. If you implement MouseListener, for example, you can get events
    for mousePressed, mouseReleased, mouseMoved, etc. Each of those mouse events has
    a separate method in the interface, even though they all take a MouseEvent. If
    you implement MouseListener, the mousePressed() method is called when the user
    (you guessed it) presses the mouse. And when the user lets go, the mouseReleased()
    method is called. So for mouse events, there’s only one event *object*, MouseEvent,
    but several different event *methods*, representing the different *types* of mouse
    events.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些接口有多个方法，因为事件本身具有不同的类型。例如，如果你实现了MouseListener，你可以获取鼠标按下（mousePressed）、鼠标释放（mouseReleased）、鼠标移动（mouseMoved）等事件。每个鼠标事件在接口中都有一个单独的方法，尽管它们都接收一个MouseEvent对象。如果你实现了MouseListener，当用户（你猜对了）按下鼠标时会调用mousePressed()方法。当用户松开鼠标时，会调用mouseReleased()方法。因此，对于鼠标事件来说，只有一个事件*对象*，即MouseEvent，但有几种不同的事件*方法*，代表不同类型的鼠标事件。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you implement a listener interface, you give the button a way to call
    you back. The interface is where the call-back method is declared.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你实现一个监听器接口时，你给按钮一个回调的方法。接口是声明回调方法的地方。**'
- en: '![image](Images/f0466-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0466-01.png)'
- en: '**How the listener and source communicate:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听器和源如何通信：**'
- en: '![image](Images/f0467-01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0467-01.png)'
- en: '**The Listener**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**听者**'
- en: If your class wants to know about a button’s ActionEvents, you implement the
    ActionListener interface. The button needs to know you’re interested, so you register
    with the button by calling its addActionListener(this) and passing an ActionListener
    reference to it. In our first example, *you* are the ActionListener so you pass
    *this*, but it’s more common to create a specific class to do listen to events.
    The button needs a way to call you back when the event happens, so it calls the
    method in the listener interface. As an ActionListener, you *must* implement the
    interface’s sole method, actionPerformed(). The compiler guarantees it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类想知道按钮的ActionEvents，你就实现ActionListener接口。按钮需要知道你感兴趣，所以你通过调用它的addActionListener(this)并传递一个ActionListener的引用来注册。在我们的第一个例子中，*你*就是ActionListener，所以你传递*this*，但更常见的是创建一个专门的类来监听事件。按钮需要一种方式在事件发生时调用你，所以它调用监听器接口中的方法。作为ActionListener，你*必须*实现接口的唯一方法actionPerformed()。编译器会保证这一点。
- en: '**The Event Source**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件源**'
- en: A button is a source of ActionEvents, so it has to know which objects are interested
    listeners. The button has an addActionListener() method to give interested objects
    (listeners) a way to *tell* the button they’re interested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是ActionEvents的源，因此它必须知道哪些对象是感兴趣的监听器。按钮有一个addActionListener()方法，让感兴趣的对象（监听器）有一种方式*告诉*按钮它们感兴趣。
- en: When the button’s addActionListener() runs (because a potential listener invoked
    it), the button takes the parameter (a reference to the listener object) and stores
    it in a list. When the user clicks the button, the button “fires” the event by
    calling the actionPerformed() method on each listener in the list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮的addActionListener()方法运行时（因为一个潜在的监听器调用了它），按钮接受参数（监听器对象的引用）并将其存储在列表中。当用户点击按钮时，按钮通过调用列表中每个监听器的actionPerformed()方法来“触发”事件。
- en: '**Getting a button’s ActionEvent**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取按钮的ActionEvent**'
- en: '![images](Images/1.png) Implement the ActionListener interface'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 实现ActionListener接口'
- en: '![images](Images/2.png) Register with the button (tell it you want to listen
    for events)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![images](Images/2.png) 向按钮注册（告诉它你想要监听事件）'
- en: '![images](Images/3.png) Define the event-handling method (implement the actionPerformed()
    method from the ActionListener interface)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![images](Images/3.png) 定义事件处理方法（实现ActionListener接口的actionPerformed()方法）'
- en: '![image](Images/f0468-01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0468-01.png)'
- en: Listeners, Sources, and Events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器、来源和事件
- en: For most of your stellar Java career, *you* will not be the *source* of events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你辉煌的Java职业生涯中，*你*不会是事件的*源*。
- en: (No matter how much you fancy yourself the center of your social universe.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (无论你如何自视你是社交宇宙的中心。)
- en: Get used to it. ***Your job is to be a good listener.***
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 适应它。***你的工作是成为一个好的倾听者。***
- en: (Which, if you do it sincerely, *can* improve your social life.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: (如果你真诚地去做，*可以*改善你的社交生活。)
- en: '![image](Images/f0469-01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0469-01.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **你来解决。**'
- en: Getting back to graphics...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回到图形...
- en: Now that we know a little about how events work (we’ll learn more later), let’s
    get back to putting stuff on the screen. We’ll spend a few minutes playing with
    some fun ways to get graphic, before returning to event handling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对事件的工作原理有了一点了解（稍后会学到更多），让我们回到屏幕上放东西。我们会花几分钟玩一些有趣的图形方式，然后回到事件处理。
- en: '**Three ways to put things on your GUI:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**三种在GUI上放置东西的方法:**'
- en: '![images](Images/1.png) **Put widgets on a frame**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 在框架上放置小部件'
- en: Add buttons, menus, radio buttons, etc.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加按钮、菜单、单选按钮等等。
- en: '`**frame.getContentPane().add(myButton);**`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**frame.getContentPane().add(myButton);**`'
- en: The javax.swing package has more than a dozen widget types.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: javax.swing包含十多种小部件类型。
- en: '![image](Images/f0471-01.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-01.png)'
- en: '![images](Images/2.png) **Draw 2D graphics on a widget**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 在小部件上绘制2D图形'
- en: Use a graphics object to paint shapes.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用图形对象来绘制形状。
- en: '`**graphics.fillOval(70,70,100,100);**`'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**graphics.fillOval(70,70,100,100);**`'
- en: You can paint a lot more than boxes and circles; the Java2D API is full of fun,
    sophisticated graphics methods.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以画的不仅仅是方框和圆形；Java2D API充满了有趣和复杂的图形方法。
- en: '![image](Images/f0471-02.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-02.png)'
- en: '![images](Images/3.png) **Put a JPEG on a widget**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/3.png) 在小部件上放置JPEG'
- en: You can put your own images on a widget.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在小部件上放置自己的图像。
- en: '`**graphics.drawImage(myPic,10,10,this);**`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**graphics.drawImage(myPic,10,10,this);**`'
- en: '![image](Images/f0471-03.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-03.png)'
- en: Make your own drawing widget
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作自己的绘图小部件
- en: If you want to put your own graphics on the screen, your best bet is to make
    your own paintable widget. You plop that widget on the frame, just like a button
    or any other widget, but when it shows up, it will have your images on it. You
    can even make those images move, in an animation, or make the colors on the screen
    change every time you click a button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想把自己的图形放在屏幕上，最好的方法是制作一个可绘制的小部件。你把那个小部件放在框架上，就像按钮或任何其他小部件一样，但当它显示时，它将有你的图像。你甚至可以让这些图像动起来，作为动画，或者每次点击按钮时改变屏幕上的颜色。
- en: It’s a piece of cake.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易。
- en: '**Make a subclass of JPanel and override one method, paintComponent().**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作JPanel的子类，并重写一个方法，paintComponent()。**'
- en: All of your graphics code goes inside the paintComponent() method. Think of
    the paintComponent() method as the method called by the system to say, “Hey widget,
    time to paint yourself.” If you want to draw a circle, the paintComponent() method
    will have code for drawing a circle. When the frame holding your drawing panel
    is displayed, paintComponent() is called and your circle appears. If the user
    iconifies/minimizes the window, the JVM knows the frame needs “repair” when it
    gets de-iconified, so it calls paintComponent() again. Anytime the JVM thinks
    the display needs refreshing, your paintComponent() method will be called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的图形代码都放在paintComponent()方法里。把paintComponent()方法想象成系统调用的方法，“嘿小部件，是时候画你自己了。”如果你想画一个圆，paintComponent()方法将有画圆的代码。当显示包含你的绘图面板的框架时，会调用paintComponent()，你的圆就会出现。如果用户最小化窗口，JVM知道框架需要“修复”，因此当它被还原时，会再次调用paintComponent()。每当JVM认为显示需要刷新时，都会调用你的paintComponent()方法。
- en: One more thing, ***you never call this method yourself!*** The argument to this
    method (a Graphics object) is the actual drawing canvas that gets slapped onto
    the *real* display. You can’t get this by yourself; it must be handed to you by
    the system. You’ll see later, however, that you *can* ask the system to refresh
    the display (repaint()), which ultimately leads to paintComponent() being called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，***你永远不会自己调用这个方法！***这个方法的参数（一个 Graphics 对象）是实际的绘图画布，它被贴到*真实*显示器上。你无法自己获取它；它必须由系统传递给你。然而，你后来会看到，你可以要求系统刷新显示（repaint()），最终导致
    paintComponent() 被调用。
- en: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
- en: Fun things to do in paintComponent()
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 paintComponent() 中的有趣事物
- en: Let’s look at a few more things you can do in paintComponent(). The most fun,
    though, is when you start experimenting yourself. Try playing with the numbers,
    and check the API for class Graphics (later we’ll see that there’s even *more*
    you can do besides what’s in the Graphics class).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 paintComponent() 中还可以做些什么。不过，最有趣的是当你开始自己尝试实验。试着玩玩数字，并查看 Graphics 类的 API（稍后我们将看到除了
    Graphics 类中的内容外，*还有*更多你可以做的）。
- en: '**Display a JPEG**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示 JPEG**'
- en: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
- en: '**Paint a randomly colored circle on a black background**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**在黑色背景上随机绘制一个彩色圆圈**'
- en: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
- en: Behind every good Graphics reference is a Graphics2D object
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每一个优秀的 Graphics 参考背后都是一个 Graphics2D 对象
- en: The argument to paintComponent() is declared as type Graphics (java.awt.Graphics).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: paintComponent() 的参数声明为 Graphics 类型（java.awt.Graphics）。
- en: '**`public void paintComponent(Graphics g) { }`**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`public void paintComponent(Graphics g) { }`**'
- en: So the parameter “g” IS-A Graphics object. This means it *could* be a *subclass*
    of Graphics (because of polymorphism). And in fact, it *is*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以参数“g”是一个 Graphics 对象。这意味着它 *可能* 是 Graphics 的 *子类*（因为多态性）。而事实上，它 *就是*。
- en: '***The object referenced by the “g” parameter is actually an instance of the***
    Graphics2D ***class.***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***“g”参数引用的对象实际上是 Graphics2D 类的一个实例。***'
- en: Why do you care? Because there are things you can do with a Graphics2D reference
    that you can’t do with a Graphics reference. A Graphics2D object can do more than
    a Graphics object, and it really is a Graphics2D object lurking behind the Graphics
    reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要在意呢？因为有些事情你可以通过 Graphics2D 引用做，而用 Graphics 引用是做不到的。Graphics2D 对象比 Graphics
    对象能做更多的事情，它确实是在 Graphics 引用背后潜伏的 Graphics2D 对象。
- en: 'Remember your polymorphism. The compiler decides which methods you can call
    based on the reference type, not the object type. If you have a Dog object referenced
    by an Animal reference variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你的多态性。编译器根据引用类型决定你可以调用哪些方法，而不是对象类型。如果你有一个由 Animal 引用变量引用的 Dog 对象：
- en: '`**Animal a = new Dog();**`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Animal a = new Dog();**`'
- en: 'You CANNOT say:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能说：
- en: '`**a.bark();**`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`**a.bark();**`'
- en: 'Even though you know it’s really a Dog back there. The compiler looks at “a,”
    sees that it’s of type Animal, and finds that there’s no remote control button
    for bark() in the Animal class. But you can still get the object back to the Dog
    it really *is* by saying:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你知道背后真的是一只狗。编译器看到“a”，看到它是 Animal 类型，发现 Animal 类中没有 bark() 方法的远程控制按钮。但你仍然可以通过以下方式将对象还原为它真正*是*的
    Dog：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the bottom line with the Graphics object is this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于 Graphics 对象的底线是这样的：
- en: '**If you need to use a method from the Graphics2D class, you can’t *use* the
    paintComponent parameter (“g”) straight from the method. But you can *cast* it
    with a new Graphics2D variable:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你需要使用 Graphics2D 类的方法，你不能直接使用 paintComponent 参数（“g”）的方法。但是你可以使用新的 Graphics2D
    变量进行强制转换：**'
- en: '`**Graphics2D g2d = (Graphics2D) g;**`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Graphics2D g2d = (Graphics2D) g;**`'
- en: Because life’s too short to paint the circle a solid color when there’s a gradient
    blend waiting for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因为生命太短暂了，当有一个渐变混合在等着你时，你就不会只用单色来绘制圆圈了
- en: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
- en: '**Bullet Points**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目符号**'
- en: We can get an event. We can paint graphics. But can we paint graphics *when*
    we get an event?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以获取事件。我们可以绘制图形。但是当我们获取事件时，我们可以绘制图形吗？
- en: 'Let’s hook up an event to a change in our drawing panel. We’ll make the circle
    change colors each time you click the button. Here’s how the program flows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将事件连接到绘图面板的变化上。每次点击按钮时，我们将使圆圈更换颜色。程序的流程如下：
- en: '![images](Images/1-circle.png) The frame is built with the two widgets (your
    drawing panel and a button). A listener is created and registered with the button.
    Then the frame is displayed, and it just waits for the user to click.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1-circle.png) 框架建立了两个小部件（您的绘图面板和一个按钮）。创建了监听器并将其注册到按钮上。然后显示框架，它只等待用户点击。'
- en: '![image](Images/f0477-01.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-01.png)'
- en: '![images](Images/2-circle.png) The user clicks the button, and the button creates
    an event object and calls the listener’s event handler.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2-circle.png) 用户单击按钮，按钮创建事件对象并调用监听器的事件处理程序。'
- en: '![image](Images/f0477-02.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-02.png)'
- en: '![images](Images/3-circle.png) The event handler calls repaint() on the frame.
    The system calls paintComponent() on the drawing panel.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3-circle.png) 事件处理程序在框架上调用 repaint()。系统在绘图面板上调用 paintComponent()。'
- en: '![images](Images/4-circle.png) Voilà! A new color is painted because paintComponent()
    runs again, filling the circle with a random color.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4-circle.png) 瞧！因为 paintComponent() 再次运行，一个新的颜色被绘制，填充了圆形。'
- en: '![image](Images/f0477-03.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-03.png)'
- en: '![image](Images/f0478-01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-01.png)'
- en: 'GUI layouts: putting more than one widget on a frame'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI 布局：在一个框架上放置多个小部件
- en: 'We cover GUI layouts in the *next* chapter, but we’ll do a quickie lesson here
    to get you going. By default, a frame has five regions you can add to. You can
    add only *one* thing to each region of a frame, but don’t panic! That one thing
    might be a panel that holds three other things including a panel that holds two
    more things and...you get the idea. In fact, we were “cheating” when we added
    a button to the frame using:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*下一*章节中讨论 GUI 布局，但我们在这里快速进行一次课程，让您开始。默认情况下，框架有五个区域可以添加。您可以仅向框架的每个区域添加*一*个事物，但不要惊慌！那个事物可能是一个面板，包含三个其他事物，包括一个面板，再加上两个事物...你明白了吧。事实上，当我们使用以下内容将按钮添加到框架时，我们是“作弊”的：
- en: '![image](Images/f0478-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-02.png)'
- en: '**The circle changes color each time you click the button.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**每次单击按钮时，圆圈的颜色都会改变。**'
- en: '![image](Images/f0479-01.png)![image](Images/f0479-02.png)![image](Images/f0479-03.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0479-01.png)![图片](Images/f0479-02.png)![图片](Images/f0479-03.png)'
- en: Let’s try it with TWO buttons
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们用两个按钮再试一次
- en: The south button will act as it does now, simply calling repaint on the frame.
    The second button (which we’ll stick in the east region) will change the text
    on a label. (A label is just text on the screen.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 南侧按钮将像现在一样起作用，只需在框架上调用 repaint。第二个按钮（我们将放在东侧区域）将更改标签上的文本。（标签只是屏幕上的文本。）
- en: So now we need FOUR widgets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在我们需要四个小部件
- en: '![image](Images/f0480-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0480-01.png)'
- en: And we need to get TWO events
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 而且我们需要获取两个事件
- en: Uh-oh.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哦。
- en: Is that even possible? How do you get *two* events when you have only *one*
    actionPerformed() method?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至可能吗？当你只有 *一个* actionPerformed() 方法时如何获得 *两个* 事件？
- en: '![image](Images/f0480-02.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0480-02.png)'
- en: How do you get action events for two different buttons when each button needs
    to do something different?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在每个按钮都需要执行不同操作时获取两个不同按钮的操作事件？
- en: '![image](Images/f0483-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0483-01.png)'
- en: Inner class to the rescue!
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类来拯救！
- en: You *can* have one class nested inside another. It’s easy. Just make sure that
    the definition for the inner class is *inside* the curly braces of the outer class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您*可以*在一个类中嵌套另一个类。这很容易。只需确保内部类的定义在外部类的花括号内部。
- en: '**Simple inner class:**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单内部类：**'
- en: '![image](Images/f0484-01.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0484-01.png)'
- en: An inner class gets a special pass to use the outer class’s stuff. *Even the
    private stuff.* And the inner class can use those private variables and methods
    of the outer class as if the variables and members were defined in the inner class.
    That’s what’s so handy about inner classes—they have most of the benefits of a
    normal class, but with special access rights.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类获得了特别许可，可以使用外部类的东西。*即使是私有的东西也一样。*内部类可以像在内部类中定义变量和方法一样使用外部类的私有变量和方法。这就是内部类如此方便的地方——它们具有大多数普通类的优点，但具有特殊的访问权限。
- en: '**Inner class using an outer class variable**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部类使用外部类变量**'
- en: '![image](Images/f0484-02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0484-02.png)'
- en: An inner class instance must be tied to an outer class instance*
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类实例必须与外部类实例绑定
- en: Remember, when we talk about an inner *class* accessing something in the outer
    class, we’re really talking about an *instance* of the inner class accessing something
    in an *instance* of the outer class. But *which* instance?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们讨论内部 *类* 访问外部类的某物时，我们实际上在讨论内部类的一个 *实例* 访问外部类的一个 *实例*。但是 *哪个* 实例呢？
- en: Can *any* arbitrary instance of the inner class access the methods and variables
    of *any* instance of the outer class? **No!**
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*内部类的* 任意 *实例都可以访问* 外部类的 *任意* 实例的方法和变量吗？ **不！**'
- en: '*An **inner** object must be tied to a specific **outer** object on the heap.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个 **内部** 对象必须与堆上特定的 **外部** 对象相关联。*'
- en: '![image](Images/f0485-03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0485-03.png)'
- en: '![images](Images/1.png) Make an instance of the outer class'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 实例化外部类的一个实例'
- en: '![image](Images/f0485-01.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0485-01.png)'
- en: '![images](Images/2.png) Make an instance of the inner class, by using the instance
    of the outer class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 通过外部类的实例实例化内部类。'
- en: '![image](Images/f0485-02.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0485-02.png)'
- en: '![images](Images/3.png) The outer and inner objects are now intimately linked.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/3.png) 外部和内部对象现在紧密联系在一起。'
- en: '![image](Images/f0485-04.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0485-04.png)'
- en: '* There’s an exception to this, for a very special case—an inner class defined
    within a static method. But we’re not going there, and you might go your entire
    Java life without ever encountering one of these.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* 有一个例外情况，即一个非常特殊的情况——在静态方法内定义的内部类。但是我们不会讨论那里，你可能在整个Java生涯中从未遇到过这种情况。'
- en: How to make an instance of an inner class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建内部类的实例
- en: If you instantiate an inner class from code *within* an outer class, the instance
    of the outer class is the one that the inner object will “bond” with. For example,
    if code within a method instantiates the inner class, the inner object will bond
    to the instance whose method is running.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在外部类的代码*内部*实例化内部类，则内部对象将与运行该方法的实例“绑定”。例如，如果方法内的代码实例化内部类，则内部对象将绑定到运行该方法的实例。
- en: Code in an outer class can instantiate one of its own inner classes, in exactly
    the same way it instantiates any other class...**`new MyInner()`**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部类中的代码可以实例化其自己的内部类，就像实例化任何其他类一样... **`new MyInner()`**。
- en: '![image](Images/f0486-01.png)![image](Images/f0486-02.png)![image](Images/f0486-03.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0486-01.png)![image](Images/f0486-02.png)![image](Images/f0486-03.png)'
- en: '**Now we can get the two-button code working**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们可以让这两个按钮的代码工作**'
- en: '![image](Images/f0487-01.png)![image](Images/f0487-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0487-01.png)![image](Images/f0487-02.png)'
- en: Java Exposed
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java暴露
- en: '![image](Images/f0488-01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0488-01.png)'
- en: '**This week’s interview: Instance of an Inner Class**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**本周的访谈：内部类的实例**'
- en: '**HeadFirst:** What makes inner classes important?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 什么使内部类如此重要？'
- en: '**Inner object:** Where do I start? We give you a chance to implement the same
    interface more than once in a class. Remember, you can’t implement a method more
    than once in a normal Java class. But using *inner* classes, each inner class
    can implement the *same* interface, so you can have all these *different* implementations
    of the very same interface methods.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 我从哪里开始呢？我们为你提供了在类中多次实现同一个接口的机会。请记住，在普通的Java类中，你不能多次实现方法。但是使用*内部*类，每个内部类都可以实现*相同*的接口，因此你可以拥有所有这些*不同*的接口方法实现。'
- en: '**HeadFirst:** *Why would you ever* want to implement the same method twice?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *你为什么会想要* 两次 *实现相同的方法呢？*'
- en: '**Inner object:** *Let’s revisit GUI event handlers. Think about it...if you
    want* three *buttons to each have a different event behavior, then use* three
    inner classes, all implementing ActionListener—which means each class gets to
    implement its own actionPerformed method.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** *让我们重新审视GUI事件处理程序。考虑一下...如果你希望* 三个 *按钮分别具有不同的事件行为，那么使用* 三个 *内部类，所有这些类都实现ActionListener——这意味着每个类都可以实现其自己的actionPerformed方法。'
- en: '**HeadFirst:** So are event handlers the only reason to use inner classes?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 那么事件处理程序是使用内部类的唯一原因吗？'
- en: '**Inner object:** *Oh, gosh no. Event handlers are just an obvious example.
    Anytime you need a separate class but still want that class to behave as if it
    were part of* another *class, an inner class is the best—and sometimes* only—way
    to do it.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** *哦，天哪不。事件处理程序只是一个明显的例子。每当你需要一个单独的类但又希望该类表现得像是* 另一个 *类的一部分时，内部类是最好的——有时*
    唯一 *的方法。*'
- en: '**HeadFirst:** *I’m still confused here. If you want the inner class to* behave
    *like it belongs to the outer class, why have a separate class in the first place?
    Why wouldn’t the inner class code just be* in the outer class in the first place?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *我还是感到困惑。如果你希望内部类* 表现 *得像属于外部类一样，为什么一开始不直接将内部类代码* 放在 *外部类中呢？为什么不在一开始就将内部类代码放在外部类中呢？*'
- en: '**Inner object:** *I just* gave *you one scenario, where you need more than
    one implementation of an interface. But even when you’re not using interfaces,
    you might need two different* classes *because those classes represent two different*
    things. It’s good OO.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *我刚刚* 给了 *你一个场景，你需要一个接口的多个实现。但即使在不使用接口的情况下，你可能需要两个不同的* 类，因为这些类代表两种不同的*
    事物。这是良好的面向对象。'
- en: '**HeadFirst:** *Whoa. Hold on here. I thought a big part of OO design is about
    reuse and maintenance. You know, the idea that if you have two separate classes,
    they can each be modified and used independently, as opposed to stuffing it all
    into one class yada yada yada. But with an* inner *class, you’re still just working
    with one* real class in the end, right? The enclosing class is the only one that’s
    reusable and separate from everybody else. Inner classes aren’t exactly reusable.
    In fact, I’ve heard them called “Reuseless—useless over and over again.”'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *哇，慢着。我以为面向对象设计的一个重要部分是关于重用和维护。你知道，如果你有两个独立的类，它们可以分别修改和独立使用，而不是把所有东西都塞进一个类里面啰啰嗦嗦地。但是用*
    内部 *类，最后你还是只跟一个* 真正的类 打交道，对吧？外围类是唯一可重用且与其他所有人分开的类。内部类并不是特别可重用。实际上，我听说它们被称为“无重用——一次又一次无用”。'
- en: '**Inner object:** Yes, it’s true that the inner class is not *as* reusable,
    in fact sometimes not reusable at all, because it’s intimately tied to the instance
    variables and methods of the outer class. But it—'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的，内部类确实不太* 可重用，有时甚至根本不能重用，因为它与外部类的实例变量和方法紧密相关。但是——'
- en: '**HeadFirst:** —which only proves my point! If they’re not reusable, why bother
    with a separate class? I mean, other than the interface issue, which sounds like
    a workaround to me.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** —这只证明了我的观点！如果它们不可重用，为什么要费心去做一个单独的类呢？我是说，除了接口问题之外，这听起来像是一个变通方法。'
- en: '**Inner object:** As I was saying, you need to think about IS-A and polymorphism.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 正如我所说的，你需要考虑IS-A和多态性。'
- en: '**HeadFirst:** OK. And I’m thinking about them because...'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 好吧。我在考虑它们是因为……'
- en: '**Inner object:** *Because the outer and inner classes might need to pass*
    different *IS-A tests! Let’s start with the polymorphic GUI listener example.
    What’s the declared argument type for the button’s listener registration method?
    In other words, if you go to the API and check, what kind of* thing (class or
    interface type) do you have to pass to the addActionListener() method?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *因为外部和内部类可能需要传递* 不同 *的IS-A测试！让我们从多态GUI监听器的示例开始。按钮的监听器注册方法的声明参数类型是什么？换句话说，如果你去API检查，你必须传递什么*
    东西（类或接口类型） *到addActionListener()方法中？'
- en: '**HeadFirst:** You have to pass a listener. Something that implements a particular
    listener interface, in this case ActionListener. Yeah, we know all this. What’s
    your point?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 你必须传递一个监听器。实现特定监听器接口的东西，这种情况下是ActionListener。是的，我们知道这些。你的观点是什么？'
- en: '**Inner object:** *My point is that polymorphically, you have a method that
    takes only one particular* type*. Something that passes the IS-A test for ActionListener.
    But—and here’s the big thing—what if your class needs to be an IS-A of something
    that’s a* class type rather than an interface?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *我的观点是，从多态的角度来看，你有一个只接受特定* 类型 *的方法。一些通过ActionListener的IS-A测试。但是——这里的大问题是——如果你的类需要成为一个类类型的IS-A而不是一个接口呢？'
- en: '**HeadFirst:** *Wouldn’t you have your class just* extend the class you need
    to be a part of? Isn’t that the whole point of how subclassing works? If B is
    a subclass of A, then anywhere an A is expected a B can be used. The whole pass-a-Dog-where-an-Animal-is-the-declared-type
    thing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *你为什么不让你的类* 扩展 *你需要成为其一部分的类呢？这不是子类化工作的全部意义吗？如果B是A的子类，那么无论何处期望A，都可以使用B。整个将Dog传递到Animal声明类型的事情。'
- en: '**Inner object:** Yes! Bingo! So now what happens if you need to pass the IS-A
    test for two different classes? Classes that aren’t in the same inheritance hierarchy?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的！对了！那么现在如果你需要通过两个不同的类的IS-A测试呢？那些类不在同一继承层次结构中怎么办？'
- en: '**HeadFirst:** *Oh, well you just...hmmm. I think I’m getting it. You can always*
    implement *more than one interface, but you can* extend *only* one *class. You
    can be only one kind of IS-A when it comes to* class types.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *哦，好吧，你只需……嗯，我想我明白了。你可以始终* 实现 *多个接口，但在* 类 *类型方面，你只能* 扩展 *一个*
    类。在类类型方面，你只能成为一种IS-A。'
- en: '**Inner object:** *Well done! Yes, you can’t be both a Dog and a Button. But
    if you’re a Dog that needs to sometimes be a Button (in order to pass yourself
    to methods that take a Button), the Dog class (which extends Animal so it can’t
    extend Button) can have an* inner class that acts on the Dog’s behalf as a Button,
    by extending Button, and thus wherever a Button is required, the Dog can pass
    his inner Button instead of himself. In other words, instead of saying x.takeButton(this),
    the Dog object calls x.takeButton(new MyInnerButton()).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *干得好！是的，你不能同时是狗和按钮。但如果你是一只需要偶尔充当按钮的狗（为了将自己传递给需要按钮的方法），那么狗类（继承自动物，因此无法扩展按钮）可以有一个内部类来代表狗充当按钮，通过扩展按钮，因此在需要按钮的任何地方，狗可以传递它的内部按钮而不是它自己。换句话说，不是说x.takeButton(this)，而是狗对象调用x.takeButton(new
    MyInnerButton())。*'
- en: '**HeadFirst:** Can I get a clear example?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 我能得到一个清晰的例子吗？'
- en: '**Inner object:** Remember the drawing panel we used, where we made our own
    subclass of JPanel? Right now, that class is a separate, non-inner, class. And
    that’s fine, because the class doesn’t need special access to the instance variables
    of the main GUI. But what if it did? What if we’re doing an animation on that
    panel, and it’s getting its coordinates from the main application (say, based
    on something the user does elsewhere in the GUI). In that case, if we make the
    drawing panel an inner class, the drawing panel class gets to be a subclass of
    JPanel, while the outer class is still free to be a subclass of something else.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 记得我们使用的绘图面板，我们在那里创建了自己的JPanel子类吗？现在，那个类是一个单独的非内部类。这没问题，因为该类不需要特殊访问主GUI实例变量。但如果需要呢？如果我们在面板上做动画，并且它的坐标来自主应用程序（比如，基于用户在GUI其他地方的操作）。在这种情况下，如果将绘图面板设为内部类，那么绘图面板类就可以成为JPanel的子类，而外部类仍然可以是其他类的子类。'
- en: '**HeadFirst:** Yes, I see! And the drawing panel isn’t reusable enough to be
    a separate class anyway, since what it’s actually painting is specific to this
    one GUI application.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 是的，我明白了！而且绘图面板本身不够可重用，无法成为一个单独的类，因为它实际上绘制的内容特定于这个GUI应用程序。'
- en: '**Inner object:** Yes! You’ve got it!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的！你搞懂了！'
- en: '**HeadFirst:** *Good. Then we can move on to the nature of the* relationship
    between you and the outer instance.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *很好。那么我们可以继续讨论* 你 和外部实例之间的*关系的本质。'
- en: '**Inner object:** What is it with you people? Not enough sordid gossip in a
    serious topic like polymorphism?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 你们这些人怎么了？在多态这样严肃的话题中，八卦不够多吗？'
- en: '**HeadFirst:** Hey, you have no idea how much the public is willing to pay
    for some good old tabloid dirt. So, someone creates you, and you become instantly
    bonded to the outer object, is that right?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 嘿，你不知道公众为了一些好的旧小报狗脏料愿意付出多少钱。所以，有人创造了你，你立刻与外部对象绑定了，对吗？'
- en: '**Inner object:** Yes, that’s right.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的，没错。'
- en: '**HeadFirst:** What about the outer object? Can it be associated with any other
    inner objects?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 外部对象呢？它能与其他任何内部对象关联吗？'
- en: '**Inner object:** *So now we have it. This is what you* really *wanted. Yes,
    yes. My so-called* “mate” can have as many inner objects as it wants.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *所以现在我们明白了。这是你*真正*想要的。是的，是的。我所谓的*伴侣*可以拥有任意多个内部对象。'
- en: '**HeadFirst:** Is that like, serial monogamy? Or can it have them all at the
    same time?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 这像是串行一夫一妻制吗？还是可以同时拥有所有这些？'
- en: '**Inner object:** All at the same time. There. Satisfied?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 同时完成了。满意了吗？'
- en: '**HeadFirst:** *Well, it does make sense. And let’s not forget, it was* you
    extolling the virtues of “multiple implementations of the same interface.” So
    it makes sense that if the outer class has three buttons, it would need three
    different inner classes (and thus three different inner class objects) to handle
    the events.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *嗯，这确实有道理。而且别忘了，正是* 你 赞美了“同一接口的多种实现”。所以如果外部类有三个按钮，它就需要三个不同的内部类（因此三个不同的内部类对象）来处理事件，这很合理。'
- en: '**Inner objects:** You got it!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner objects:** 你说对了！'
- en: '**HeadFirst:** One more question. I’ve heard that when lambdas came along,
    you were almost put out of a job?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 再问一个问题。我听说当lambda表达式出现时，你几乎失业了？'
- en: '**Inner objects:** Ouch, that really hurts! Okay, full disclosure, there are
    many cases for which a lambda is an easier to read, more concise way to do what
    I do. But inner classes have been around for a long time, and you’re sure to encounter
    us in older code. Plus, those pesky lambdas aren’t better at everything..'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 哎呀，这真的很痛！好吧，完全披露，有很多情况下，lambda 是执行我所做的事情更易于阅读、更简洁的方式。但是内部类已经存在很长时间了，您肯定会在旧代码中遇到我们。另外，那些讨厌的
    lambda 并不是所有事情都做得更好。'
- en: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
- en: Lambdas to the rescue! (again)
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdas to the rescue! (again)
- en: 'He’s not wrong! One way to interpret the two highlighted lines of code would
    be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 他并没有错！解释两行代码中突出显示的一种方法可能是：
- en: “When the `labelButton` *ActionListener gets an event,* `setText("Ouch");`”
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: “当 `labelButton` 的 *ActionListener 得到一个事件*时，`setText("Ouch");`”
- en: Not only are those two ideas separated from each other in the code, the inner
    class takes FIVE lines of code to invoke the setText method. And of course, everything
    we’ve said about the labelButton code is also true about the colorButton code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个想法不仅在代码中彼此分开，而且内部类需要五行代码来调用 setText 方法。当然，我们对 labelButton 代码说的一切也适用于 colorButton
    代码。
- en: Remember a few pages back we said that in order to implement the ActionListener
    interface you had provide code for its actionPerformed method? Hmmm...does that
    ring any bells?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得几页前我们说过为了实现 ActionListener 接口，你需要为其 actionPerformed 方法提供代码吗？嗯...这有点耳熟吗？
- en: '![image](Images/f0490-02.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0490-02.png)'
- en: ActionListener is a Functional Interface
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActionListener 是一个功能接口
- en: '**Remember that a lambda provides an implementation for a functional interface’s
    *one and only* abstract method.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**请记住，lambda 为功能接口的*唯一*抽象方法提供了实现。**'
- en: Since ActionListener is a functional interface, you can replace the inner classes
    we saw on the previous page with lambda expressions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ActionListener 是一个功能接口，您可以用 lambda 表达式替换我们在前一页看到的内部类。
- en: '![image](Images/f0491-01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0491-01.png)'
- en: Lambdas, clearer and more concise
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdas, clearer and more concise
- en: Well, maybe not quite yet, but once you get used to reading lambdas, we’re pretty
    sure you’ll agree that they make your code clearer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许现在还不完全是这样，但是一旦您习惯阅读 lambda 表达式，我们相信您会同意它们使您的代码更清晰。
- en: Using an inner class for animation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Using an inner class for animation
- en: We saw why inner classes are handy for event listeners, because you get to implement
    the same event-handling method more than once. But now we’ll look at how useful
    an inner class is when used as a subclass of something the outer class doesn’t
    extend. In other words, when the outer class and inner class are in different
    inheritance trees!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到为什么内部类在事件监听器中很方便，因为您可以多次实现相同的事件处理方法。但现在我们将看看当内部类用作外部类不继承的东西的子类时，内部类有多有用。换句话说，当外部类和内部类在不同的继承树中时！
- en: Our goal is to make a simple animation, where the circle moves across the screen
    from the upper left down to the lower right.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个简单的动画，其中圆圈从屏幕的左上角向右下角移动。
- en: '![image](Images/f0492-01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0492-01.png)'
- en: '**How simple animation works**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单动画的工作原理**'
- en: '![images](Images/1.png) Paint an object at a particular x and y coordinate.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 在特定的 x 和 y 坐标处绘制对象。'
- en: '![image](Images/f0492-02.png)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0492-02.png)'
- en: '![images](Images/2.png) Repaint the object at a different x and y coordinate.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 在不同的 x 和 y 坐标处重新绘制对象。'
- en: '![image](Images/f0492-03.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0492-03.png)'
- en: '![images](Images/3.png) Repeat the previous step with changing x and y values
    for as long as the animation is supposed to continue.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/3.png) 在动画应该继续的时间内，通过更改 x 和 y 的值重复上一步骤。'
- en: '**What we really want is something like...**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们真正想要的是像这样的东西...**'
- en: '![image](Images/f0493-01.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0493-01.png)'
- en: '**The complete simple animation code**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的简单动画代码**'
- en: '![image](Images/f0494-01.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0494-01.png)'
- en: '**Did it work?**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功了吗？**'
- en: You might not have got the smooth animation that you expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能没有得到您预期的流畅动画。
- en: What did we do wrong?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做错了什么？
- en: There’s one little flaw in the paintComponent() method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 paintComponent() 方法中有一个小缺陷。
- en: '**We need to erase what was already there! Or we might get trails.**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们需要擦除已经存在的内容！否则可能会留下轨迹。**'
- en: 'To fix it, all we have to do is fill in the entire panel with the background
    color, before painting the circle each time. The code below adds two lines at
    the start of the method: one to set the color to white (the background color of
    the drawing panel) and the other to fill the entire panel rectangle with that
    color. In English, the code below says, “Fill a rectangle starting at x and y
    of 0 (0 pixels from the left and 0 pixels from the top) and make it as wide and
    as high as the panel is currently.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复它，我们只需在每次绘制圆之前用背景颜色填充整个面板。下面的代码在方法开头添加了两行：一行是将颜色设置为白色（绘图面板的背景颜色），另一行是用该颜色填充整个面板矩形。简而言之，下面的代码用英语表示，“填充一个从
    x 和 y 为 0 开始的矩形（距左侧和顶部各 0 像素）并使其宽度和高度与面板当前的宽度和高度相同。
- en: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **由你来解决。**'
- en: Code Kitchen
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码厨房
- en: '![image](Images/f0496-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0496-01.png)'
- en: '**Let’s make a music video. We’ll use Java-generated random graphics that keep
    time with the music beats.**'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**让我们制作一个音乐视频。我们将使用由 Java 生成的随着音乐节拍保持时间的随机图形。**'
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Along the way we’ll register (and listen for) a new kind of non-GUI event,
    triggered by the music itself.**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**在这个过程中，我们将注册（并监听）一种新的非 GUI 事件，由音乐本身触发。**'
- en: Note
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, this part is all optional. But we think it’s good for you. And you’ll
    like it. And you can use it to impress people.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这部分都是可选的。但我们认为这对你有好处。而且你会喜欢它的。你可以用它来给人留下深刻印象。
- en: (OK, sure, it might work only on people who are really easy to impress, but
    still....)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: （好吧，当然，这可能只对那些很容易感动的人有效，但还是....）
- en: Listening for a non-GUI event
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听非 GUI 事件
- en: OK, maybe not a music video, but we *will* make a program that draws random
    graphics on the screen with the beat of the music. In a nutshell, the program
    listens for the beat of the music and draws a random graphic rectangle with each
    beat.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许不是一个音乐视频，但我们*将*制作一个程序，在音乐的节拍下在屏幕上绘制随机图形。简而言之，该程序监听音乐的节拍，并在每个节拍时绘制一个随机图形矩形。
- en: 'That brings up some new issues for us. So far, we’ve listened for only GUI
    events, but now we need to listen for a particular kind of MIDI event. Turns out,
    listening for a non-GUI event is just like listening for GUI events: you implement
    a listener interface, register the listener with an event source, and then sit
    back and wait for the event source to call your event-handler method (the method
    defined in the listener interface).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一些新问题。到目前为止，我们只监听了 GUI 事件，但现在我们需要监听特定类型的 MIDI 事件。事实证明，监听非 GUI 事件就像监听
    GUI 事件一样：你实现一个监听器接口，将监听器注册到事件源，然后坐下来等待事件源调用你的事件处理方法（在监听器接口中定义的方法）。
- en: The simplest way to listen for the beat of the music would be to register and
    listen for the actual MIDI events so that whenever the sequencer gets the event,
    our code will get it too and can draw the graphic. But...there’s a problem. A
    bug, actually, that won’t let us listen for the MIDI events *we’re* making (the
    ones for NOTE ON).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 监听音乐节拍的最简单方法是注册并监听实际的 MIDI 事件，这样每当序列器收到事件时，我们的代码也会收到，并且可以绘制图形。但是...有一个问题。实际上是一个
    bug，它不允许我们监听*我们*制作的 MIDI 事件（NOTE ON 的事件）。
- en: 'So we have to do a little workaround. There is another type of MIDI event we
    can listen for, called a ControllerEvent. Our solution is to register for ControllerEvents
    and then make sure that for every NOTE ON event, there’s a matching ControllerEvent
    fired at the same “beat.” How do we make sure the ControllerEvent is fired at
    the same time? We add it to the track just like the other events! In other words,
    our music sequence goes like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须做一些变通。我们可以监听另一种类型的 MIDI 事件，称为控制器事件。我们的解决方案是注册 ControllerEvents，然后确保对于每个
    NOTE ON 事件，在相同的“节拍”上触发一个匹配的 ControllerEvent。我们如何确保 ControllerEvent 在同一时间被触发？我们将其添加到轨道中，就像其他事件一样！换句话说，我们的音乐序列如下：
- en: BEAT 1 - NOTE ON, CONTROLLER EVENT
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 节拍 1 - 音符开启，控制器事件
- en: BEAT 2 - NOTE OFF
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 节拍 2 - 音符关闭
- en: BEAT 3 - NOTE ON, CONTROLLER EVENT
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 节拍 3 - 音符开启，控制器事件
- en: BEAT 4 - NOTE OFF
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 节拍 4 - 音符关闭
- en: and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: Before we dive into the full program, though, let’s make it a little easier
    to make and add MIDI messages/events since in *this* program, we’re gonna make
    a lot of them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们深入全面的程序之前，让我们让制作和添加 MIDI 消息/事件变得更容易，因为在*这个*程序中，我们将制作很多这样的事件。
- en: '**What the music art program needs to do:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**音乐艺术程序需要做的事情：**'
- en: '![images](Images/1.png) Make a series of MIDI messages/events to play random
    notes on a piano (or whatever instrument you choose).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 制作一系列 MIDI 消息/事件来在钢琴（或您选择的乐器）上播放随机音符。'
- en: '![images](Images/2.png) Register a listener for the events.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 注册一个事件的监听器。'
- en: '![images](Images/3.png) Start the sequencer playing.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 启动序列播放器。'
- en: '![images](Images/4.png) Each time the listener’s event handler method is called,
    draw a random rectangle on the drawing panel, and call repaint.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 每当监听器的事件处理方法被调用时，在绘图面板上绘制一个随机矩形，并调用 repaint。'
- en: '**We’ll build it in three iterations:**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们将分三个迭代来构建它：**'
- en: '![images](Images/1.png) Version One: Code that simplifies making and adding
    MIDI events, since we’ll be making a lot of them.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 第一版：简化了制作和添加 MIDI 事件的代码，因为我们将会制作很多这样的事件。'
- en: '![images](Images/2.png) Version Two: Register and listen for the events, but
    without graphics. Prints a message at the command line with each beat.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 第二版：注册并监听事件，但不包含图形。每个节拍在命令行打印一个消息。'
- en: '![images](Images/3.png) Version Three: The real deal. Adds graphics to version
    two.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 第三版：真正的交易。在第二版中添加图形。'
- en: An easier way to make messages/events
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种更简单的制作消息/事件的方法
- en: Right now, making and adding messages and events to a track is tedious. For
    each message, we have to make the message instance (in this case, ShortMessage),
    call setMessage(), make a MidiEvent for the message, and add the event to the
    track. In the previous chapter’s code, we went through each step for every message.
    That means eight lines of code just to make a note play and then stop playing!
    Four lines to add a NOTE ON event, and four lines to add a NOTE OFF event.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，制作并添加消息和事件到轨道是件麻烦事。对于每条消息，我们必须创建消息实例（在本例中为 ShortMessage），调用 setMessage()，为消息创建一个
    MidiEvent，并将事件添加到轨道中。在上一章的代码中，我们为每条消息执行了这些步骤。这意味着为了播放一个音符而停止播放，我们需要八行代码！四行用于添加
    NOTE ON 事件，四行用于添加 NOTE OFF 事件。
- en: '[PRE3]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Things that have to happen for each event:**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个事件都必须发生的事情：**'
- en: '![images](Images/1.png) Make a message instance'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 创建一个消息实例'
- en: '`**ShortMessage msg = new ShortMessage();**`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**ShortMessage msg = new ShortMessage();**`'
- en: '![images](Images/2.png) Call setMessage() with the instructions'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 使用 setMessage() 调用消息'
- en: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
- en: '![images](Images/3.png) Make a MidiEvent instance for the message'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 为消息创建一个 MidiEvent 实例'
- en: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
- en: '![images](Images/4.png) Add the event to the track'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 将事件添加到轨道'
- en: '`**track.add(noteOn);**`'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**track.add(noteOn);**`'
- en: '**Let’s build a static utility method that makes a message and returns a MidiEvent**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们建立一个静态实用方法来创建消息并返回 MidiEvent**'
- en: '![image](Images/f0498-02.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0498-02.png)'
- en: 'Version One: using the new static makeEvent() method'
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一版：使用新的静态 makeEvent() 方法
- en: There’s no event handling or graphics here, just a sequence of 15 notes that
    go up the scale. The point of this code is simply to learn how to use our new
    makeEvent() method. The code for the next two versions is much smaller and simpler
    thanks to this method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有事件处理或图形，只是一系列沿着音阶上升的15个音符。这段代码的目的仅仅是学习如何使用我们的新的 makeEvent() 方法。下面两个版本的代码要小得多，也简单得多，多亏了这个方法。
- en: '![image](Images/f0499-01.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0499-01.png)'
- en: 'Version Two: registering and getting ControllerEvents'
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二版：注册并获取 ControllerEvents
- en: '![image](Images/f0500-01.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0500-01.png)'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Code that’s different from the previous version is highlighted in gray (and
    we’ve moved the code out of the main() method into its own go() method).**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**与上一个版本不同的代码用灰色突出显示（我们将代码从 main() 方法移到了自己的 go() 方法中）。**'
- en: 'Version Three: drawing graphics in time with the music'
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三版：与音乐同时绘制图形
- en: This final version builds on Version Two by adding the GUI parts. We build a
    frame and add a drawing panel to it, and each time we get an event, we draw a
    new rectangle and repaint the screen. The only other change from Version Two is
    that the notes play randomly as opposed to simply moving up the scale.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终版本在第二版的基础上增加了 GUI 部分。我们建立了一个框架并向其添加了绘图面板，每当我们收到一个事件时，我们就会绘制一个新的矩形并重新绘制屏幕。与第二版唯一的其他变化是音符是随机播放的，而不是简单地上升音阶。
- en: The most important change to the code (besides building a simple GUI) is that
    we make the drawing panel implement the ControllerEventListener rather than the
    program itself. So when the drawing panel (an inner class) gets the event, it
    knows how to take care of itself by drawing the rectangle.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的更改（除了构建一个简单的GUI之外）是，我们使绘图面板实现ControllerEventListener，而不是程序本身。因此，当绘图面板（一个内部类）收到事件时，它知道如何通过绘制矩形来照顾自己。
- en: Complete code for this version is on the next page.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的完整代码在下一页。
- en: '**The drawing panel inner class:**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘图面板内部类：**'
- en: '![image](Images/f0501-01.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0501-01.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **由您来解决。**'
- en: '[PRE4]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: A bunch of Java hotshots, in full costume, are playing the party game “Who am
    I?” They give you a clue, and you try to guess who they are, based on what they
    say. Assume they always tell the truth about themselves. If they happen to say
    something that could be true for more than one guy, then write down all for whom
    that sentence applies. Fill in the blanks next to the sentence with the names
    of one or more attendees.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一群Java高手，穿着全副武装，正在玩“我是谁？”派对游戏。他们给了你一个线索，你根据他们说的话来猜他们是谁。假设他们总是说实话。如果他们碰巧说的话对多个人都成立，那么请将适用的人名填入句子旁边的空白处。
- en: Who Am I?
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: '![image](Images/f0504-02.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0504-02.png)'
- en: '**Tonight’s attendees:**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**今晚的参与者：**'
- en: '**Any of the charming personalities from this chapter just might show up!**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章中任何迷人的个性可能都会出现！**'
- en: '| **I got the whole GUI, in my hands.** | ______________________ |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **我把整个GUI都握在手中。** | ______________________ |'
- en: '| **Every event type has one of these.** | ______________________ |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **每种事件类型都有一个。** | ______________________ |'
- en: '| **The listener’s key method.** | ______________________ |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **侦听器的关键方法。** | ______________________ |'
- en: '| **This method gives JFrame its size.** | ______________________ |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **这个方法使JFrame得到大小。** | ______________________ |'
- en: '| **You add code to this method but never call it.** | ______________________
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **你在这个方法中添加代码，但从未调用它。** | ______________________ |'
- en: '| **When the user actually does something, it’s an _____ .** | ______________________
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **当用户实际做某事时，这是一个 _____.** | ______________________ |'
- en: '| **Most of these are event sources.** | ______________________ |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **大多数都是事件源。** | ______________________ |'
- en: '| **I carry data back to the listener.** | ______________________ |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **我把数据带回给侦听器。** | ______________________ |'
- en: '| **An addXxxListener( ) method says an object is an _____ .** | ______________________
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **addXxxListener( )方法表示对象是一个 _____.** | ______________________ |'
- en: '| **How a listener signs up.** | ______________________ |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **监听器如何注册。** | ______________________ |'
- en: '| **The method where all the graphics code goes.** | ______________________
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **所有图形代码都放入的方法。** | ______________________ |'
- en: '| **I’m typically bound to an instance.** | ______________________ |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **我通常绑定到一个实例。** | ______________________ |'
- en: '| **The “g” in (Graphics g) is really of this class.** | ______________________
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **(Graphics g) 中的“g”实际上是属于这个类。** | ______________________ |'
- en: '| **The method that gets paintComponent( ) rolling.** | ______________________
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **使JFrame得到大小的方法。** | ______________________ |'
- en: '| **The package where most of the Swingers reside.** | ______________________
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **大多数交换机居住的包。** | ______________________ |'
- en: '![image](Images/arr.png) **Answers in [“Who am I?”](#who_am_iquestion_mark_left_parenthesisfr).**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“我是谁？”](#who_am_iquestion_mark_left_parenthesisfr)中。**'
- en: BE the Compiler
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the Compiler
- en: '![image](Images/f0505-02.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0505-02.png)'
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Java file on this page represents a complete source file. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it, and if it does compile, what would it do?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面上的Java文件代表一个完整的源文件。您的任务是扮演编译器，确定这个文件是否会编译。如果不能编译，您将如何修复它？如果能编译，它会做什么？
- en: '[PRE5]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](Images/arr.png) **Answers in [“BE the Compiler”](#be_the_compiler-id00003).**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“BE the Compiler”](#be_the_compiler-id00003)中。**'
- en: Pool Puzzle
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/f0506-01.png)![image](Images/f0506-02.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-01.png)![image](Images/f0506-02.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You **may** use the same snippet more than once, and
    you won’t need to use all the snippets. Your ***goal*** is to make a class that
    will compile and run and produce the output listed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您的***工作***是从池中获取代码片段并将它们放入代码中的空白行。您可以多次使用相同的片段，但不需要使用所有片段。您的***目标***是创建一个可以编译、运行并生成所列输出的类。
- en: '**Output**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The Amazing, Shrinking, Blue Rectangle. This program will produce a blue rectangle
    that will shrink and shrink and disappear into a field of white.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊奇的、收缩的、蓝色矩形。这个程序将生成一个蓝色的矩形，它会收缩、收缩，最终消失在白色的背景中。
- en: '![image](Images/f0506-03.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-03.png)'
- en: '**Note: Each snippet from the pool can be used more than once!**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个片段可以多次使用！**'
- en: '![image](Images/f0506-04.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-04.png)'
- en: '[PRE6]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](Images/arr.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_50).**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_50)中。**'
- en: Exercise Solutions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: '![image](Images/exercise.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Who am I?
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: (from [“Exercise”](#exercise-id000023))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“Exercise”](#exercise-id000023)）
- en: '| **I got the whole GUI, in my hands.** | JFrame |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **我把整个GUI掌握在手中。** | JFrame |'
- en: '| **Every event type has one of these.** | listener interface |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **每种事件类型都有一个。** | 侦听器接口 |'
- en: '| **The listener’s key method.** | actionPerformed( ) |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **侦听器的关键方法。** | actionPerformed( ) |'
- en: '| **This method gives JFrame its size.** | setSize( ) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **这个方法为JFrame设置其大小。** | setSize( ) |'
- en: '| **You add code to this method but never call it.** | paintComponent( ) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **你在这个方法中添加代码但从未调用它。** | paintComponent( ) |'
- en: '| **When the user actually does something, it’s an ____ .** | event |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| **当用户实际执行操作时，它是一个____。** | 事件 |'
- en: '| **Most of these are event sources.** | swing components |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **这些大多数是事件源。** | Swing组件 |'
- en: '| **I carry data back to the listener.** | event object |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **我将数据返回给侦听器。** | 事件对象 |'
- en: '| **An addXxxListener( ) method says an object is an ___ .** | event source
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **一个addXxxListener( )方法表示对象是一个___。** | event source |'
- en: '| **How a listener signs up.** | addXxxListener( ) |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **侦听器如何注册。** | addXxxListener( ) |'
- en: '| **The method where all the graphics code goes.** | paintComponent( ) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **所有图形代码都在这个方法中。** | paintComponent( ) |'
- en: '| **I’m typically bound to an instance.** | inner class |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **我通常绑定到一个实例。** | 内部类 |'
- en: '| **The “g” in (Graphics g) is really of this class.** | Graphics2D |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **在（Graphics g）中，“g”实际上是这个类的一部分。** | Graphics2D |'
- en: '| **The method that gets paintComponent( ) rolling.** | repaint( ) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **触发paintComponent( )方法的方法。** | repaint( ) |'
- en: '| **The package where most of the Swingers reside.** | javax.swing |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **大多数Swingers居住的包。** | javax.swing |'
- en: BE the Compiler
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the Compiler
- en: (from [“BE the Compiler”](#be_the_compiler-id00003))
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“BE the Compiler”](#be_the_compiler-id00003)）
- en: '![image](Images/f0507-01.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0507-01.png)'
- en: Pool Puzzle
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pool Puzzle
- en: (from [“Pool Puzzle”](#pool_puzzle-id00006))
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“Pool Puzzle”](#pool_puzzle-id00006)）
- en: '![image](Images/f0506-01.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-01.png)'
- en: '[PRE7]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Amazing, Shrinking, Blue Rectangle.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊奇的、收缩的、蓝色矩形。
- en: '![image](Images/f0508-01.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0508-01.png)'
