- en: 'Chapter 4\. How Objects Behave: Methods Use Instance Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。对象的行为：方法使用实例变量
- en: '![image](Images/f0071-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0071-01.png)'
- en: '**State affects behavior, behavior affects state**. We know that objects have
    **state** and **behavior**, represented by **instance variables** and **methods**.
    But until now, we haven’t looked at how state and behavior are *related*. We already
    know that each instance of a class (each object of a particular type) can have
    its own unique values for its instance variables. Dog A can have a *name* “Fido”
    and a *weight* of 70 pounds. Dog B is “Killer” and weighs 9 pounds. And if the
    Dog class has a method makeNoise(), well, don’t you think a 70-pound dog barks
    a bit deeper than the little 9-pounder? (Assuming that annoying yippy sound can
    be considered a *bark*.) Fortunately, that’s the whole point of an object—it has
    *behavior* that acts on its *state*. In other words, ***methods use instance variable
    values***. Like, “if dog is less than 14 pounds, make yippy sound, else...” or
    “increase weight by 5.” ***Let’s go change some state.***'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态影响行为，行为影响状态**。我们知道对象具有**状态**和**行为**，由**实例变量**和**方法**表示。但直到现在，我们还没有探讨状态和行为之间的*关系*。我们已经知道类的每个实例（特定类型的每个对象）可以为其实例变量拥有自己独特的值。狗A可以有一个名为“Fido”的*名字*，体重为70磅。狗B是“Killer”，体重为9磅。如果狗类有一个叫做makeNoise()的方法，那么你认为一只70磅的狗会比那只小9磅的狗叫得更深吗？（假设那烦人的尖叫声可以被视为*叫声*。）幸运的是，这就是对象的全部意义——它具有*行为*，可以作用于其*状态*。换句话说，***方法使用实例变量值***。比如，“如果狗的体重小于14磅，则发出尖叫声，否则...”或“增加体重5磅。”***让我们去改变一些状态吧。***'
- en: 'Remember: a class describes what an object knows and what an object does'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住：一个类描述了一个对象知道什么和做什么
- en: '![image](Images/f0072-01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0072-01.png)'
- en: '**A class is the blueprint for an object.** When you write a class, you’re
    describing how the JVM should make an object of that type. You already know that
    every object of that type can have different *instance variable* values. But what
    about the methods?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个类是对象的蓝图。**当你编写一个类时，你描述的是JVM应该如何制造该类型的对象。你已经知道该类型的每个对象可以有不同的*实例变量*值。但方法呢？'
- en: Can every object of that type have different method behavior?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 该类型的每个对象的方法行为都可能不同吗？
- en: '![image](Images/f0072-02.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0072-02.png)'
- en: Well...***sort of.****
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...***有点像。****
- en: Every instance of a particular class has the same methods, but the methods can
    *behave* differently based on the value of the instance variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类的每个实例具有相同的方法，但这些方法可以根据实例变量的值*表现*不同。
- en: The Song class has two instance variables, *title* and *artist*. When you call
    the play() method on an the instance, it will play the song represented by the
    value of the *title* and *artist* instance variables for that instance. So, if
    you call the play() method on one instance, you’ll hear the song “Havana” by Cabello,
    while another instance plays “Sing” by Travis. The method code, however, is the
    same.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Song类有两个实例变量，*title*和*artist*。当你在一个实例上调用play()方法时，它将播放由*title*和*artist*实例变量值表示的歌曲。因此，如果你在一个实例上调用play()方法，你将听到卡贝洛的“Havana”，而另一个实例则播放特拉维斯的“Sing”。但方法的代码是相同的。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The size affects the bark
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小影响叫声
- en: A small Dog’s bark is different from a big Dog’s bark.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 小狗的叫声不同于大狗的叫声。
- en: '![image](Images/f0073-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0073-02.png)'
- en: The Dog class has an instance variable *size* that the *bark()* method uses
    to decide what kind of bark sound to make.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Dog类有一个实例变量*size*，bark()方法使用它来决定发出什么样的叫声。
- en: '![image](Images/f0073-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0073-01.png)'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '* * *'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![image](Images/f0073-03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0073-03.png)'
- en: You can send things to a method
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以把东西送给一个方法
- en: 'Just as you expect from any programming language, you can pass values into
    your methods. You might, for example, want to tell a Dog object how many times
    to bark by calling:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从任何编程语言中期望的那样，你可以将值传递给你的方法。例如，你可能想通过调用一个Dog对象的方法告诉它叫多少次：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Depending on your programming background and personal preferences, *you* might
    use the term *arguments* or perhaps *parameters* for the values passed into a
    method. Although there *are* formal computer science distinctions that people
    who wear lab coats (and who will almost certainly not read this book) make, we
    have bigger fish to fry in this book. So *you* can call them whatever you like
    (arguments, donuts, hairballs, etc.) but we’re doing it like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的编程背景和个人偏好，*你*可能会使用术语*参数*或者*参数*来表示传递给方法的值。尽管有*正式的计算机科学*区别，穿实验室白大褂的人（几乎肯定不会读这本书）可能会用，但我们在这本书中有更重要的事情要做。所以*你*可以随意称呼它们（参数、甜甜圈、毛球等等），但我们按照这样做：
- en: '**A caller passes arguments. A method takes parameters.**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用者传递参数。方法接收参数。**'
- en: Arguments are the things you pass into the methods. An ***argument*** (a value
    like 2, Foo, or a reference to a Dog) lands face-down into a...wait for it...***parameter***.
    And a parameter is nothing more than a local variable. A variable with a type
    and a name that can be used inside the body of the method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是你传递给方法的东西。一个***参数***（像2、Foo或指向狗的引用）被面朝下地投入到...等等...***参数***中。而参数只不过是一个本地变量。一个带有类型和名称的变量，可以在方法体内使用。
- en: 'But here’s the important part: **If a method takes a parameter, you *must*
    pass it something when you call it.** And that something must be a value of the
    appropriate type.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里的重点是：**如果一个方法接收一个参数，你*必须*在调用时传递一个值。**而且那个值必须是适当类型的值。
- en: '![image](Images/f0074-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0074-01.png)'
- en: You can get things back from a method
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以从一个方法中得到东西
- en: Methods can also *return* values. Every method is declared with a return type,
    but until now we’ve made all of our methods with a **void** return type, which
    means they don’t give anything back.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以*返回*值。每个方法都声明了一个返回类型，但到目前为止，我们所有的方法都是使用**void**返回类型，这意味着它们不返回任何内容。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](Images/f0075-01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0075-01.png)'
- en: 'But we can declare a method to give a specific type of value back to the caller,
    such as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以声明一个方法，向调用者返回特定类型的值，比如：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you declare a method to return a value, you *must* return a value of the
    declared type! (Or a value that is *compatible* with the declared type. We’ll
    get into that more when we talk about polymorphism in [Chapter 7](ch07.xhtml#better_living_in_objectville_inheritance)
    and [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst).)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个方法返回一个值，你*必须*返回与声明类型*兼容*的值！（或者与声明类型*兼容*的值。在我们讨论[第7章](ch07.xhtml#better_living_in_objectville_inheritance)和[第8章](ch08.xhtml#serious_polymorphism_interfaces_and_abst)时，我们会更详细地讨论多态性。）
- en: '**Whatever you say you’ll give back, you *better* give back!**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**无论你说你会返回什么，你*一定*要返回！**'
- en: The compiler won’t let you return the wrong type of thing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会让你返回错误类型的东西。
- en: '![image](Images/f0075-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0075-02.png)'
- en: You can send more than one thing to a method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以将多个东西发送到一个方法
- en: Methods can have multiple parameters. Separate them with commas when you declare
    them, and separate the arguments with commas when you pass them. Most importantly,
    if a method has parameters, you *must* pass arguments of the right type and order.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以有多个参数。在声明它们时用逗号分隔，在传递它们时也用逗号分隔。最重要的是，如果一个方法有参数，你*必须*传递正确类型和顺序的参数。
- en: Calling a two-parameter method and sending it two arguments
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用一个有两个参数的方法，并向其发送两个参数
- en: '![image](Images/f0076-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0076-01.png)'
- en: You can pass variables into a method, as long as the variable type matches the
    parameter type
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你可以将变量传递给一个方法，只要变量类型与参数类型匹配。
- en: '![image](Images/f0076-02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0076-02.png)'
- en: Java is pass-by-value. That means pass-by-copy.
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java是按值传递的。这意味着按照拷贝传递。
- en: '![image](Images/f0077-01.png)![image](Images/f0077-02.png)![image](Images/f0077-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0077-01.png)![image](Images/f0077-02.png)![image](Images/f0077-03.png)'
- en: 'Reminder: Java cares about type!'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提醒：Java关心类型！
- en: '![image](Images/f0078-01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0078-01.png)'
- en: '**You can’t return a Giraffe when the return type is declared as a Rabbit.
    Same thing with parameters. You can’t pass a Giraffe into a method that takes
    a Rabbit.**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**当返回类型声明为兔子时，你不能返回长颈鹿。参数也是一样。你不能将长颈鹿传递给需要兔子的方法。**'
- en: Cool things you can do with parameters and return types
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以用参数和返回类型做一些很酷的事情
- en: '![image](Images/f0079-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0079-01.png)'
- en: 'Now that we’ve seen how parameters and return types work, it’s time to put
    them to good use: let’s create **Getters** and **Setters**. If you’re into being
    all formal about it, you might prefer to call them *Accessors* and *Mutators*.
    But that’s a waste of perfectly good syllables. Besides, Getters and Setters fits
    a common Java naming convention, so that’s what we’ll call them.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了参数和返回类型的工作原理，是时候将它们用于正途了：让我们创建**Getters**和**Setters**。如果你喜欢正式些，也许你更愿意称它们为*Accessors*和*Mutators*。但这样会浪费很多好音节。而且，Getters和Setters符合常见的Java命名约定，所以我们就这样称呼它们。
- en: Getters and Setters let you, well, *get and set things*. Instance variable values,
    usually. A Getter’s sole purpose in life is to send back, as a return value, the
    value of whatever it is that particular Getter is supposed to be Getting. And
    by now, it’s probably no surprise that a Setter lives and breathes for the chance
    to take an argument value and use it to *set* the value of an instance variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Getters和Setters让你可以*获取和设置东西*。通常是实例变量的值。Getter的唯一目的是作为返回值将那个特定Getter应该获取的内容的值返回。到现在为止，Setter生来就为了有机会接受一个参数值并将其用于*设置*实例变量的值。
- en: '![image](Images/f0079-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0079-02.png)'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Encapsulation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Do it or risk humiliation and ridicule.
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做或者冒着被羞辱和嘲笑的风险。
- en: '![image](Images/f0080-01.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0080-01.png)'
- en: Until this most important moment, we’ve been committing one of the worst OO
    faux pas (and we’re not talking minor violation like showing up without the “B”
    in BYOB). No, we’re talking Faux Pas with a capital “F.” And “P.”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这个最重要的时刻，我们一直在犯着最严重的面向对象的错误（我们不是说像没有“B”在BYOB这样的小违规）。不，我们说的是带着大写“F”的Faux Pas。还有“P”。
- en: Our shameful transgression?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可耻过失？
- en: Exposing our data!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 曝露我们的数据！
- en: Here we are, just humming along without a care in the world leaving our data
    out there for *anyone* to see and even touch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们就像漫不经心一样，毫不在乎地把我们的数据留给*任何人*看，甚至触摸。
- en: You may have already experienced that vaguely unsettling feeling that comes
    with leaving your instance variables exposed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经经历过那种略显不安的感觉，即离开你的实例变量暴露在外的感觉。
- en: 'Exposed means reachable with the dot operator, as in:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露意味着可通过点操作符访问，就像：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Think about this idea of using our remote control to make a direct change to
    the Cat object’s size instance variable. In the hands of the wrong person, a reference
    variable (remote control) is quite a dangerous weapon. Because what’s to prevent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个使用我们的遥控器直接改变Cat对象的大小实例变量的想法。在错误的人手中，引用变量（遥控器）是一种非常危险的武器。因为有什么能阻止：
- en: '![image](Images/f0080-02.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0080-02.png)'
- en: This would be a Bad Thing. We need to build setter methods for all the instance
    variables, and find a way to force other code to call the setters rather than
    access the data directly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个坏事。我们需要为所有的实例变量构建setter方法，并找到一种方法来强制其他代码调用setter而不是直接访问数据。
- en: '![image](Images/f0080-03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0080-03.png)'
- en: Hide the data
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏数据
- en: Yes, it *is* that simple to go from an implementation that’s just begging for
    bad data to one that protects your data *and* protects your right to modify your
    implementation later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，从一个请求坏数据的实现到一个保护你的数据*和*保护你后续修改实现权利的实现，是如此简单。
- en: OK, so how exactly do you *hide* the data? With the **`public`** and **`private`**
    access modifiers. You’re familiar with **`public`**—we use it with every main
    method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么如何*隐藏*数据？通过**`public`**和**`private`**访问修饰符。你对**`public`**很熟悉——我们在每个主方法中都使用它。
- en: 'Here’s an encapsulation *starter* rule of thumb (all standard disclaimers about
    rules of thumb are in effect): mark your instance variables ***private*** and
    provide ***public*** getters and setters for access control. When you have more
    design and coding savvy in Java, you will probably do things a little differently,
    but for now, this approach will keep you safe.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个封装的*入门*法则（所有关于法则的免责声明都有效）：将你的实例变量标记为***private***，并提供***public***的getters和setters来进行访问控制。当你在Java中拥有更多的设计和编码技巧时，你可能会以稍有不同的方式进行，但现在，这种方法会保护你的安全。
- en: '**“Sadly, Bill forgot to encapsulate his Cat class and ended up with a flat
    cat.”**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**“不幸的是，比尔忘记封装他的Cat类，结果得到了一只扁平的猫。”**'
- en: (overheard at the water cooler)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （在饮水机旁听到）
- en: Java Exposed
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java暴露
- en: '![image](Images/f0081-01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0081-01.png)'
- en: '**This week’s interview: An Object gets candid about encapsulation.**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**本周的采访：一个对象公开谈论封装。**'
- en: '**HeadFirst:** What’s the big deal about encapsulation?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 封装有什么了不起的地方？'
- en: '**Object:** OK, you know that dream where you’re giving a talk to 500 people
    when you suddenly realize you’re *naked*?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 好的，你知道那个梦境吗，你在给500人讲话，突然意识到你*赤裸*了？'
- en: '**HeadFirst:** Yeah, we’ve had that one. It’s right up there with the one about
    the Pilates machine and...no, we won’t go there. OK, so you feel naked. But other
    than being a little exposed, is there any danger?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 是的，我们听说过那个。它和那个关于普拉提机的故事差不多……不，我们不谈这个。好了，所以你感觉很裸露。但除了有点暴露外，还有什么危险吗？'
- en: '**Object:** Is there any danger? Is there any *danger*? [starts laughing] Hey,
    did all you other instances hear that, *“Is there any danger?”* he asks? [falls
    on the floor laughing]'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 有危险吗？有*危险*吗？[开始笑] 嘿，你们其他实例都听到了吗，“有危险吗？”他问？[笑倒在地上]'
- en: '**HeadFirst:** What’s funny about that? Seems like a reasonable question.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 这有什么好笑的？似乎是个合理的问题。'
- en: '**Object:** OK, I’ll explain it. It’s [bursts out laughing again, uncontrollably]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 好的，我来解释一下。它是[再次爆笑，无法控制]'
- en: '**HeadFirst:** Can I get you anything? Water?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 我能给你什么吗？水？'
- en: '**Object:** Whew! Oh boy. No I’m fine, really. I’ll be serious. Deep breath.
    OK, go on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 哎呀！哦天啊。不用了，真的。我会认真的。深呼吸。好了，继续吧。'
- en: '**HeadFirst:** So what does encapsulation protect you from?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 那么封装能保护你免受什么？'
- en: '**Object:** Encapsulation puts a force-field around my instance variables,
    so nobody can set them to, let’s say, something *inappropriate*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 封装在我的实例变量周围放了一个力场，所以没有人可以将它们设置为，比如说，不*合适*的东西。'
- en: '**HeadFirst:** Can you give me an example?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 能举个例子吗？'
- en: '**Object:** Happy to. Most instance variable values are coded with certain
    assumptions about their boundaries. Like, think of all the things that would break
    if negative numbers were allowed. Number of bathrooms in an office. Velocity of
    an airplane. Birthdays. Barbell weight. Phone numbers. Microwave oven power.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 很高兴为你解释。大多数实例变量的值都编码有关它们边界的某些假设。比如，想想如果允许负数会破坏什么。办公室的浴室数量。飞机的速度。生日。杠铃的重量。电话号码。微波炉功率。'
- en: '**HeadFirst:** I see what you mean. So how does encapsulation let you set boundaries?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 我明白你的意思了。那么封装如何让你设定边界？'
- en: '**Object:** By forcing other code to go through setter methods. That way, the
    setter method can validate the parameter and decide if it’s doable. Maybe the
    method will reject it and do nothing, or maybe it’ll throw an Exception (like
    if it’s a null Social Security number for a credit card application), or maybe
    the method will round the parameter sent in to the nearest acceptable value. The
    point is, you can do whatever you want in the setter method, whereas you can’t
    do *anything* if your instance variables are public.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** 强制其他代码通过setter方法。这样，setter方法可以验证参数并决定是否可行。也许方法会拒绝它并什么也不做，或者可能会抛出异常（比如如果是信用卡申请中的空社会安全号码），或者方法可能会将发送的参数四舍五入到最接受的值。关键在于，在setter方法中可以做任何你想做的事情，而如果你的实例变量是公共的，你什么也做不了。'
- en: '**HeadFirst:** But sometimes I see setter methods that simply set the value
    without checking anything. If you have an instance variable that doesn’t have
    a boundary, doesn’t that setter method create unnecessary overhead? A performance
    hit?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 但有时我看到setter方法只是简单地设置值而没有检查任何东西。如果你有一个实例变量没有边界，那么这个setter方法会不会造成不必要的开销？会有性能损失吗？'
- en: '**Object:** The point to setters (and getters, too) is that ***you can change
    your mind later, without breaking anybody else’s code!*** Imagine if half the
    people in your company used your class with public instance variables, and one
    day you suddenly realized, “Oops—there’s something I didn’t plan for with that
    value, I’m going to have to switch to a setter method.” You break everyone’s code.
    The cool thing about encapsulation is that *you get to change your mind.* And
    nobody gets hurt. The performance gain from using variables directly is so miniscule
    and would rarely—*if ever*—be worth it.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object:** setters（以及getters）的关键在于***你随时可以改变主意，而不会破坏其他人的代码！*** 想象一下，如果你公司里一半的人都在使用你的类和公共实例变量，突然有一天你突然意识到，“哎呀——对这个值我没考虑到的地方，我得改成setter方法了。”
    你会破坏所有人的代码。封装的酷之处在于*你可以改变主意*。没人会受伤。直接使用变量的性能收益微乎其微，几乎——*或者说从未*——值得。'
- en: Encapsulating the GoodDog class
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装GoodDog类
- en: '![image](Images/f0082-01.png)![image](Images/f0082-02.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0082-01.png)![image](Images/f0082-02.png)'
- en: How do objects in an array behave?
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组中的对象如何表现？
- en: Just like any other object. The only difference is how you *get* to them. In
    other words, how you get the remote control. Let’s try calling methods on Dog
    objects in an array.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他对象一样。唯一的区别在于*获得*它们的方式。换句话说，如何获得遥控器。让我们尝试在数组中调用Dog对象的方法。
- en: '![Images](Images/1circlea.png) Declare and create a Dog array to hold seven
    Dog references.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlea.png) 声明并创建一个Dog数组以保存七个Dog引用。'
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](Images/f0083-01.png)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0083-01.png)'
- en: '* * *'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '![Images](Images/1circleb.png) Create two new Dog objects, and assign them
    to the first two array elements.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circleb.png) 创建两个新的Dog对象，并将它们分配给数组的前两个元素。'
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Images](Images/1circlec.png) Call methods on the two Dog objects.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlec.png) 在两个Dog对象上调用方法。'
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![image](Images/f0083-02.png)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0083-02.png)'
- en: Declaring and initializing instance variables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化实例变量
- en: 'You already know that a variable declaration needs at least a name and a type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道变量声明至少需要一个名称和类型：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And you know that you can initialize (assign a value to) the variable at the
    same time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以在同一时间初始化（赋值给）变量：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But when you don’t initialize an instance variable, what happens when you call
    a getter method? In other words, what is the *value* of an instance variable *before*
    you initialize it?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你不初始化实例变量时，调用getter方法会发生什么？换句话说，在初始化之前实例变量的*值*是多少？
- en: '![image](Images/f0084-01.png)![image](Images/f0084-02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0084-01.png)![image](Images/f0084-02.png)'
- en: You don’t have to initialize instance variables, because they always have a
    default value. Number primitives (including char) get 0, booleans get false, and
    object reference variables get null.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必初始化实例变量，因为它们总是有一个默认值。数字类型的基本类型（包括char）得到0，布尔类型得到false，对象引用变量得到null。
- en: (Remember, null just means a remote control that isn’t controlling / programmed
    to anything. A reference, but no actual object.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: （记住，null只是意味着一个没有控制/未编程到任何东西的遥控器。一个引用，但没有实际对象。）
- en: The difference between instance and local variables
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例变量与局部变量的区别
- en: '![Images](Images/1circlea.png) **Instance** variables are declared inside a
    class but not within a method.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlea.png) **实例**变量声明在类内部但不在方法内部。'
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Images](Images/1circleb.png) **Local** variables are declared within a method.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circleb.png) **局部**变量在方法内声明。'
- en: '![image](Images/f0085-01.png)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0085-01.png)'
- en: '![Images](Images/1circlec.png) **Local** variables MUST be initialized before
    use!'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlec.png) **局部**变量必须在使用之前初始化！'
- en: '![image](Images/f0085-02.png)![image](Images/f0085-03.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0085-02.png)![image](Images/f0085-03.png)'
- en: '**Local variables do NOT get a default value! The compiler complains if you
    try to use a local variable before the variable is initialized.**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量不会有默认值！如果在变量初始化之前尝试使用局部变量，编译器会报错。**'
- en: Comparing variables (primitives or references)
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较变量（基本类型或引用类型）
- en: 'Sometimes you want to know if two *primitives* are the same; for example, you
    might want to check an int result with some expected integer value. That’s easy
    enough: just use the == operator. Sometimes you want to know if two reference
    variables refer to a single object on the heap; for example, is this Dog object
    exactly the same Dog object I started with? Easy as well: just use the == operator.
    But sometimes you want to know if two *objects* are equal. And for that, you need
    the .equals() method.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想知道两个*基本类型*是否相同；例如，你可能想检查一个int结果与某个预期的整数值是否相等。这很简单：只需使用 == 运算符。有时候你想知道两个引用变量是否引用堆上的同一个对象；例如，这个Dog对象是否确实是我最初创建的那个Dog对象？这也很简单：只需使用
    == 运算符。但有时候你想知道两个*对象*是否相等。为此，你需要使用 .equals() 方法。
- en: The idea of equality for objects depends on the type of object. For example,
    if two different String objects have the same characters (say, “my name”), they
    are meaningfully equivalent, regardless of whether they are two distinct objects
    on the heap. But what about a Dog? Do you want to treat two Dogs as being equal
    if they happen to have the same size and weight? Probably not. So whether two
    different objects should be treated as equal depends on what makes sense for that
    particular object type. We’ll explore the notion of object equality again in later
    chapters, but for now, we need to understand that the == operator is used *only*
    to compare the bits in two variables. *What* those bits represent doesn’t matter.
    The bits are either the same, or they’re not.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的相等概念取决于对象的类型。例如，如果两个不同的String对象具有相同的字符（比如，“my name”），它们在语义上是等价的，不管它们是否是堆上的两个不同对象。但是对于狗呢？如果两只狗的大小和体重相同，你是否希望将它们视为相等？可能不。因此，两个不同对象是否应被视为相等取决于该特定对象类型的逻辑。我们将在后面的章节中再次探讨对象的相等概念，但现在我们需要明白，==
    运算符仅用于比较两个变量的比特位。无论这些比特位代表什么，它们要么相同，要么不同。
- en: '**To compare two primitives, use the == operator**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**用 == 运算符来比较两个原始类型**'
- en: The == operator can be used to compare two variables of any kind, and it simply
    compares the bits.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: == 运算符可以用来比较任何类型的两个变量，它简单地比较比特位。
- en: if (a == b) {...} looks at the bits in a and b and returns true if the bit pattern
    is the same (although all the extra zeros on the left end don’t matter).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: if (a == b) {...} 检查 a 和 b 的比特位，并在比特模式相同时返回 true（尽管左端所有额外的零无关紧要）。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![image](Images/f0086-01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0086-01.png)'
- en: '**Use == to compare two primitives or to see if two references refer to the
    same object.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**用 == 来比较两个原始类型或者查看两个引用是否指向同一个对象。**'
- en: '**Use the equals() method to see if two different objects are equal.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**用 equals() 方法来检查两个不同的对象是否相等。**'
- en: '**(E.g., two different String objects that both contain the characters “Fred”)**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**（例如，两个不同的String对象，它们都包含字符“Fred”）**'
- en: '**To see if two references are the same (which means they refer to the same
    object on the heap) use the == operator**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**用 == 运算符来查看两个引用是否相同（这意味着它们在堆上引用同一个对象）**'
- en: Remember, the == operator cares only about the pattern of bits in the variable.
    The rules are the same whether the variable is a reference or primitive. So the
    == operator returns true if two reference variables refer to the same object!
    In that case, we don’t know what the bit pattern is (because it’s dependent on
    the JVM and hidden from us), but we *do* know that whatever it looks like, *it
    will be the same for two references to a single object*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，== 运算符只关心变量中的比特模式。无论变量是引用还是原始类型，规则都是一样的。因此，如果两个引用变量指向同一个对象，== 运算符返回 true！在这种情况下，我们不知道比特模式是什么（因为它依赖于JVM并对我们隐藏），但我们知道，无论它看起来如何，对于指向单个对象的两个引用，它将是相同的。
- en: '![image](Images/f0086-02.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0086-02.png)'
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![image](Images/f0087-01.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0087-01.png)'
- en: Exercise
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/common-03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-03.png)'
- en: BE the Compiler
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为编译器
- en: '![image](Images/common-05.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-05.png)'
- en: '**Each of the Java files on this page represents a complete source file. Your
    job is to play compiler and determine whether each of these files will compile.
    If they won’t compile, how would you fix them, and if they do compile, what would
    be their output?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**此页面上的每个Java文件都代表一个完整的源文件。你的任务是扮演编译器，确定这些文件是否会编译。如果它们不能编译，你将如何修复它们？如果它们可以编译，它们的输出将会是什么？**'
- en: '**A**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**'
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**B**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**'
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler”](#be_the_compiler_left_parenthesisfro-1000).**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr1.png) **答案在[“BE the Compiler”](#be_the_compiler_left_parenthesisfro-1000)中。**'
- en: A bunch of Java components, in full costume, are playing a party game, “Who
    am I?” They give you a clue, and you try to guess who they are, based on what
    they say. Assume they always tell the truth about themselves. If they happen to
    say something that could be true for more than one attendee, then write down all
    for whom that sentence applies. Fill in the blanks next to the sentence with the
    names of one or more attendees.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一群穿着全套服装的Java组件正在玩一个派对游戏，“我是谁？” 他们给你一个提示，你根据他们说的内容来猜他们是谁。假设他们总是对自己说实话。如果他们碰巧说了一些对多个参与者都可能是真实的话，那么请写下所有这些话对应的参与者名字。在每个句子旁边填上一个或多个参与者的名字。
- en: Who Am I?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁是我？
- en: '![image](Images/f0045-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0045-01.png)'
- en: '**Tonight’s attendees:**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**今晚的参与者：**'
- en: '**instance variable, argument, return, getter, setter, encapsulation, public,
    private, pass by value, method**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例变量，参数，返回，getter，setter，封装，公共，私有，按值传递，方法**'
- en: '| **A class can have any number of these.** | __________________________________
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **一个类可以有任意数量的这些。** | __________________________________ |'
- en: '| **A method can have only one of these.** | __________________________________
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **一个方法只能有一个这样的。** | __________________________________ |'
- en: '| **This can be implicitly promoted.** | __________________________________
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **这可以被隐式提升。** | __________________________________ |'
- en: '| **I prefer my instance variables private.** | __________________________________
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **我更喜欢我的实例变量是私有的。** | __________________________________ |'
- en: '| **It really means “make a copy.”** | __________________________________ |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **它实际上意味着“制作一个副本”。** | __________________________________ |'
- en: '| **Only setters should update these.** | __________________________________
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **只有setter应该更新这些。** | __________________________________ |'
- en: '| **A method can have many of these.** | __________________________________
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **一个方法可以有很多这样的。** | __________________________________ |'
- en: '| **I return something by definition.** | __________________________________
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **根据定义，我会返回一些东西。** | __________________________________ |'
- en: '| **I shouldn’t be used with instance variables.** | __________________________________
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **不应该与实例变量一起使用。** | __________________________________ |'
- en: '| **I can have many arguments.** | __________________________________ |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **我可以有很多参数。** | __________________________________ |'
- en: '| **By definition, I take one argument.** | __________________________________
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **根据定义，我接受一个参数。** | __________________________________ |'
- en: '| **These help create encapsulation.** | __________________________________
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **这些有助于创建封装。** | __________________________________ |'
- en: '| **I always fly solo.** | __________________________________ |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **我总是独自飞行。** | __________________________________ |'
- en: '![Images](Images/arr1.png) **Answers in [“Who Am I?”](#who_am_iquestion_mark_left_parenthes-id0).**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在[“我是谁？”](#who_am_iquestion_mark_left_parenthes-id0)。**'
- en: Mixed Messages
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合信息
- en: '![image](Images/common-04.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common-04.png)'
- en: A short Java program is listed to your right. Two blocks of the program are
    missing. Your challenge is to **match the candidate blocks of code** (below) **with
    the output** that you’d see if the blocks were inserted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧列出了一个简短的Java程序。程序中有两个代码块缺失。你的挑战是**将候选代码块**（下方）**与插入后看到的输出**进行匹配。
- en: Not all the lines of output will be used, and some of the lines of output might
    be used more than once. Draw lines connecting the candidate blocks of code with
    their matching command-line output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有输出行都会被使用，有些输出行可能会被多次使用。画线连接候选代码块与它们匹配的命令行输出。
- en: '![image](Images/f0090-01.png)![image](Images/f0090-02.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0090-01.png)![图片](Images/f0090-02.png)'
- en: '![Images](Images/arr1.png) **Answers in [“Mixed Messages”](#mixed_messages_left_parenthesisfrom_page).**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在[“混合信息”](#mixed_messages_left_parenthesisfrom_page)。**'
- en: Pool Puzzle
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/common-04.png)![image](Images/common-06.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common-04.png)![图片](Images/common-06.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You may **not** use the same snippet more than once,
    and you won’t need to use all the snippets. Your ***goal*** is to make a class
    that will compile and run and produce the output listed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***工作***是从代码池中提取代码片段并将它们放入代码中的空白行中。你不能多次使用相同的代码片段，也不需要使用所有的代码片段。你的***目标***是创建一个能够编译、运行并产生列出的输出的类。
- en: '![Images](Images/arr1.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_91).**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在[“池谜题”](#pool_puzzle_left_parenthesisfrom_page_91)。**'
- en: '**Output**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![image](Images/f0091-01.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0091-01.png)'
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note: Each snippet from the pool can be used only once!**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个代码片段只能使用一次！**'
- en: '![image](Images/f0091-02.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0091-02.png)'
- en: '**Fast Times in Stim-City**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**刺激城市的快速时光**'
- en: '![image](Images/common-04.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common-04.png)'
- en: Five-Minute Mystery
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 五分钟的谜题
- en: When Buchanan roughly grabbed Jai’s arm from behind, Jai froze. Jai knew that
    Buchanan was as stupid as he was ugly and he didn’t want to spook the big guy.
    Buchanan ordered Jai into his boss’s office, but Jai’d done nothing wrong (lately),
    so he figured a little chat with Buchanan’s boss Leveler couldn’t be too bad.
    He’d been moving lots of neural-stimmers in the west side lately, and he figured
    Leveler would be pleased. Black market stimmers weren’t the best money pump around,
    but they were pretty harmless. Most of the stim-junkies he’d seen tapped out after
    a while and got back to life, maybe just a little less focused than before.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Buchanan 粗鲁地从后面抓住 Jai 的胳膊时，Jai 呆住了。Jai 知道 Buchanan 既愚蠢又丑陋，他不想让这个大个子受惊。Buchanan
    命令 Jai 进入他老板 Leveler 的办公室，但 Jai 最近没有做错什么，所以他觉得与 Leveler 聊聊应该不会太坏。他最近在西区卖了很多神经兴奋剂，他觉得
    Leveler 会很高兴。黑市的兴奋剂不是最好的赚钱方式，但它们相当无害。他见过的大多数兴奋剂君子过一段时间就戒掉了，回归正常生活，也许只是比以前少了点专注力。
- en: Leveler’s “office” was a skungy-looking skimmer, but once Buchanan shoved him
    in, Jai could see that it’d been modified to provide all the extra speed and armor
    that a local boss like Leveler could hope for. “Jai my boy,” hissed Leveler, “pleasure
    to see you again.” “Likewise I’m sure...,” said Jai, sensing the malice behind
    Leveler’s greeting, “We should be square Leveler, have I missed something?” “Ha!
    You’re making it look pretty good, Jai. Your volume is up, but I’ve been experiencing,
    shall we say, a little ‘breach’ lately,” said Leveler.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Leveler 的“办公室”看起来像是一个陈旧的滑板车，但是当 Buchanan 把他推进去后，Jai 发现它被改装过，提供了所有地方老大 Leveler
    可能期望的额外速度和装甲。“Jai，我的孩子，” Leveler 嘶嘶地说，“很高兴再次见到你。” “彼此彼此……” Jai 感受到 Leveler 问候背后的恶意，说道，“我们应该已经不欠不欠了，Leveler，我错过了什么吗？”
    “哈！你看起来很不错，Jai。你的销量不错，但我最近经历了，咱们说，一点‘漏洞’，” Leveler 说道。
- en: Jai winced involuntarily; he’d been a top drawer jack-hacker in his day. Anytime
    someone figured out how to break a street-jack’s security, unwanted attention
    turned toward Jai. “No way it’s me man,” said Jai, “not worth the downside. I’m
    retired from hacking, I just move my stuff and mind my own business.” “Yeah, yeah,”
    laughed Leveler, “I’m sure you’re clean on this one, but I’ll be losing big margins
    until this new jack-hacker is shut out!” “Well, best of luck, Leveler. Maybe you
    could just drop me here and I’ll go move a few more ‘units’ for you before I wrap
    up today,” said Jai.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Jai 不由自主地皱了皱眉头；他曾经是一位顶级的街头黑客。每当有人找出如何突破街头插孔的安全措施时，不良注意就会转向 Jai。“绝对不可能是我，老兄，”
    Jai 说道，“不值得冒险。我已经退出黑客界，我只是转移我的东西，管好自己的事。” “是啊，是啊，” Leveler 笑了笑，“我相信你这一次没事，但在这件事上我会损失很多，直到这个新的街头黑客被拒之门外！”
    “好吧，祝你好运，Leveler。也许你可以就把我丢在这儿，我再为你多运输几‘单位’，然后今天就收工了。” Jai 说道。
- en: '![image](Images/f0092-01.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0092-01.png)'
- en: “I’m afraid it’s not that easy, Jai. Buchanan here tells me that word is you’re
    current on Java NE 37.3.2,” insinuated Leveler. “Neural edition? Sure, I play
    around a bit, so what?” Jai responded, feeling a little queasy. “Neural edition’s
    how I let the stim-junkies know where the next drop will be,” explained Leveler.
    “Trouble is, some stim-junkie’s stayed straight long enough to figure out how
    to hack into my Warehousing database.” “I need a quick thinker like yourself,
    Jai, to take a look at my StimDrop Java NE class; methods, instance variables,
    the whole enchilada, and figure out how they’re getting in. It should...,” “HEY!”
    exclaimed Buchanan, “I don’t want no scum hacker like Jai nosin’ around my code!”
    “Easy big guy,” Jai saw his chance, “I’m sure you did a top rate job with your
    access modi...” “Don’t tell me, bit twiddler!” shouted Buchanan, “I left all of
    those junkie-level methods public so they could access the drop site data, but
    I marked all the critical WareHousing methods private. Nobody on the outside can
    access those methods, buddy, nobody!”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: “对不起，Jai，这并不那么容易。” Leveler 暗示道。“Buchanan 告诉我，你对 Java NE 37.3.2 相当了解。” “神经版？没错，我有点玩过。”
    Jai 回答道，感到有点不安。“神经版是我让刺激物瘾君子们知道下一个投放点的方式。” Leveler 解释道。“问题是，有些刺激物瘾君子竟然保持清醒长到足够搞懂如何入侵我的仓储数据库。”
    “我需要像你这样思维敏捷的人，Jai，来看看我的 StimDrop Java NE 类；方法、实例变量，整个大餐，看看他们是如何进来的。应该……” “喂！”
    Buchanan 叫道，“我可不希望像 Jai 这样的垃圾黑客到我的代码里窥探！” “冷静点大哥，” Jai 看到机会，“我相信你对你的访问权限做得很好……”
    “别告诉我，比特位狗！” Buchanan 咆哮道，“我把那些君子级的方法全部设为公开，以便他们能访问投放点数据，但所有关键的仓储方法我都标记为私有的。外面没人能访问那些方法，伙计，没人！”
- en: “I think I can spot your leak, Leveler. What say we drop Buchanan here off at
    the corner and take a cruise around the block?” suggested Jai. Buchanan clenched
    his fists and started toward Jai, but Leveler’s stunner was already on Buchanan’s
    neck, “Let it go, Buchanan,” sneered Leveler, “Keep your hands where I can see
    them and step outside. I think Jai and I have some plans to make.”
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: “我想我能找到你的漏洞，Leveler。我们把Buchanan放在拐角处，然后绕街区巡游怎么样？” Jai建议道。Buchanan握紧拳头朝Jai走去，但Leveler的麻痹器已经在Buchanan的脖子上，“放开吧，Buchanan，”Leveler嘲笑道，“把手放在我能看到的地方，走到外面。我想Jai和我有一些计划要制定。”
- en: '***What did Jai suspect?***'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '***Jai怀疑什么？***'
- en: '***Will he get out of Leveler’s skimmer with all his bones intact?***'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '***他会完整地从Leveler的滑板车中走出来吗？***'
- en: '![Images](Images/arr1.png) **Answers in [“Five-Minute Mystery”](#five_minute_mystery_left_parenthesisfrom).**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **[“五分钟谜题”](#five_minute_mystery_left_parenthesisfrom)中的答案。**'
- en: Exercise Solutions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: '![image](Images/common-03.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common-03.png)'
- en: Sharpen your pencil
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磨砺你的铅笔
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00005))
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“磨砺你的铅笔”](#sharpen_your_pencil-id00005)）
- en: '![image](Images/f0093-01.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0093-01.png)'
- en: BE the Compiler
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为编译器
- en: (from [“BE the Compiler”](#be_the_compiler-id000200))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“成为编译器”](#be_the_compiler-id000200)）
- en: 'Class ‘XCopy’ compiles and runs as it stands! The output is: ‘42 84’. Remember,
    Java is pass by value, (which means pass by copy), and the variable ‘orig’ is
    not changed by the go( ) method.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ‘XCopy’类编译并运行正常！输出结果为：‘42 84’。记住，Java是按值传递的（也就是按拷贝传递），变量‘orig’不会被go( )方法改变。
- en: '![image](Images/f0093-02.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0093-02.png)'
- en: Who Am I?
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: (from [“Who Am I?”](#who_am_i-id0100002))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“我是谁？”](#who_am_i-id0100002)）
- en: '| **A class can have any number of these.** | **instance variables, getter,
    setter, method** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **一个类可以有任意数量的这些。** | **实例变量，getter，setter，方法** |'
- en: '| **A method can have only one of these.** | **return** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **一个方法只能有一个这个。** | **返回** |'
- en: '| **This can be implicitly promoted.** | **return, argument** |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **这个可以被隐式提升。** | **返回，参数** |'
- en: '| **I prefer my instance variables private.** | **encapsulation** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **我更喜欢我的实例变量是私有的。** | **封装** |'
- en: '| **It really means “make a copy.”** | **pass by value** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **它实际上意味着“制作一份拷贝”。** | **按值传递** |'
- en: '| **Only setters should update these.** | **instance variables** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **只有setter应该更新这些。** | **实例变量** |'
- en: '| **A method can have many of these.** | **argument** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **一个方法可以有很多这些。** | **参数** |'
- en: '| **I return something by definition.** | **getter** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **根据定义，我会返回一些东西。** | **getter** |'
- en: '| **I shouldn’t be used with instance variables** | **public** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **不应该与实例变量一起使用。** | **public** |'
- en: '| **I can have many arguments.** | **method** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **我可以有很多参数。** | **方法** |'
- en: '| **By definition, I take one argument.** | **setter** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **根据定义，我接受一个参数。** | **setter** |'
- en: '| **These help create encapsulation.** | **getter, setter, public, private**
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **这些有助于创建封装。** | **getter, setter, public, private** |'
- en: '| **I always fly solo.** | **return** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **我总是独自飞行。** | **返回** |'
- en: Puzzle Solutions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谜题解答
- en: Pool Puzzle
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游泳池谜题
- en: (from [“Pool Puzzle”](#pool_puzzle-id00002))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“游泳池谜题”](#pool_puzzle-id00002)）
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Output**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![image](Images/f0094-01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0094-01.png)'
- en: Five-Minute Mystery
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 五分钟谜题
- en: (from [“Five-Minute Mystery”](#five-minute_mystery-id00001))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“五分钟谜题”](#five-minute_mystery-id00001)）
- en: '**What did Jai suspect?**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jai怀疑什么？**'
- en: Jai knew that Buchanan wasn’t the sharpest pencil in the box. When Jai heard
    Buchanan talk about his code, Buchanan never mentioned his instance variables.
    Jai suspected that while Buchanan did in fact handle his methods correctly, he
    failed to mark his instance variables `private.` That slip-up could have easily
    cost Leveler thousands.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Jai知道Buchanan不是最聪明的人。当Jai听到Buchanan谈论他的代码时，Buchanan从未提到他的实例变量。Jai怀疑，虽然Buchanan确实正确处理了他的方法，但他没有将他的实例变量标记为`private`。这个疏忽很容易让Leveler损失成千上万。
- en: Mixed Messages
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合信息
- en: (from [“Mixed Messages”](#mixed_messages-id00002))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[“混合信息”](#mixed_messages-id00002)）
- en: '![image](Images/f0094-02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0094-02.png)'
