- en: 'Chapter 13\. Risky Behavior: Exception Handling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。冒险行为：异常处理
- en: '![image](Images/f0421-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0421-01.png)'
- en: '**Stuff happens. The file isn’t there. The server is down.** No matter how
    good a programmer you are, you can’t control everything. Things can go wrong.
    *Very* wrong. When you write a risky method, you need code to handle the bad things
    that might happen. But how do you *know* when a method is risky? And where do
    you put the code to *handle* the ***exceptional*** situation? So far in this book,
    we haven’t *really* taken any risks. We’ve certainly had things go wrong at runtime,
    but the problems were mostly flaws in our own code. Bugs. And those we should
    fix at development time. No, the problem-handling code we’re talking about here
    is for code that you *can’t* guarantee will work at runtime. Code that expects
    the file to be in the right directory, the server to be running, or the Thread
    to stay asleep. And we have to do this *now*. Because in *this* chapter, we’re
    going to build something that uses the risky JavaSound API. We’re going to build
    a MIDI Music Player.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**事情总会发生。文件不在那里。服务器挂了。** 不管你是多么优秀的程序员，你也不能控制一切。事情可能会出错。*非常*出错。当你编写一个风险方法时，你需要代码来处理可能发生的坏事。但你如何*知道*一个方法是有风险的？你应该把代码放在哪里来*处理*这个***特殊***情况？到目前为止，在这本书中，我们并没有*真正*冒过任何风险。在运行时，我们当然会遇到问题，但问题大多是我们自己代码的缺陷。漏洞。我们应该在开发时修复这些漏洞。不，我们这里讨论的问题处理代码是针对那些你不能保证在运行时能正常工作的代码。那些期望文件在正确的目录中，服务器正在运行或线程保持休眠的代码。我们现在必须要做这件事。因为在*这*章，我们将构建一个使用有风险的JavaSound
    API的东西。我们将构建一个MIDI音乐播放器。'
- en: Let’s make a Music Machine
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们制造一个音乐机器
- en: Over the next three chapters, we’ll build a few different sound applications,
    including a BeatBox Drum Machine. In fact, before the book is done, we’ll have
    a multiplayer version so you can send your drum loops to another player, kind
    of like sharing over social media. You’re going to write the whole thing, although
    you can choose to use Ready-Bake Code for the GUI parts. OK, so not every IT department
    is looking for a new BeatBox server, but we’re doing this to learn more about
    Java. Building a BeatBox is just a way to have fun *while* we’re learning Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将构建几个不同的音频应用程序，包括一个BeatBox鼓机。事实上，在这本书完成之前，我们将有一个多人版本，这样你就可以将你的鼓循环发送给另一个玩家，有点像通过社交媒体分享。你将编写整个程序，尽管你可以选择使用GUI部分的现成代码。好吧，并不是每个IT部门都在寻找一个新的BeatBox服务器，但我们这样做是为了更多地了解Java。构建BeatBox只是在我们学习Java的同时享受乐趣的一种方式。
- en: 'The finished BeatBox looks something like this:'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成的BeatBox看起来像这样：
- en: '![image](Images/f0422-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0422-01.png)'
- en: Notice the check marks in the boxes for each of the 16 “beats.” For example,
    on beat 1 (of 16) the Bass drum and the Maracas will play, on beat 2 nothing,
    and on beat 3 the Maracas and Closed Hi-Hat...you get the idea. When you hit Start,
    it plays your pattern in a loop until you hit Stop. At any time, you can “capture”
    one of your own patterns by sending it to the BeatBox server (which means any
    other players can listen to it). You can also load any of the incoming patterns
    by clicking on the message that goes with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个16拍的框中的勾选标记。例如，在第1拍（16拍中的第1拍）上，Bass鼓和Maracas会播放，在第2拍上什么都没有，在第3拍上Maracas和Closed
    Hi-Hat会...你明白了。当你点击开始时，它会循环播放你的模式，直到你点击停止。随时，你可以通过发送到BeatBox服务器来“捕捉”你自己的任何模式（这意味着其他玩家可以听到它）。你还可以通过点击与之相关的消息来加载任何传入的模式。
- en: We’ll start with the basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将从基础知识开始。
- en: Obviously we’ve got a few things to learn before the whole program is finished,
    including how to build a GUI, how to *connect* to another machine via networking,
    and a little I/O so we can *send* something to the other machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在完成整个程序之前，我们有几件事情要学习，包括如何构建GUI，如何通过网络*连接*到另一台机器，以及一些I/O，这样我们就可以向其他机器*发送*一些东西。
- en: Oh yeah, and the JavaSound API. *That’s* where we’ll start in this chapter.
    For now, you can forget the GUI, forget the networking and the I/O, and focus
    only on getting some MIDI-generated sound to come out of your computer. And don’t
    worry if you don’t know a thing about MIDI or a thing about reading or making
    music. Everything you need to learn is covered here. You can almost smell the
    record deal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哦对了，还有JavaSound API。*这*就是我们在本章将要开始的地方。现在，你可以忘掉GUI，忘掉网络和I/O，只专注于让你的计算机发出一些通过MIDI生成的声音。如果你对MIDI一无所知，或者对阅读或制作音乐一无所知也不必担心。这里包含了你需要学习的一切。你几乎能闻到唱片合约的味道了。
- en: The JavaSound API
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaSound API
- en: 'JavaSound is a collection of classes and interfaces added to Java way back
    in version 1.3\. These aren’t special add-ons; they’re part of the standard Java
    SE class library. JavaSound is split into two parts: MIDI and Sampled. We use
    only MIDI in this book. MIDI stands for Musical Instrument Digital Interface,
    and is a standard protocol for getting different kinds of electronic sound equipment
    to communicate. But for our BeatBox app, you can think of MIDI as *a kind of sheet
    music* that you feed into some device like a high-tech “player piano.” In other
    words, MIDI data doesn’t actually include any *sound*, but it does include the
    *instructions* that a MIDI-reading instrument can play back. Or for another analogy,
    you can think of a MIDI file like an HTML document, and the instrument that renders
    the MIDI file (i.e., *plays* it) is like the web browser.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaSound是添加到Java中的一组类和接口，早在1.3版中就有了。这些不是特殊的附加组件；它们是标准Java SE类库的一部分。JavaSound分为两部分：MIDI和Sampled。我们在本书中只使用MIDI。MIDI代表音乐乐器数字接口，是一种用于使不同类型的电子声音设备进行通信的标准协议。但对于我们的BeatBox应用程序，你可以将MIDI视为*一种乐谱*，你将其输入到某种设备中，如高科技的“自动钢琴”。换句话说，MIDI数据实际上不包括任何*声音*，但它包括MIDI读取乐器可以播放的*指令*。或者用另一个类比，你可以将MIDI文件视为HTML文档，而呈现MIDI文件的乐器（即*播放*它）就像网络浏览器。
- en: MIDI data says *what* to do (play middle C, and here’s how hard to hit it, and
    here’s how long to hold it, etc.), but it doesn’t say anything at all about the
    actual *sound* you hear. MIDI doesn’t know how to make a flute, piano, or Jimi
    Hendrix guitar sound. For the actual sound, we need an instrument (a MIDI device)
    that can read and play a MIDI file. But the device is usually more like an *entire
    band or orchestra* of instruments. And that instrument might be a physical device,
    like a keyboard, or it could even be an instrument built entirely in software,
    living in your computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI数据告诉你*做*什么（演奏中央C，以及如何用力击打它，以及保持多久等），但它根本不涉及你听到的实际*声音*。 MIDI不知道如何制作长笛、钢琴或吉米·亨德里克斯吉他的声音。对于实际的声音，我们需要一个能够读取和播放MIDI文件的乐器（MIDI设备）。但该设备通常更像是一整个乐队或交响乐团的乐器。而且该乐器可能是一个物理设备，比如键盘，或者甚至是完全建立在计算机中的软件乐器。
- en: For our BeatBox, we use only the built-in, software-only instrument that you
    get with Java. It’s called a *synthesizer* (some folks refer to it as a *software
    synth*) because it *creates* sound. Sound that you *hear*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的BeatBox，我们只使用Java提供的内置软件乐器。它被称为*合成器*（有些人将其称为*软件合成器*），因为它*创建*声音。你*听到*的声音。
- en: '![image](Images/f0423-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0423-01.png)'
- en: First we need a Sequencer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先我们需要一个Sequencer
- en: Before we can get any sound to play, we need a Sequencer object. The sequencer
    is the object that takes all the MIDI data and sends it to the right instruments.
    It’s the thing that *plays* the music. A sequencer can do a lot of different things,
    but in this book, we’re using it strictly as a playback device. It’s like a device
    that streams music, but with a few added features. The Sequencer class is in the
    javax.sound.midi package. So let’s start by making sure we can make (or get) a
    Sequencer object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能播放任何声音之前，我们需要一个Sequencer对象。Sequencer是将所有MIDI数据发送到正确乐器的对象。它是*播放*音乐的东西。Sequencer可以做很多不同的事情，但在本书中，我们严格将其用作播放设备。它就像一个流媒体音乐的设备，但带有一些附加功能。Sequencer类位于javax.sound.midi包中。因此，让我们首先确保我们可以创建（或获取）一个Sequencer对象。
- en: '![image](Images/f0424-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0424-01.png)'
- en: Something’s wrong!
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出了点问题！
- en: '![image](Images/f0424-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0424-02.png)'
- en: What happens when a method you want to call (probably in a class you didn’t
    write) is risky?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你想调用的方法（可能在你没有编写的类中）存在风险时会发生什么？
- en: '![Images](Images/1.png) **Let’s say you want to call a method in a class that
    you didn’t write.**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **假设你想调用一个你没有编写的类中的方法。**'
- en: '![image](Images/f0425-01.png)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0425-01.png)'
- en: '![Images](Images/2.png) **That method does something risky, something that
    might not work at runtime.**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **该方法执行一些有风险的操作，可能在运行时不起作用。**'
- en: '![image](Images/f0425-02.png)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0425-02.png)'
- en: '![Images](Images/3.png) **You need to *know* that the method you’re calling
    is risky.**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **你需要*知道*你调用的方法是有风险的。**'
- en: '![image](Images/f0425-03.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0425-03.png)'
- en: '![Images](Images/4.png) **You then write code that can handle the failure if
    it *does* happen. You need to be prepared, just in case.**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) **然后你编写代码来处理如果*发生*失败的情况。你需要做好准备，以防万一。**'
- en: '![image](Images/f0425-04.png)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0425-04.png)'
- en: Methods in Java use *exceptions* to tell the calling code, “Something Bad Happened.
    I failed.”
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的方法使用*异常*告诉调用代码，“发生了一些糟糕的事情。我失败了。”
- en: Java’s exception-handling mechanism is a clean, well-lighted way to handle “exceptional
    situations” that pop up at runtime; it lets you put all your error-handling code
    in one easy-to-read place. It’s based on the method you’re calling *telling you*
    it’s risky (i.e., that the method *might* generate an exception), so that you
    can write code to deal with that possibility. If you *know* you might get an exception
    when you call a particular method, you can be *prepared* for—possibly even *recover*
    from—the problem that caused the exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java的异常处理机制是一种清晰明了的处理运行时“异常情况”的方式；它让你把所有的错误处理代码放在一个易于阅读的地方。它基于你调用的方法*告诉你*它有风险（即该方法*可能*生成异常），这样你就可以编写代码来处理这种可能性。如果你*知道*在调用特定方法时可能会抛出异常，你就可以为引起异常的问题做好准备，甚至*恢复*。
- en: So, how does a method tell you it might throw an exception? You find a `**throws**`
    clause in the risky method’s declaration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个方法如何告诉你它可能抛出异常呢？你会在风险方法声明中找到一个`**throws**`子句。
- en: '**The** `**getSequencer ()**` **method takes a risk. It can fail at runtime.
    So it must “declare” the risk *you* take when you call it.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**`getSequencer()`**方法有风险。它可能在运行时失败。因此，当你调用它时，必须“声明”你承担的风险。'
- en: '![image](Images/f0426-01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0426-01.png)'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Risky methods that could fail at runtime declare the exceptions that might
    happen using “throws SomeKindOfException” on their method declaration.**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**在运行时可能失败的风险方法使用“throws SomeKindOfException”在它们的方法声明中声明可能发生的异常。**'
- en: The compiler needs to know that YOU know you’re calling a risky method
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器需要知道你知道自己在调用一个有风险的方法
- en: '![image](Images/f0427-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0427-01.png)'
- en: If you wrap the risky code in something called a **try/catch**, the compiler
    will relax.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个叫做**try/catch**的东西包裹了风险代码，编译器就会放松。
- en: A try/catch block tells the compiler that you *know* an exceptional thing could
    happen in the method you’re calling, and that you’re prepared to handle it. That
    compiler doesn’t care *how* you handle it; it cares only that you say you’re taking
    care of it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个try/catch块告诉编译器，你*知道*在你调用的方法中可能会发生异常，而且你已经准备好处理它。编译器不关心你*如何*处理它；它只关心你说你正在处理它。
- en: '![image](Images/f0428-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0428-01.png)'
- en: An exception is an object... of type Exception
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个异常是一个对象……类型为Exception
- en: This is fortunate, because it would be much harder to remember if exceptions
    were of type Broccoli.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这很幸运，因为如果异常是Broccoli类型的话，记住它将会更困难。
- en: Remember from the polymorphism ([Chapter 7](ch07.xhtml#better_living_in_objectville_inheritance)
    and [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst)) that an
    object of type Exception *can* be an instance of any *subclass* of Exception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从多态性（[第7章](ch07.xhtml#better_living_in_objectville_inheritance) 和 [第8章](ch08.xhtml#serious_polymorphism_interfaces_and_abst)）中记住，Exception类型的对象*可以*是任何Exception的*子类*的实例。
- en: Because an *Exception* is an object, what you *catch* is an object. In the following
    code, the **`catch`** argument is declared as type Exception, and the parameter
    reference variable is *ex*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*Exception*是一个对象，你*捕获*的是一个对象。在以下代码中，**`catch`** 参数声明为Exception类型，参数引用变量是*ex*。
- en: '![image](Images/f0428-03.png)![image](Images/f0428-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0428-03.png)![image](Images/f0428-02.png)'
- en: What you write in a catch block depends on the exception that was thrown. For
    example, if a server is down, you might use the catch block to try another server.
    If the file isn’t there, you might ask the user for help finding it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你在catch块中写什么取决于抛出的异常。例如，如果服务器宕机，你可能会在catch块中尝试另一个服务器。如果文件不存在，你可能会请求用户帮助找到它。
- en: If it’s your code that catches the exception, then whose code throws it?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果是你的代码捕获了异常，那么是谁的代码抛出它呢？
- en: '![image](Images/f0429-01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0429-01.png)'
- en: You’ll spend much more of your Java coding time *handling* exceptions than you’ll
    spend *creating* and *throwing* them yourself. For now, just know that when your
    code *calls* a risky method—a method that declares an exception—it’s the risky
    method that *throws* the exception back to *you*, the caller.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你在编写Java代码时，会花费大量时间*处理*异常，而不是花在*创建*和*抛出*异常上。暂时来说，只需知道当你的代码*调用*一个风险方法时——一个声明异常的方法——就是这个风险方法*抛出*异常给*你*，调用者。
- en: In reality, it might be you who wrote both classes. It really doesn’t matter
    who writes the code...what matters is knowing which method *throws* the exception
    and which method *catches* it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可能是你写了两个类。重要的不是谁写了代码...重要的是知道哪个方法*抛出*异常，哪个方法*捕获*异常。
- en: When somebody writes code that could throw an exception, they must *declare*
    the exception.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人编写可能抛出异常的代码时，他们必须*声明*异常。
- en: '![Images](Images/1.png) **Risky, exception-throwing code:**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/1.png) **危险、抛出异常的代码：**'
- en: '![image](Images/f0429-02.png)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](Images/f0429-02.png)'
- en: '![Images](Images/2.png) **Your code that *calls* the risky method:**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/2.png) **调用危险方法的你的代码：**'
- en: '![image](Images/f0429-03.png)'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](Images/f0429-03.png)'
- en: '**The compiler checks for everything except RuntimeExceptions.**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器会检查所有情况，除了RuntimeExceptions。**'
- en: '![image](Images/f0430-01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0430-01.png)'
- en: '**The compiler guarantees:**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器保证：**'
- en: '![Images](Images/1.png) If you *throw* an exception in your code, you *must*
    declare it using the *throws* keyword in your method declaration.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/1.png) 如果你在代码中*抛出*异常，你必须在方法声明中使用*throws*关键字声明它。'
- en: '![Images](Images/2.png) If you *call* a method that throws an exception (in
    other words, a method that *declares* it throws an exception), you must *acknowledge*
    that you’re aware of the exception possibility. One way to satisfy the compiler
    is to wrap the call in a try/catch. (There’s a second way we’ll look at a little
    later in this chapter.)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图像](Images/2.png) 如果你*调用*一个抛出异常的方法（换句话说，声明会抛出异常的方法），你必须*确认*你意识到了异常的可能性。满足编译器的一种方式是将调用包装在try/catch中。（本章稍后会再看到第二种方式。）'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](Images/arr.png) **你需要解决的问题。**'
- en: Flow control in try/catch blocks
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try/catch块中的流程控制
- en: When you call a risky method, one of two things can happen. The risky method
    either succeeds, and the try block completes, or the risky method throws an exception
    back to your calling method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个危险的方法时，会发生两种情况之一。危险的方法要么成功，try块完成，要么危险的方法抛出异常返回到调用方法。
- en: '**If the try succeeds**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果尝试成功**'
- en: '**(doRiskyThing() does *not* throw an exception)**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**（doRiskyThing()不会抛出异常）**'
- en: '![image](Images/f0432-01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0432-01.png)'
- en: '**If the try fails**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果try失败**'
- en: '**(because doRiskyThing() *does* throw an exception)**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**(因为doRiskyThing()确实会抛出异常)**'
- en: '![image](Images/f0432-02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0432-02.png)'
- en: 'Finally: for the things you want to do no matter what'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终：放置那些无论如何都要执行的代码
- en: '![image](Images/f0433-01.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0433-01.png)'
- en: If you try to cook something, you start by turning on the oven.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试烹饪某物，你首先要打开烤箱。
- en: If the thing you try is a complete **failure, *you have to turn off the oven.***
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试的事情是一个彻底的**失败，*你必须关闭烤箱。***
- en: If the thing you try **succeeds, *you have to turn off the oven.***
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试的事情**成功，*你必须关闭烤箱。***
- en: '***You have to turn off the oven no matter what!***'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***无论如何都必须关闭烤箱！***'
- en: '**A finally block is where you put code that must run *regardless* of an exception.**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**finally块是你放置必须无论异常与否都要运行的代码的地方。**'
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Without finally, you have to put the turnOvenOff() in *both* the try and the
    catch because ***you have to turn off the oven no matter what.*** A finally block
    lets you put all your important cleanup code­ in *one* place instead of duplicating
    it like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有finally，你必须在*try*和*catch*中都放置turnOvenOff()，因为***无论如何都必须关闭烤箱。*** 一个finally块让你把所有重要的清理代码放在*一个*地方，而不是像这样重复：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**If the try block fails (an exception),** flow control immediately moves to
    the catch block. When the catch block completes, the finally block runs. When
    the finally block completes, the rest of the method continues on.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果try块失败（有异常），** 流程控制立即移动到catch块。当catch块完成后，finally块运行。当finally块完成后，方法的其余部分继续执行。'
- en: '**If the try block succeeds (*no* exception),** flow control skips over the
    catch block and moves to the finally block. When the finally block completes,
    the rest of the method continues on.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果try块成功（*没有*异常），** 流程控制跳过catch块，移动到finally块。当finally块完成后，方法的其余部分继续执行。'
- en: '**If the try or catch block has a return statement, finally will still run!**
    Flow jumps to the finally, then back to the return.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果try或catch块有return语句，finally仍然会运行！** 流程跳转到finally，然后返回到return处。'
- en: '![image](Images/pencil.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/pencil.png)'
- en: Flow Control
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](Images/arr.png) **你需要解决的问题。**'
- en: '**Look at the code to the left. What do you think the output of this program
    would be? What do you think it would be if the third line of the program were
    changed to** `String test = "yes";`**? Assume ScaryException extends Exception.**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**看左边的代码。你认为这个程序的输出是什么？如果程序的第三行改为** `String test = "yes";` **会是什么？假设 ScaryException
    扩展自 Exception。**'
- en: '![image](Images/f0434-01.png)![image](Images/f0434-02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0434-01.png)![image](Images/f0434-02.png)'
- en: 'When test = “no”: start try - start risky - end risky - end try - finally -
    end of main'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `test = "no"` 时：开始尝试 - 开始冒险 - 结束冒险 - 结束尝试 - 最后 - 主体结束
- en: 'When test = “yes”: start try - start risky - scary exception - finally - end
    of main'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `test = "yes"` 时：开始尝试 - 开始冒险 - 可怕的异常 - 最后 - 主体结束
- en: Did we mention that a method can throw more than one exception?
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们有没有提到方法可能会抛出多个异常？
- en: A method can throw multiple exceptions if it darn well needs to. But a method’s
    declaration must declare *all* the checked exceptions it can throw (although if
    two or more exceptions have a common superclass, the method can declare just the
    superclass).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法确实需要，它可以抛出多个异常。但方法的声明必须声明*所有*它可能抛出的已检查异常（尽管如果两个或更多异常有一个共同的超类，方法可以只声明超类）。
- en: Catching multiple exceptions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获多个异常
- en: The compiler will make sure that you’ve handled *all* the checked exceptions
    thrown by the method you’re calling. Stack the *catch* blocks under the *try*,
    one after the other. Sometimes the order in which you stack the catch blocks matters,
    but we’ll get to that a little later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将确保你已处理调用方法抛出的*所有*已检查异常。将 *catch* 块堆叠在 *try* 下，一个接一个。有时候，堆叠 catch 块的顺序很重要，但我们稍后再讨论这一点。
- en: '![image](Images/f0435-01.png)![image](Images/f0435-02.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0435-01.png)![image](Images/f0435-02.png)'
- en: Exceptions are polymorphic
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常是多态的
- en: Exceptions are objects, remember. There’s nothing all that special about one,
    except that it is *a thing that can be **thrown***. So like all good objects,
    Exceptions can be referred to polymorphically. A LingerieException *object*, for
    example, could be assigned to a ClothingException *reference*. A PantsException
    could be assigned to an Exception reference. You get the idea. The benefit for
    exceptions is that a method doesn’t have to explicitly declare every possible
    exception it might throw; it can declare a superclass of the exceptions. Same
    thing with catch blocks—you don’t have to write a catch for each possible exception
    as long as the catch (or catches) you have can handle any exception thrown.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，异常是对象。除了它是*可以抛出的东西*外，没有什么特别的。因此，就像所有良好的对象一样，异常可以多态地引用。例如，LingerieException
    *对象*可以分配给 ClothingException *引用*。PantsException 可以分配给 Exception 引用。你明白了吧。对于异常来说，方法不必显式声明它可能抛出的每个可能异常；它可以声明异常的超类。对于
    catch 块也是一样—只要你有的 catch（或多个 catch）可以处理抛出的任何异常，你就不必为每个可能的异常编写 catch。
- en: '![image](Images/f0436-01.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0436-01.png)'
- en: '![Images](Images/1.png) **You can DECLARE exceptions using a superclass of
    the exceptions you throw.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **你可以使用抛出的异常的超类来声明异常。**'
- en: '![image](Images/f0436-02.png)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0436-02.png)'
- en: '![Images](Images/2.png) **You can CATCH exceptions using a superclass of the
    exception thrown.**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **你可以使用抛出的异常的超类来捕获异常。**'
- en: '![image](Images/f0436-03.png)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0436-03.png)'
- en: '**Just because you CAN catch everything with one big super polymorphic catch,
    doesn’t always mean you SHOULD.**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅仅因为你能用一个大的超级多态 catch 捕获所有东西，并不总是意味着你应该这样做。**'
- en: You *could* write your exception-handling code so that you specify only *one*
    catch block, using the superclass Exception in the catch clause, so that you’ll
    be able to catch *any* exception that might be thrown.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*编写异常处理代码，只指定一个 catch 块，在 catch 子句中使用 Exception 超类，这样你就能捕获*任何*可能抛出的异常。
- en: '![image](Images/f0437-01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0437-01.png)'
- en: '**Write a different catch block for each exception that you need to handle
    uniquely.**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**为需要单独处理的每个异常编写不同的 catch 块。**'
- en: For example, if your code deals with (or recovers from) a TeeShirtException
    differently than it handles a LingerieException, write a catch block for each.
    But if you treat all other types of ClothingException in the same way, then add
    a ClothingException catch to handle the rest.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的代码对 T 恤异常（或从中恢复）的处理方式与对内衣异常不同，那么为每个异常编写一个 catch 块。但如果你对待所有其他类型的服装异常的方式相同，那么添加一个
    ClothingException catch 来处理其余异常。
- en: '![image](Images/f0437-02.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0437-02.png)'
- en: Multiple catch blocks must be ordered from smallest to biggest
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个 catch 块必须从小到大排序
- en: '![image](Images/f0438-01.png)![image](Images/f0438-02.png)![image](Images/f0438-03.png)![image](Images/f0438-04.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0438-01.png)![image](Images/f0438-02.png)![image](Images/f0438-03.png)![image](Images/f0438-04.png)'
- en: The higher up the inheritance tree, the bigger the catch “basket.” As you move
    down the inheritance tree, toward more and more specialized Exception classes,
    the catch “basket” is smaller. It’s just plain old polymorphism.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承树越高的地方，捕获“篮子”越大。当你向下移动到更多专门的异常类时，捕获“篮子”就越小。这就是简单的多态性。
- en: 'A ShirtException catch is big enough to take a TeeShirtException or a DressShirtException
    (and any future subclass of anything that extends ShirtException). A ClothingException
    is even bigger (i.e., there are more things that can be referenced using a ClothingException
    type). It can take an exception of type ClothingException (duh) and any ClothingException
    subclasses: PantsException, UniformException, LingerieException, and ShirtException.
    The mother of all catch arguments is type **Exception**; it will catch *any* exception,
    including runtime (unchecked) exceptions, so you probably won’t use it outside
    of testing.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ShirtException 捕获足够大，可以捕获 TeeShirtException 或 DressShirtException（以及任何继承
    ShirtException 的未来子类）。一个 ClothingException 更大（也就是说，可以引用更多使用 ClothingException
    类型的事物）。它可以捕获 ClothingException 类型的异常（呃），以及任何 ClothingException 的子类：PantsException、UniformException、LingerieException
    和 ShirtException。所有捕获参数的“母亲”是 **Exception** 类型；它会捕获 *任何* 异常，包括运行时（未检查）异常，所以你可能不会在测试之外使用它。
- en: You can’t put bigger baskets above smaller baskets
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不能把更大的篮子放在小篮子上面
- en: '![image](Images/f0439-02.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0439-02.png)'
- en: Well, you *can,* but it won’t compile. Catch blocks are not like overloaded
    methods where the best match is picked. With catch blocks, the JVM simply starts
    at the first one and works its way down until it finds a catch that’s broad enough
    (in other words, high enough on the inheritance tree) to handle the exception.
    If your first catch block is `**catch(Exception ex)**`, the compiler knows there’s
    no point in adding any others—they’ll never be reached.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你 *可以*，但它不会编译通过。捕获块不像重载的方法那样选择最佳匹配项。对于捕获块，JVM 简单地从第一个开始，并沿着继承树向下工作，直到找到足够广泛的捕获（换句话说，在继承树上足够高），以处理异常。如果你的第一个捕获块是
    `**catch(Exception ex)**`，编译器知道没有添加其他捕获块的必要——它们永远不会被执行到。
- en: '![image](Images/f0439-01.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0439-01.png)'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Siblings (exceptions at the same level of the hierarchy tree, like PantsException
    and LingerieException) can be in any order, because they can’t catch one another’s
    exceptions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 兄弟节点（在层次树中同一级别的异常，如 PantsException 和 LingerieException）可以以任何顺序排列，因为它们不能捕获彼此的异常。
- en: You could put ShirtException above LingerieException, and nobody would mind.
    Because even though ShirtException is a bigger (broader) type because it can catch
    other classes (its own subclasses), ShirtException can’t catch a LingerieException,
    so there’s no problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 ShirtException 放在 LingerieException 上面，没人会介意。因为即使 ShirtException 是更大（更广泛）的类型，因为它可以捕获其他类（它自己的子类），但
    ShirtException 不能捕获 LingerieException，所以没有问题。
- en: '![image](Images/arr.png) **Both answers in [“Sharpen your pencil”](#sharpen_your_pencil-id00035).**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **“磨砺你的铅笔”中的两个答案都在 [“Sharpen your pencil”](#sharpen_your_pencil-id00035)
    中。**'
- en: When you don’t want to handle an exception...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你不想处理异常时……
- en: '![image](Images/f0441-02.png)![image](Images/f0441-01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0441-02.png)![image](Images/f0441-01.png)'
- en: '**If you don’t want to handle an exception, you can** **duck** **it by** **declaring**
    **it.**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你不想处理一个异常，你可以** **规避** **它通过** **声明** **它。**'
- en: 'When you call a risky method, the compiler needs you to acknowledge it. Most
    of the time, that means wrapping the risky call in a try/catch. But you have another
    alternative: simply duck it and let the method that called you catch the exception.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个危险的方法时，编译器需要你承认它。大多数时候，这意味着将危险调用包装在 try/catch 中。但你还有另一种选择：简单地规避它，并让调用你的方法捕获异常。
- en: It’s easy—all you have to do is *declare* that *you* throw the exceptions. Even
    though, technically, *you* aren’t the one doing the throwing, it doesn’t matter.
    You’re still the one letting the exception whiz right on by.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易——你只需要 *声明* *你* 抛出异常。即使从技术上讲，*你* 不是在抛出异常，也没关系。你仍然是让异常直接通过的人。
- en: But if you duck an exception, then you don’t have a try/catch, so what happens
    when the risky method (doLaundry()) *does* throw the exception?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你回避了一个异常，那么你没有一个 try/catch，那么当危险方法（doLaundry()）*确实*抛出异常时会发生什么？
- en: When a method throws an exception, that method is popped off the stack immediately,
    and the exception is thrown to the next method down the stack—the *caller*. But
    if the *caller* is a *ducker*, then there’s no catch for it, so the *caller* pops
    off the stack immediately, and the exception is thrown to the next method and
    so on...where does it end? You’ll see a little later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法抛出异常时，该方法会立即从堆栈中弹出，并且异常被抛到堆栈中下一个方法——*调用者*。但如果*调用者*是个*避开者*，那么它就没有捕捉到异常，因此*调用者*也会立即从堆栈中弹出，异常继续被抛到下一个方法，依此类推...这将在稍后详细说明。
- en: '![image](Images/f0441-03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0441-03.png)'
- en: Ducking (by declaring) only delays the inevitable
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避开（通过声明）只是暂时推迟了问题的解决
- en: '**Sooner or later, *somebody* has to deal with it. But what if main() ducks
    the exception?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sooner or later, *somebody* has to deal with it. But what if main() ducks
    the exception?**'
- en: '![image](Images/f0442-01.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0442-01.png)'
- en: '![Images](Images/1circle.png) doLaundry() throws a ClothingException'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circle.png) doLaundry() 抛出 ClothingException'
- en: '![image](Images/f0442-02.png)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0442-02.png)'
- en: '[PRE2]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Images](Images/2circle.png) foo() ducks the exception'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2circle.png) foo() 避开异常'
- en: '![image](Images/f0442-03.png)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0442-03.png)'
- en: '[PRE3]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Images](Images/3circle.png) main() ducks the exception'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3circle.png) main() 避开异常'
- en: '![image](Images/f0442-04.png)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0442-04.png)'
- en: '[PRE4]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Images](Images/4circle.png) The JVM shuts down'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/4circle.png) JVM 关闭'
- en: '![Images](Images/f0442-05.png) We’re using the T-shirt to represent a Clothing
    Exception. We know, we know...you would have preferred the blue jeans.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/f0442-05.png) 我们用 T 恤来代表一个服装异常。我们知道，我们知道...你可能更喜欢蓝色牛仔裤。'
- en: '**Handle or Declare. It’s the law.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Handle or Declare。这是法律。**'
- en: '**So now we’ve seen both ways to satisfy the compiler when you call a risky
    (exception-throwing) method.**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们已经看到了调用风险（抛出异常）方法时满足编译器的两种方式。**'
- en: '![Images](Images/1.png) **HANDLE**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **HANDLE**'
- en: '![image](Images/f0443-01.png)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-01.png)'
- en: '![Images](Images/2.png) **DECLARE (duck it)**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **DECLARE（避开它）**'
- en: Declare that YOUR method throws the same exceptions as the risky method you’re
    calling.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明你的方法抛出与你调用的危险方法相同的异常。
- en: '![image](Images/f0443-02.png)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-02.png)'
- en: But now this means that whoever calls the foo() method has to follow the Handle
    or Declare law. If foo() ducks the exception (by declaring it) and main() calls
    foo(), then main() has to deal with the exception.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但现在这意味着调用 foo() 方法的任何人都必须遵循 Handle or Declare 法则。如果 foo() 避开异常（通过声明它），而 main()
    调用了 foo()，那么 main() 就必须处理这个异常。
- en: '![image](Images/f0443-03.png)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-03.png)'
- en: Getting back to our music code...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的音乐代码...
- en: Now that you’ve completely forgotten, we started this chapter with a first look
    at some JavaSound code. We created a Sequencer object, but it wouldn’t compile
    because the method Midi.getSequencer() declares a checked exception (MidiUnavailableException).
    But we can fix that now by wrapping the call in a try/catch.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完全忘记了，我们在本章开始时首次看了一些 JavaSound 代码。我们创建了一个 Sequencer 对象，但它无法编译，因为方法 Midi.getSequencer()
    声明了一个受检异常（MidiUnavailableException）。但现在我们可以通过包裹在 try/catch 中来修复这个问题。
- en: '![image](Images/f0444-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0444-01.png)'
- en: Exception Rules
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常规则
- en: '![Images](Images/1.png) **You cannot have a catch or finally without a try.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **在 try 后面没有 catch 或 finally 是不允许的。**'
- en: '![image](Images/f0444-02.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0444-02.png)'
- en: '![Images](Images/2.png) **You cannot put code between the try and the catch.**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **你不能在 try 和 catch 之间插入代码。**'
- en: '![image](Images/f0444-03.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0444-03.png)'
- en: '![Images](Images/3.png) **A try MUST be followed by either a catch or a finally.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3.png) **一个 try 后面必须跟着 catch 或 finally。**'
- en: '![image](Images/f0444-04.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0444-04.png)'
- en: '![Images](Images/4.png) **A try with only a finally (no catch) must still declare
    the exception.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/4.png) **一个只有 finally 而没有 catch 的 try 仍然必须声明异常。**'
- en: '![image](Images/f0444-05.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0444-05.png)'
- en: Code Kitchen
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code Kitchen
- en: '![image](Images/f0445-01.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0445-01.png)'
- en: '**You don’t have to do it yourself, but it’s a lot more fun if you do.**'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**你不一定非得自己做，但如果你这么做会更有趣。**'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The rest of this chapter is optional; you can use Ready-Bake Code for all
    the music apps.**'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**本章的剩余内容是可选的；你可以为所有音乐应用使用现成的代码。**'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**But if you want to learn more about JavaSound, turn the page.**'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**但如果你想更多地了解 JavaSound，请翻到下一页。**'
- en: Making actual sound
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出实际声音
- en: 'Remember near the beginning of the chapter, we looked at how MIDI data holds
    the instructions for *what* should be played (and *how* it should be played) and
    we also said that MIDI data doesn’t actually *create any sound that you hear.*
    For sound to come out of the speakers, the MIDI data has to be sent through some
    kind of MIDI device that takes the MIDI instructions and renders them in sound,
    by triggering either a hardware instrument or a “virtual” instrument (software
    synthesizer). In this book, we’re using only software devices, so here’s how it
    works in JavaSound:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得章节开头我们讨论过 MIDI 数据保存了*什么*要播放（以及*如何*播放），并且我们也说过 MIDI 数据实际上并不会*产生任何你听到的声音*。要从扬声器中发出声音，MIDI
    数据必须通过某种 MIDI 设备发送，该设备将 MIDI 指令渲染成声音，通过触发硬件乐器或“虚拟”乐器（软件合成器）。在本书中，我们只使用软件设备，以下是在
    JavaSound 中的工作原理：
- en: '**You need FOUR things:**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**你需要四件事情：**'
- en: '![image](Images/f0446-01.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0446-01.png)'
- en: '**And you need FIVE steps:**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**而你需要五个步骤：**'
- en: '![Images](Images/1.png) Get a `**Sequencer**` and open it'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 获取一个`**Sequencer**`并打开它'
- en: '[PRE5]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Images](Images/2.png) Make a new `**Sequence**`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 创建一个新的`**Sequence**`'
- en: '[PRE6]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Images](Images/3.png) Get a new `**Track**` from the Sequence'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 从序列中获取一个新的`**Track**`'
- en: '[PRE7]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Images](Images/4.png) Fill the Track with `**MidiEvents**` and give the Sequence
    to the Sequencer'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 用`**MidiEvents**`填充轨道，并将序列给 Sequencer'
- en: '[PRE8]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![image](Images/f0447-04.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0447-04.png)'
- en: 'Version 1: Your very first sound player app'
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本 1：你的第一个音乐播放器应用程序
- en: Type it in and run it. You’ll hear the sound of someone playing a single note
    on a piano! (OK, maybe not some*one*, but some*thing*.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输入代码并运行。你会听到有人在钢琴上弹奏单音！（好吧，也许不是某*个*人，而是某*物*。）
- en: '![image](Images/f0448-01.png)![image](Images/f0448-02.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0448-01.png)![图片](Images/f0448-02.png)'
- en: Making a MidiEvent (song data)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作 MidiEvent（歌曲数据）
- en: A MidiEvent is an instruction for part of a song. A series of MidiEvents is
    kind of like sheet music, or a player piano roll. Most of the MidiEvents we care
    about describe ***a thing to do*** and the ***moment in time to do it***. The
    moment in time part matters, since timing is everything in music. This note follows
    this note and so on. And because MidiEvents are so detailed, you have to say at
    what moment to *start* playing the note (a NOTE ON event) and at what moment to
    *stop* playing the notes (NOTE OFF event). So you can imagine that firing the
    “stop playing note G” (NOTE OFF message) *before* the “start playing Note G” (NOTE
    ON) message wouldn’t work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MidiEvent 是歌曲的一部分指令。一系列 MidiEvents 有点像乐谱或自动钢琴卷。我们关心的大多数 MidiEvents 描述的是要做的***事情***以及***何时***去做。时间的概念很重要，因为在音乐中，时间至关重要。这个音符跟随那个音符，依此类推。由于
    MidiEvents 非常详细，你必须说明何时*开始*播放音符（NOTE ON 事件）以及何时*停止*播放音符（NOTE OFF 事件）。因此，你可以想象在“停止播放音符
    G”（NOTE OFF 消息）*之前*触发“开始播放音符 G”（NOTE ON）消息是行不通的。
- en: The MIDI instruction actually goes into a Message object; the MidiEvent is a
    combination of the Message plus the moment in time when that message should “fire.”
    In other words, the Message might say, “Start playing Middle C,” while the MidiEvent
    would say, “Trigger this message at beat 4.”
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI 指令实际上放入一个 Message 对象；而 MidiEvent 是消息和消息“触发”的时间点的组合。换句话说，消息可能是“开始播放中音 Do”，而
    MidiEvent 则是“在第四拍触发此消息”。
- en: So we always need a Message and a MidiEvent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们总是需要一个消息和一个 MidiEvent。
- en: The Message says *what* to do, and the MidiEvent says *when* to do it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 消息说*做什么*，而 MidiEvent 则说*什么时候*去做。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**A MidiEvent says what to do and when to do it.**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个 MidiEvent 告诉你要做什么，以及什么时候去做。**'
- en: '**Every instruction must include the timing for that instruction.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个指令必须包含其时机。**'
- en: '**In other words, at which beat that thing should happen.**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**换句话说，在哪个拍子发生那件事。**'
- en: '![Images](Images/1.png) Make a **Message**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 制作一个**消息**'
- en: '`ShortMessage msg = new ShortMessage();`'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ShortMessage msg = new ShortMessage();`'
- en: '![Images](Images/2.png) Put the **Instruction** in the Message'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 将**指令**放入消息中'
- en: '![image](Images/f0449-01.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0449-01.png)'
- en: '![Images](Images/3.png) Make a new **MidiEvent** using the Message'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 使用消息创建一个新的**MidiEvent**'
- en: '![image](Images/f0449-02.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0449-02.png)'
- en: '![Images](Images/4.png) Add the MidiEvent to the **Track**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 将 MidiEvent 添加到**轨道**中'
- en: '![image](Images/f0449-03.png)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0449-03.png)'
- en: 'MIDI message: the heart of a MidiEvent'
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MIDI 消息：MidiEvent 的核心
- en: A MIDI message holds the part of the event that says *what* to do. It’s the
    actual instruction you want the sequencer to execute. The first argument of an
    instruction is always the type of the message. The values you pass to the other
    three arguments depend on the type of message. For example, a message of type
    144 means “NOTE ON.” But in order to carry out a NOTE ON, the sequencer needs
    to know a few things. Imagine the sequencer saying, “OK, I’ll play a note, but
    *which channel*? In other words, do you want me to play a Drum note or a Piano
    note? And *which note*? Middle-C? D Sharp? And while we’re at it, at *which velocity*
    should I play the note?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI 消息包含事件的一部分，说明要做的动作。它是你希望序列器执行的实际指令。指令的第一个参数始终是消息的类型。你传递给其它三个参数的值取决于消息的类型。例如，类型为
    144 的消息意味着“NOTE ON”（音符开启）。但是为了执行 NOTE ON，序列器需要知道一些信息。想象一下序列器说：“好的，我将播放一个音符，但是在*哪个通道*？换句话说，你要我演奏鼓还是钢琴？还有*哪个音符*？中音C？D#？还有，在*哪个速度*下我应该演奏这个音符？
- en: To make a MIDI message, make a ShortMessage instance and invoke setMessage(),
    passing in the four arguments for the message. But remember, the message says
    only *what* to do, so you still need to stuff the message into an event that adds
    *when* that message should “fire.”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个MIDI消息，创建一个ShortMessage实例并调用setMessage()，传入消息的四个参数。但请记住，消息只说明要做*什么*，所以你仍然需要将消息装入一个事件中，以便确定消息“触发”的*时间*。
- en: Anatomy of a message
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息的解剖
- en: The *first* argument to setMessage() always represents the message “type,” while
    the *other t*hree arguments represent different things depending on the message
    type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMessage()` 的第一个参数始终表示“类型”消息，而其它三个参数根据消息类型表示不同的内容。'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The Message says what to do; the MidiEvent says when to do it.**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息说明要做什么；MidiEvent说明何时执行。**'
- en: '![image](Images/f0450-01.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0450-01.png)'
- en: '![Images](Images/1.png) **Message type**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **消息类型**'
- en: '![image](Images/f0450-02.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0450-02.png)'
- en: '![Images](Images/2.png) **Channel**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **通道**'
- en: Think of a channel like a musician in a band. Channel 1 is musician 1 (the keyboard
    player), channel 9 is the drummer, etc.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 把通道想象成乐队中的音乐家。通道1是音乐家1（键盘手），通道9是鼓手，等等。
- en: '![Images](Images/3.png) **Note to play**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **要演奏的音符**'
- en: A number from 0 to 127, going from low to high notes.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从低音到高音，数字从0到127。
- en: '![image](Images/f0450-03.png)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0450-03.png)'
- en: '![Images](Images/4.png) **Velocity**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) **速度**'
- en: How fast and hard did you press the key? 0 is so soft you probably won’t hear
    anything, but 100 is a good default.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你按键时的速度和力度是多少？0表示非常轻柔，你可能听不到任何声音，但100是一个很好的默认值。
- en: '![image](Images/f0450-04.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0450-04.png)'
- en: Change a message
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变消息
- en: Now that you know what’s in a MIDI message, you can start experimenting. You
    can change the note that’s played, how long the note is held, add more notes,
    and even change the instrument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了一个MIDI消息的组成，可以开始进行实验了。你可以改变播放的音符，音符持续的时间，增加更多的音符，甚至改变乐器。
- en: '![Images](Images/1.png) **Change the note**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **改变音符**'
- en: Try a number between 0 and 127 in the note on and note off messages.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试在音符开启和音符关闭的消息中使用介于0到127之间的数字。
- en: '[PRE9]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](Images/f0451-01.png)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0451-01.png)'
- en: '![Images](Images/2.png) **Change the duration of the note**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **改变音符的持续时间**'
- en: Change the note off event (not the *message*) so that it happens at an earlier
    or later beat.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改变音符关闭事件（不是*消息*），使其发生在较早或较晚的节拍。
- en: '[PRE10]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](Images/f0451-02.png)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0451-02.png)'
- en: '![Images](Images/3.png) **Change the instrument**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **改变乐器**'
- en: Add a new message, BEFORE the note-playing message, that sets the instrument
    in channel 1 to something other than the default piano. The change-instrument
    message is “192,” and the third argument represents the actual instrument (try
    a number between 0 and 127).
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在播放音符的消息之前添加一个新消息，将通道1的乐器设置为除默认钢琴外的其他乐器。改变乐器的消息是“192”，第三个参数代表实际乐器（尝试一个介于0到127之间的数字）。
- en: '![image](Images/f0451-03.png)![image](Images/f0451-04.png)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0451-03.png)![图片](Images/f0451-04.png)'
- en: 'Version 2: Using command-line args to experiment with sounds'
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本 2：使用命令行参数来尝试不同的声音
- en: This version still plays just a single note, but you get to use command-line
    arguments to change the instrument and note. Experiment by passing in two int
    values from 0 to 127\. The first int sets the instrument; the second int sets
    the note to play.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本仍然只播放单个音符，但你可以使用命令行参数来改变乐器和音符。通过传入两个从0到127的整数值来进行实验。第一个整数设置乐器，第二个整数设置要播放的音符。
- en: '![image](Images/f0452-01.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0452-01.png)'
- en: Where we’re headed with the rest of the CodeKitchens
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何通过CodeKitchens的其余部分实现目标
- en: '| **[Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads): the
    goal** When we’re done, we’ll have a working BeatBox that’s also a Drum Chat Client.
    We’ll need to learn about GUIs (including event handling), I/O, networking, and
    threads. The next three ([Chapter 14](ch14.xhtml#a_very_graphic_story_getting_gui),
    [Chapter 15](ch15.xhtml#work_on_your_swing_using_swing), and [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr))
    will get us there. | ![image](Images/f0453-01.png) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **[第17章](ch17.xhtml#make_a_connection_networking_and_threads): 目标** 当我们完成时，我们将拥有一个既是工作的BeatBox，又是Drum
    Chat客户端的BeatBox。我们需要学习关于GUI（包括事件处理）、I/O、网络和线程的知识。接下来的三章（[第14章](ch14.xhtml#a_very_graphic_story_getting_gui)、[第15章](ch15.xhtml#work_on_your_swing_using_swing)和[第16章](ch16.xhtml#saving_objects_left_parenthesisand_textr)）将带我们达到目标。
    | ![image](Images/f0453-01.png) |'
- en: '| **[Chapter 14](ch14.xhtml#a_very_graphic_story_getting_gui): MIDI events**
    This CodeKitchen lets us build a little “music video” (bit of a stretch to call
    it that...) that draws random rectangles to the beat of the MIDI music. We’ll
    learn how to construct and play a lot of MIDI events (instead of just a couple,
    as we do in the current chapter). | ![image](Images/f0453-02.png) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **[第14章](ch14.xhtml#a_very_graphic_story_getting_gui): MIDI事件** 这个CodeKitchen让我们构建一个小型“音乐视频”（有点牵强地称之为音乐视频……），它按照MIDI音乐的节奏绘制随机矩形。我们将学习如何构建和播放大量的MIDI事件（而不仅仅是当前章节中的一两个）。
    | ![image](Images/f0453-02.png) |'
- en: '| **[Chapter 15](ch15.xhtml#work_on_your_swing_using_swing): Standalone BeatBox**
    Now we’ll actually build the real BeatBox, GUI and all. But it’s limited—as soon
    as you change a pattern, the previous one is lost. There’s no Save and Restore
    feature, and it doesn’t communicate with the network. (But you can still use it
    to work on your drum pattern skills.) | ![image](Images/f0453-03.png) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **[第15章](ch15.xhtml#work_on_your_swing_using_swing): 独立BeatBox** 现在我们将实际构建真正的BeatBox，包括GUI。但它的功能有限——一旦更改模式，之前的模式就会丢失。没有保存和恢复功能，并且它不与网络通信。（但您仍然可以使用它来提高鼓模式技能。）
    | ![image](Images/f0453-03.png) |'
- en: '| **[Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr): Save
    and Restore** You’ve made the perfect pattern, and now you can save it to a file
    and reload it when you want to play it again. This gets us ready for the final
    version ([Chapter 15](ch15.xhtml#work_on_your_swing_using_swing)), where instead
    of writing the pattern to a file, we send it over a network to the chat server.
    | ![image](Images/f0453-04.png) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **[第16章](ch16.xhtml#saving_objects_left_parenthesisand_textr): 保存和恢复** 您已经创建了完美的模式，现在可以将其保存到文件中，并在需要时重新加载。这让我们准备好进入最终版本（[第15章](ch15.xhtml#work_on_your_swing_using_swing)），在这一版本中，我们不再将模式写入文件，而是将其发送到聊天服务器。
    | ![image](Images/f0453-04.png) |'
- en: Exercise
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: This chapter explored the wonderful world of exceptions. Your job is to decide
    whether each of the following exception-related statements is true or false.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了异常的精彩世界。您的任务是判断以下与异常相关的语句是真还是假。
- en: True or False
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真或假
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/hand.png)![image](Images/hand1.png)'
- en: A try block must be followed by a catch and a finally block.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: try块必须跟随catch块和finally块。
- en: If you write a method that might cause a compiler-checked exception, you must
    wrap that risky code in a try/catch block.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编写可能引起编译检查异常的方法，则必须将该风险代码包装在try/catch块中。
- en: Catch blocks can be polymorphic.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: catch块可以是多态的。
- en: Only “compiler checked” exceptions can be caught.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有“经过编译检查”的异常可以被捕获。
- en: If you define a try/catch block, a matching finally block is optional.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果定义了try/catch块，则匹配的finally块是可选的。
- en: If you define a try block, you can pair it with a matching catch or finally
    block, or both.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果定义了try块，可以将其与匹配的catch块或finally块或两者配对使用。
- en: If you write a method that declares that it can throw a compiler-checked exception,
    you must also wrap the exception throwing code in a try/catch block.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您编写一个声明可能抛出经过编译检查的异常的方法，则必须将抛出异常的代码包装在try/catch块中。
- en: The main( ) method in your program must handle all unhandled exceptions thrown
    to it.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的程序中的main()方法必须处理传递给它的所有未处理异常。
- en: A single try block can have many different catch blocks.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个单独的try块可以有多个不同的catch块。
- en: A method can throw only one kind of exception.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法只能抛出一种类型的异常。
- en: A finally block will run regardless of whether an exception is thrown.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是否抛出异常，finally块都会运行。
- en: A finally block can exist without a try block.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: finally块可以在没有try块的情况下存在。
- en: A try block can exist by itself, without a catch block or a finally block.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个try块可以单独存在，没有catch块或finally块。
- en: Handling an exception is sometimes referred to as “ducking.”
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理异常有时被称为“躲避”。
- en: The order of catch blocks never matters.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获块的顺序永远不重要。
- en: A method with a try block and a finally block can optionally declare a checked
    exception.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有try块和finally块的方法可以选择声明一个已检查的异常。
- en: Runtime exceptions must be handled or declared.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须处理或声明运行时异常。
- en: '![image](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfrom_page).**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“真或假”](#true_or_false_left_parenthesisfrom_page)。**'
- en: Code Magnets
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](Images/f0455-02.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0455-02.png)'
- en: A working Java program is scrambled up on the fridge. Can you reconstruct all
    the code snippets to make a working Java program that produces the output listed
    below? Some of the curly braces fell on the floor and they were too small to pick
    up, so feel free to add as many of those as you need!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作中的Java程序被弄乱在冰箱上。你能重新构建所有的代码片段，使其成为一个能够输出下列内容的工作中的Java程序吗？一些花括号掉到了地板上，它们太小了，无法捡起来，所以随意添加你需要的数量！
- en: '![image](Images/f0455-05.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0455-05.png)'
- en: '![image](Images/arr.png) **Answers in [“Code Magnets”](ch02.xhtml#code_magnets_left_parenthesisfrom_page_4).**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“代码磁铁”](ch02.xhtml#code_magnets_left_parenthesisfrom_page_4)。**'
- en: JavaCross
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaCross
- en: '![image](Images/arr.png) **Answers in [“JavaCross”](#javacross_left_parenthesisfrom_page_456r).**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **答案在[“JavaCross”](#javacross_left_parenthesisfrom_page_456r)。**'
- en: '![image](Images/f0456-01.png)![image](Images/f0456-02.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0456-01.png)![image](Images/f0456-02.png)'
- en: You know what to do!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道该怎么做！
- en: '**Across**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**横向**'
- en: 1\. To give value
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 给予价值
- en: 4\. Flew off the top
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 飞到顶部
- en: 6\. All this and more!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 所有这些和更多！
- en: 8\. Start
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 开始
- en: 10\. The family tree
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. 家谱
- en: 13\. No ducking
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 13\. 不躲避
- en: 15\. Problem objects
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 15\. 问题对象
- en: 18\. One of Java’s ‘49’
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 18\. Java的‘49’之一
- en: 20\. Class hierarchy
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 20\. 类层次结构
- en: 21\. Too hot to handle
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 21\. 太热而无法处理
- en: 24\. Common primitive
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 24\. 常见的原始类型
- en: 25\. Code recipe
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 25\. 代码配方
- en: 27\. Unruly method action
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 27\. 不守规矩的方法动作
- en: 28\. No Picasso here
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 28\. 这里没有毕加索
- en: 29\. Start a chain of events
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 29\. 启动一系列事件
- en: '**Down**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**向下**'
- en: 2\. Currently usable
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当前可用
- en: 3\. Template’s creation
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 模板的创建
- en: 4\. Don’t show the kids
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 不要让孩子看到
- en: 5\. Mostly static API class
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 大部分静态API类
- en: 7\. Not about behavior
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 不是关于行为的
- en: 9\. The template
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 模板
- en: 11\. Roll another one off the line
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. 把另一个推出生产线
- en: 12\. Javac saw it coming
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. Javac看到了它的来临
- en: 14\. Attempt risk
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 14\. 尝试风险
- en: 16\. Automatic acquisition
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 16\. 自动获取
- en: 17\. Changing method
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 17\. 改变方法
- en: 19\. Announce a duck
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 19\. 宣布一只鸭子
- en: 22\. Deal with it
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 22\. 处理它
- en: 23\. Create bad news
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 23\. 创造坏消息
- en: 26\. One of my roles
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 26\. 我的角色之一
- en: '**More Hints:**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多提示：**'
- en: '**Across**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**横向**'
- en: 6\. A Java child
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 一个Java子类
- en: 8\. Start a method
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 开始一个方法
- en: 13\. Instead of declare
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 13\. 而不是声明
- en: 20\. Also a type of collection
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 20\. 也是一种集合类型
- en: 21\. Quack
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 21\. 嘎嘎叫
- en: 27\. Starts a problem
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 27\. 开始一个问题
- en: 28\. Not Abstract
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 28\. 不是抽象的
- en: '**Down**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**向下**'
- en: 2\. Or a mouthwash
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 或者漱口水
- en: 3\. For ______ (not example)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 对______（不是例子）
- en: 5\. Numbers . . .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 数字……
- en: 9\. Only public or default
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 只有公共或默认
- en: 16\. _____ the family fortune
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 16\. _____家族财富
- en: 17\. Not a ‘getter’
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 17\. 不是‘getter’
- en: Sharpen your pencil
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磨笔刀
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00034))
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: (from [“磨笔刀”](#sharpen_your_pencil-id00034))
- en: '![image](Images/pencil.png)![image](Images/f0457-01.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/pencil.png)![image](Images/f0457-01.png)'
- en: Exercise Solution
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解决方案
- en: '![image](Images/exercise.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: True or False
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真或假
- en: (from [“True or False”](#true_or_false-id000040))
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: (from [“真或假”](#true_or_false-id000040))
- en: False, either or both.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 要么这个要么那个。
- en: False, you can declare the exception.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 你可以声明异常。
- en: True.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True.
- en: False, runtime exception can be caught.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 运行时异常可以被捕获。
- en: True.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True.
- en: True, both are acceptable.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True, 两者都可以接受。
- en: False, the declaration is sufficient.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 声明足够了。
- en: False, but if it doesn’t, the JVM may shut down.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, but if it doesn’t, the JVM may shut down.
- en: True.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True.
- en: False.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False.
- en: True. It’s often used to clean up partially completed tasks.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: True. 它经常用于清理部分完成的任务。
- en: False.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False.
- en: False.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False.
- en: False, ducking is synonymous with declaring.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 躲避与声明是同义词。
- en: False, broadest exceptions must be caught by the last catch blocks.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 最广泛的异常必须由最后的catch块捕获。
- en: False, if you don’t have a catch block, you must declare.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False, 如果没有catch块，你必须声明。
- en: False.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: False.
- en: Code Magnets
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: (from [“Code Magnets”](#code_magnets-id000005))
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: (from [“代码磁铁”](#code_magnets-id000005))
- en: '[PRE11]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![image](Images/f0458-02.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0458-02.png)'
- en: JavaCross
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaCross
- en: (from [“JavaCross”](#javacross-id00003))
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: (from [“JavaCross”](#javacross-id00003))
- en: '![image](Images/f0456-01.png)![image](Images/f0459-01.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0456-01.png)![图片](Images/f0459-01.png)'
