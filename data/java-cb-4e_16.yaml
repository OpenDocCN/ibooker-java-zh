- en: Chapter 16\. Threaded Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章 线程化 Java
- en: 16.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.0 介绍
- en: We live in a world of multiple activities. A person may be talking on the phone
    while doodling or reading a memo. A multifunction office machine may scan one
    fax while receiving another and printing a document from somebody’s computer.
    We expect the GUI programs we use to be able to respond to a menu while updating
    the screen. But ordinary computer programs can do only one thing at a time. The
    conventional computer programming model—that of writing one statement after another,
    punctuated by repetitive loops and binary decision making—is sequential at heart.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个多活动的世界中。一个人可能一边打电话一边涂鸦或阅读备忘录。一个多功能办公设备可能在接收一个传真、扫描另一个传真并从某人的计算机打印文档。我们希望我们使用的
    GUI 程序能够在更新屏幕的同时响应菜单。但普通的计算机程序一次只能做一件事。传统的计算机编程模型——一条接着一条地写语句，由重复循环和二进制决策构成——在本质上是顺序的。
- en: 'Sequential processing is straightforward but not as efficient as it could be.
    To enhance performance, Java offers *threading*, the capability to handle multiple
    flows of control within a single application or process. Java provides thread
    support and, in fact, requires threads: the Java runtime itself is inherently
    multithreaded. For example, window system action handling and Java’s garbage collection—that
    miracle that lets us avoid having to free everything we allocate, as others must
    do when working in languages at or below C level—run in separate threads.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序处理虽然简单直接，但效率不及其它方法高。为了提高性能，Java 提供了*线程*，即在单个应用程序或进程内处理多个控制流的能力。Java 提供线程支持，并且实际上要求线程：Java
    运行时本身就是固有的多线程的。例如，窗口系统的动作处理和 Java 的垃圾收集（这种神奇的功能使我们可以避免在分配和释放内存时像其他低于或等于 C 语言级别的语言那样需要手动释放所有内容）是在不同的线程中运行的。
- en: Just as multitasking allows a single operating system to give the appearance
    of running more than one program at the same time on a single-processor computer,
    multithreading can allow a single program or process to give the appearance of
    working on more than one thing at the same time. Multithreading leads to more
    interactive graphics and more responsive GUI applications (the program can draw
    in a window while responding to a menu, with both activities occurring more or
    less independently), more reliable network servers (if one client does something
    wrong, the server continues communicating with the others), and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多任务处理允许单个操作系统在单处理器计算机上同时运行多个程序一样，多线程可以使单个程序或进程在同一时间内看起来像在处理多个任务。多线程导致更交互式的图形和更响应迅速的
    GUI 应用程序（程序可以在窗口中绘制同时响应菜单，这两个活动几乎独立进行），更可靠的网络服务器（如果一个客户端出错，服务器继续与其他客户端通信），等等。
- en: 'Note that I did not say “multiprocessing” in the previous paragraph. The term
    multi-tasking is sometimes erroneously called multiprocessing, but that term in
    fact refers to different issue: it’s the case of two or more CPUs running under
    a single operating system. Multiprocessing per se is nothing new: IBM mainframes
    did it in the 1970s, Sun SPARCstations did it in the 1980s, and Intel PCs did
    it in the 1990s. Since the mid-2010s, it has become increasingly hard to buy a
    single-processor computer packaged inside anything larger than a wristwatch. True
    multiprocessing allows you to have more than one process running concurrently
    on more than one CPU. Java’s support for threading includes multiprocessing, as
    long as the operating system supports it. Consult your system documentation for
    details.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在上一段中没有说“多处理”。有时候，多任务处理的术语被错误地称为多处理，但事实上，这个术语指的是不同的问题：即两个或更多个 CPU 在单个操作系统下运行的情况。多处理本身并不新鲜：IBM
    大型机在1970年代就做过，Sun SPARCstations 在1980年代做过，Intel PC 在1990年代做过。自2010年中期以来，越来越难买到只包含一个处理器的计算机，除了手表之外的任何装置。真正的多处理允许您在多个
    CPU 上同时运行多个进程。Java 对线程的支持包括多处理，只要操作系统支持。请参阅系统文档以获取详细信息。
- en: Though most modern operating systems provide threads, Java was the first mainstream
    programming language to have intrinsic support for threaded operations built right
    into the language. The semantics of `java.lang.Object`, of which all objects are
    instances, includes the notion of monitor locking of objects, and some methods
    (`notify`, `notifyAll`, `wait`) are meaningful only in the context of a multithreaded
    application. Java also has language keywords such as `synchronized` to control
    the behavior of threaded applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数现代操作系统都提供线程，但Java是第一种在语言中内置支持线程操作的主流编程语言。`java.lang.Object`的语义包括对象的监视器锁定的概念，一些方法（`notify`，`notifyAll`，`wait`）仅在多线程应用程序的上下文中有意义。Java还有诸如`synchronized`之类的语言关键字，用于控制线程应用程序的行为。
- en: Now that the world has had years of experience with threaded Java, experts have
    started building better ways of writing threaded applications. The Concurrency
    Utilities, specified in JSR 166^([1](ch16.html#idm45290633711352)) and included
    in all modern Java releases, are heavily based on the `util.concurrent` package
    by Professor Doug Lea of the Computer Science Department at the State University
    of New York at Oswego. This package aims to do for the difficulties of threading
    what the Collections classes (see [Chapter 7](ch07.html#javacook-structure)) did
    for structuring data. This is no small undertaking, but they pulled it off.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在世界各地已经有多年与Java线程化的经验，专家们开始构建编写线程化应用程序的更好方法。并发实用程序是根据JSR 166^([1](ch16.html#idm45290633711352))规范，并包含在所有现代Java发布版中，它们在计算机科学系的Doug
    Lea教授的`util.concurrent`包的基础上进行了大量的扩展。这个包旨在解决线程化困难，就像集合类（参见[第7章](ch07.html#javacook-structure)）为数据结构化所做的那样。这不是一个小事业，但他们成功地完成了。
- en: 'The `java.util.concurrent` package includes several main sections:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包包括几个主要部分：'
- en: '`Executor`s, thread pools (`ExecutorService`s), and `Future`s/`CompletableFuture`s'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executor`s，线程池（`ExecutorService`s）和`Future`s/`CompletableFuture`s'
- en: '`Queue`s and `BlockingQueue`s'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue`和`BlockingQueue`'
- en: Locks and conditions, with JVM support for faster locking and unlocking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁和条件，具有JVM支持的更快锁定和解锁
- en: Synchronizers, including `Semaphore`s and `Barrier`s
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步器，包括`Semaphore`和`Barrier`
- en: Atomic variables
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子变量
- en: In this chapter I will focus on the first set of these, thread pools and `Future`s.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将专注于第一组，即线程池和`Future`s。
- en: An implementation of the `Executor` interface is, as the name implies, a class
    that can execute code for you. The code to be executed can be the familiar `Runnable`
    or a new interface `Callable`. One common kind of `Executor` is a *thread pool*.
    The `Future` interface represents the future state of something that has been
    started; it has methods to wait until the result is ready. A `CompletableFuture`
    is an implementation of `Future` that adds many additional methods for chaining
    `CompletableFuture`s and post-applied methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`接口的实现正如其名称所示，是一个可以为你执行代码的类。要执行的代码可以是熟悉的`Runnable`或新的接口`Callable`。一种常见的`Executor`类型是*线程池*。`Future`接口表示已经启动的某事物的未来状态；它有等待结果准备好的方法。`CompletableFuture`是`Future`的实现，它增加了许多用于链式处理`CompletableFuture`和后应用方法的附加方法。'
- en: These brief definitions are oversimplifications. Addressing all the issues is
    beyond the scope of this chapter, but I do provide several examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简要定义都是过于简化了。解决所有问题超出了本章的范围，但我提供了几个例子。
- en: 16.1 Running Code in a Different Thread
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.1 在不同线程中运行代码
- en: Problem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to write a threaded application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写一个线程化的应用程序。
- en: Solution
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write code that implements `Runnable`; pass it to an `Executor`, or instantiate
    a `Thread` and start it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编写实现`Runnable`的代码；将其传递给`Executor`，或者实例化一个`Thread`并启动它。
- en: Discussion
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are several ways to implement threading, and they all require you to
    implement the `Runnable` or `Callable` interface. `Runnable` has only one method,
    and it returns no value; this is its signature:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种实现线程的方式，它们都要求你实现`Runnable`或`Callable`接口。`Runnable`只有一个方法，并且不返回任何值；这是它的签名：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Callable` has similarly only one method, but the `call()` method returns a
    specific type so the interface has a type parameter (`V` here, for “value”):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`同样只有一个方法，但`call()`方法返回特定类型，因此接口有一个类型参数（这里是`V`，代表“值”）：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You must provide an implementation of the `run()` or `call()` method. There
    is nothing special to this method; it’s an ordinary method and you could call
    it yourself. But if you did, what then? There wouldn’t be the special magic that
    launches it as an independent flow of control, so it wouldn’t run concurrently
    with your main program or flow of control. For this, you need to invoke the magic
    of thread creation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须提供 `run()` 或 `call()` 方法的实现。这个方法没什么特别的；它是一个普通方法，你也可以自己调用它。但如果你这样做了，那又怎样呢？它不会像独立的控制流那样启动特殊的魔法，所以它不会与你的主程序或控制流并发运行。为了实现这一点，你需要调用线程创建的魔法。
- en: 'The original way of using threads, no longer generally recommended, is to create
    `Thread` objects directly and call their `start()` method, which would cause the
    thread to call the `run()` method after the new thread had been initialized. There
    was no support for the `Callable` interface in the original threads model. You
    create threads by doing one of the following things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的原始方式，不再一般推荐，是直接创建 `Thread` 对象并调用它们的 `start()` 方法，这会在新线程初始化后调用 `run()` 方法。原始线程模型中没有支持
    `Callable` 接口。你可以通过以下几种方式之一创建线程：
- en: Subclass `java.lang.Thread` (which implements `Runnable`) and override the `run()`
    method.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承 `java.lang.Thread`（它实现了 `Runnable`），并重写 `run()` 方法。
- en: Create your `Runnable` and pass it into the `Thread` constructor.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的 `Runnable` 并将其传递给 `Thread` 构造函数。
- en: With Java 8+, as shown in [Recipe 9.0](ch09.html#javacook-fp-intro), you can
    use a lambda expression to implement `Runnable`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 8+，如 [Recipe 9.0](ch09.html#javacook-fp-intro) 所示，你可以使用 lambda 表达式来实现
    `Runnable`。
- en: This approach is no longer recommended because of issues such as performance
    (`Thread` objects are expensive to create and tear down, and a thread is unusable
    once its `run()` method returns). Because it is no longer recommended to invoke
    threading in this fashion, I no longer show examples of doing so. There are some
    examples in the online source, in the *threads* directory; see especially *ThreadsDemo4*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能等问题（`Thread` 对象的创建和销毁成本高昂，而且一旦其 `run()` 方法返回，线程就无法再使用），不再推荐采用这种方式调用线程。我不再展示这样做的示例。在线源代码中有一些示例，在
    *threads* 目录下查看；特别是 *ThreadsDemo4*。
- en: Instead, the recommended way to perform threaded operations is to use the `java.util.concurrent`
    package’s `ExecutorService`. An `ExecutorService` is, as its name implies, a service
    class that can execute code for you. The code to be executed can be in a `Runnable`
    or a `Callable`. You obtain an `ExecutorService` by invoking a factory method
    on the `Executors` class. The code in [Example 16-1](#javacook-threads-EX-16)
    shows a simple example of a thread pool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，推荐的执行线程操作的方式是使用 `java.util.concurrent` 包的 `ExecutorService`。`ExecutorService`
    如其名，是一个可以为你执行代码的服务类。要执行的代码可以是 `Runnable` 或 `Callable`。你可以通过在 `Executors` 类上调用工厂方法来获取
    `ExecutorService`。[Example 16-1](#javacook-threads-EX-16) 中的代码展示了一个线程池的简单示例。
- en: Example 16-1\. main/src/main/java/threads/ThreadPoolDemo.java
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-1\. main/src/main/java/threads/ThreadPoolDemo.java
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print a series of lines like the following, showing the threads running
    interspersed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印一系列如下的行，显示交错运行的线程：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that there are several submission methods, the first in the parent interface
    `Executor` and two more in `ExecutorService`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有几种提交方法，第一种在父接口 `Executor` 中，另外两种在 `ExecutorService` 中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That is, `execute()` takes a `Runnable` and returns nothing, whilst the `submit()`
    methods both return a `Future<T>` (for the method `submit(Runnable)`, the type
    parameter `x` is always `java.lang.Void`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`execute()` 接受一个 `Runnable` 并且不返回任何内容，而 `submit()` 方法返回一个 `Future<T>`（对于方法
    `submit(Runnable)`，类型参数 `T` 总是 `java.lang.Void`）。
- en: When you are finished with the thread pool, you should call its `shutDown()`
    method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成线程池的使用时，应该调用它的 `shutDown()` 方法。
- en: 16.2 Displaying a Moving Image with Animation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.2 用动画显示移动图像
- en: Problem
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to update a graphical display while other parts of the program are
    running.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的其他部分运行时，你需要更新图形显示。
- en: Solution
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a background thread to drive the animation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后台线程驱动动画。
- en: Discussion
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: One common use of threads is an animator, a class that displays a moving image.
    This animator program does just that. It draws a graphical image at locations
    around the screen; the location is updated and redrawn from a different `Thread`
    for each such image so that all the animations run in parallel. You can see the
    program running in [Figure 16-1](#javacook-threads-FIG-1).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的一个常见用途是动画程序，它显示一个移动的图像。这个动画程序正是这样做的。它在屏幕上不同位置绘制一个图形图像；每个图像的位置更新并从不同的`Thread`重新绘制，以便所有动画并行运行。您可以在[图 16-1](#javacook-threads-FIG-1)中看到程序的运行情况。
- en: '![jcb4 1601](assets/jcb4_1601.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1601](assets/jcb4_1601.png)'
- en: Figure 16-1\. Animator
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 16-1\. 动画程序
- en: The code for the animator program consists of two classes, `Sprite` (see [Example 16-4](#javacook-threads-EX-4ch22))
    and `Bounce`^([2](ch16.html#idm45290632776280)) (see [Example 16-5](#javacook-threads-EX-5)).
    A `Sprite` is one image that moves around; `Bounce` is the main program.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 动画程序的代码包括两个类，`Sprite`（参见[示例 16-4](#javacook-threads-EX-4ch22)）和`Bounce`^([2](ch16.html#idm45290632776280))（参见[示例 16-5](#javacook-threads-EX-5)）。`Sprite`是一个移动的图像；`Bounce`是主程序。
- en: Example 16-4\. main/src/main/java/threads/Sprite.java (part of animator program)
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-4\. main/src/main/java/threads/Sprite.java（动画程序的一部分）
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example features several uses of the `volatile` keyword. The `volatile`
    keyword is used to inform Java that a variable is subject to change by more than
    one thread, so that its current value must always be fetched when it is used.
    Absent this keyword, it is legal for Java to use a cached version of the given
    variable. That increases performance when a variable is only used in one thread,
    but (without `volatile`) can give incorrect results when the variable is modified
    in one thread and observed in another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了`volatile`关键字的几个用法。`volatile`关键字用于通知Java一个变量可能会被多个线程修改，因此在使用时必须始终获取其当前值。如果没有此关键字，Java可能会使用给定变量的缓存版本。当一个变量只在一个线程中使用时，这样可以提高性能，但（没有`volatile`时）当变量在一个线程中修改并在另一个线程中观察时可能导致不正确的结果。
- en: Example 16-5\. main/src/main/java/threads/Bounce.java (part of animator program)
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-5\. main/src/main/java/threads/Bounce.java（动画程序的一部分）
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 16.3 Stopping a Thread
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.3 停止线程
- en: Problem
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Problem
- en: You need to stop a thread.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要停止一个线程。
- en: Solution
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Don’t use the `Thread.stop()` method; instead, use a `boolean` tested at the
    top of the main loop in the `run()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`Thread.stop()`方法；相反，在`run()`方法的主循环顶部使用一个测试的`boolean`。
- en: Discussion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Though you can use the thread’s `stop()` method, it is not recommended. That’s
    because the method is so drastic that it can never be made to behave reliably
    in a program with multiple active threads. That is why, when you try to use it,
    the compiler will generate deprecation warnings. The recommended method is to
    use a `boolean` variable in the main loop of the `run()` method. The program in
    [Example 16-6](#javacook-threads-EX-6) prints a message endlessly until its `shutDown()`
    method is called; it then sets the controlling variable `done` to false, which
    terminates the loop. This causes the `run()` method to return, ending its processing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用线程的`stop()`方法，但不建议这样做。这是因为这种方法非常激烈，无法在具有多个活动线程的程序中可靠地表现。这也是为什么在尝试使用它时，编译器会生成弃用警告。推荐的方法是在`run()`方法的主循环中使用一个`boolean`变量。[示例 16-6](#javacook-threads-EX-6)中的程序在其`shutDown()`方法被调用后无限打印消息；然后将控制变量`done`设置为false，从而终止循环。这导致`run()`方法返回，结束其处理。
- en: Example 16-6\. main/src/main/java/threads/StopBoolean.java
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-6\. main/src/main/java/threads/StopBoolean.java
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running it looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时看起来像这样：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But what if your thread is blocked reading from a network connection? You then
    cannot check a `boolean`, because the thread that is reading is asleep. This is
    what the `stop` method was designed for, but, as we’ve seen, it is now deprecated.
    Instead, you can simply close the socket. The program shown in [Example 16-7](#javacook-threads-EX-7)
    intentionally deadlocks itself by reading from a socket that you are supposed
    to write to, simply to demonstrate that closing the socket does in fact terminate
    the loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您的线程在读取网络连接时被阻塞呢？此时您无法检查`boolean`，因为正在读取的线程处于休眠状态。这就是`stop`方法的设计初衷，但正如我们所见，它现在已被弃用。相反，您可以简单地关闭套接字。[示例 16-7](#javacook-threads-EX-7)中的程序故意通过从应该写入的套接字读取数据而导致死锁，以演示关闭套接字确实终止了循环。
- en: Example 16-7\. main/src/main/java/threads/StopClose.java
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-7\. main/src/main/java/threads/StopClose.java
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When run, it prints a message that the close is happening:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，它会打印一个关闭正在发生的消息：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: “But wait,” you say. “What if I want to break the wait, but not really terminate
    the socket?” A good question, indeed, and there is no perfect answer. But you
    can *interrupt* the thread that is reading; the read is interrupted by a `java.io.InterruptedIOException`,
    and you can retry the read. The file *Intr.java* in this chapter’s source code
    shows this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “但是等等，”你说。“如果我想中断等待，但实际上不想终止套接字怎么办？”这确实是一个很好的问题，并且没有完美的答案。但是你可以*中断*正在读取的线程；读取会被`java.io.InterruptedIOException`中断，并且您可以重新尝试读取。本章源代码中的文件*Intr.java*展示了这一点。
- en: 16.4 Rendezvous and Timeouts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.4 会合和超时
- en: Problem
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to know whether something finished or whether it finished in a certain
    length of time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道某件事是否已经完成，或者它是否在某个时间长度内完成。
- en: Solution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Start that something in its own thread and call its `join()` method with or
    without a timeout value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将某物置于其自己的线程中，并调用其`join()`方法，可以选择是否设置超时值。
- en: Discussion
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `join()` method of the target thread is used to suspend the current thread
    until the target thread is finished (returns from its `run()` method). This method
    is overloaded; a version with no arguments waits forever for the thread to terminate,
    whereas a version with arguments waits up to the specified time. For a simple
    example, I create (and start!) a simple thread that just reads from the console
    terminal, and the main thread simply waits for it. When I run the program, it
    looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 目标线程的`join()`方法用于暂停当前线程，直到目标线程完成（从其`run()`方法返回）。此方法有多种重载版本；不带参数的版本永远等待线程终止，而带有参数的版本最多等待指定的时间。举个简单的例子，我创建（并启动！）了一个简单的线程，它只是从控制台终端读取内容，而主线程只是等待它。当我运行程序时，它看起来是这样的：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 16-8](#javacook-threads-EX-8) lists the code for the `join()` demo.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-8](#javacook-threads-EX-8)列出了`join()`演示的代码。'
- en: Example 16-8\. main/src/main/java/threads/Join.java
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-8\. main/src/main/java/threads/Join.java
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, it uses an inner class `Runnable` (see [Recipe 16.1](#javacook-threads-SECT-1))
    in `Thread t` to be runnable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它使用了一个内部类`Runnable`（参见[第16.1节](#javacook-threads-SECT-1)）在`Thread t`中可运行。
- en: 16.5 Synchronizing Threads with the synchronized Keyword
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.5 使用`synchronized`关键字同步线程
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to protect certain data from access by multiple threads.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要保护某些数据不被多个线程访问。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `synchronized` keyword on the method or code you wish to protect.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用` synchronized`关键字来保护您希望保护的方法或代码。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: I discussed the `synchronized` keyword briefly in [Recipe 13.5](ch13.html#javacook-netserver-SECT-4).
    This keyword specifies that only one thread at a time is allowed to run the given
    method (or any other synchronized method in the same class) in a given object
    instance (for static methods, only one thread is allowed to run the method at
    a time). You can synchronize methods or smaller blocks of code. It is easier and
    safer to synchronize entire methods, but this can be more costly in terms of blocking
    threads that could run. You can simply add the `synchronized` keyword on the method.
    For example, many of the methods of `Vector` (see [Recipe 7.4](ch07.html#javacook-structure-SECT-3))
    are synchronized in order to ensure that the vector does not become corrupted
    or give incorrect results when two threads update or retrieve from it at the same
    time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第13.5节](ch13.html#javacook-netserver-SECT-4)中简要讨论了`synchronized`关键字。该关键字指定一次只允许一个线程在给定对象实例中运行给定方法（或同一类中的任何其他同步方法）（对于静态方法，一次只允许一个线程运行该方法）。您可以同步方法或更小的代码块。同步整个方法更容易和安全，但这可能会导致阻塞线程更多地运行。您只需在方法上添加`synchronized`关键字。例如，`Vector`的许多方法（参见[第7.4节](ch07.html#javacook-structure-SECT-3)）都是同步的，以确保在两个线程同时更新或检索时，向量不会变得损坏或提供不正确的结果。
- en: 'Bear in mind that threads can be interrupted at almost any time, in which case
    control is given to another thread. Consider the case of two threads appending
    to a data structure at the same time. Let’s suppose we have the same methods as
    `Vector`, but we’re operating on a simple array. The `add()` method simply uses
    the current number of objects as an array index, then increments it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，线程几乎可以在任何时候被中断，在这种情况下，控制权将转移到另一个线程。考虑两个线程同时追加到数据结构的情况。假设我们有与`Vector`相同的方法，但是我们正在操作一个简单的数组。`add()`方法简单地将当前对象数用作数组索引，然后递增它：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Threads A and B both wish to call this method. Suppose that Thread A gets interrupted
    after [![1](assets/1.png)](#co_threaded_java_CO1-1) but before [![2](assets/2.png)](#co_threaded_java_CO1-2),
    and then Thread B gets to run.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 线程A和B都希望调用这个方法。假设线程A在[![1](assets/1.png)](#co_threaded_java_CO1-1)之后被中断，但在[![2](assets/2.png)](#co_threaded_java_CO1-2)之前被中断，然后线程B开始运行。
- en: '[![1](assets/1.png)](#co_threaded_java_CO1-1)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_threaded_java_CO1-1)'
- en: Thread B does [![1](assets/1.png)](#co_threaded_java_CO1-1), overwriting the
    contents of `data[max]`; we’ve now lost all reference to the object that Thread
    A passed in!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 线程B执行[![1](assets/1.png)](#co_threaded_java_CO1-1)，覆盖了`data[max]`的内容；我们现在丢失了线程A传递的对象的所有引用！
- en: '[![2](assets/2.png)](#co_threaded_java_CO1-2)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_threaded_java_CO1-2)'
- en: Thread B then increments `max` at [![2](assets/2.png)](#co_threaded_java_CO1-2)
    and returns. Later, Thread A gets to run again; it resumes at [![2](assets/2.png)](#co_threaded_java_CO1-2)
    and increments `max` past the last valid object. So not only have we lost an object,
    but we have an uninitialized reference in the array. This state of affairs is
    shown in [Figure 16-2](#javacook-threads-FIG-2).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后线程B在[![2](assets/2.png)](#co_threaded_java_CO1-2)处增加`max`并返回。稍后，线程A再次运行；它在[![2](assets/2.png)](#co_threaded_java_CO1-2)处继续，并将`max`增加到最后一个有效对象之外。所以我们不仅丢失了一个对象，而且数组中有一个未初始化的引用。这种情况如图 16-2所示。
- en: '![jcb4 1602](assets/jcb4_1602.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1602](assets/jcb4_1602.png)'
- en: 'Figure 16-2\. Non-thread-safe add method in operation: normal and failed updates'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-2\. 非线程安全的add方法的操作：正常和失败的更新
- en: 'Now you might think, “No problem, I’ll just combine the two lines of code!”:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会想，“没问题，我只需合并这两行代码！”：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As the game show host sometimes says, “Bzzzzt! Thanks for playing!” This change
    makes the code a bit shorter but has absolutely no effect on reliability. Interrupts
    don’t happen conveniently on Java statement boundaries; they can happen between
    any of the many JVM machine instructions that correspond to your program. The
    code can still be interrupted after the store and before the increment. The only
    good solution is to use proper synchronization.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像游戏节目主持人有时会说的那样，“Bzzzzt！谢谢参与！” 这个改变使得代码变得更短，但对可靠性没有任何影响。中断不会方便地发生在Java语句边界；它们可以发生在程序对应的许多JVM机器指令中的任何一个之间。代码仍然可能在存储之后和增量之前被中断。唯一的好解决方案是使用适当的同步。
- en: 'Making the method `synchronized` means that any invocations of it will wait
    if one thread has already started running the method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 方法使用`synchronized`意味着对它的任何调用都将等待，如果一个线程已经开始运行该方法：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any time you wish to synchronize some code, but not an entire method, use the
    `synchronized` keyword on an unnamed code block within a method, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候你希望同步一些代码，但不是整个方法，可以在方法内使用未命名代码块的`synchronized`关键字，就像这样：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The choice of object to synchronize on is up to you. Sometimes it makes sense
    to synchronize on the object containing the code, as in [Example 16-9](#javacook-threads-EX-9).
    For synchronizing access to an `ArrayList`, it would make sense to use the `ArrayList`
    instance, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同步对象的选择由您决定。有时候在包含代码的对象上同步是有意义的，就像在[示例 16-9](#javacook-threads-EX-9)中那样。对于同步访问`ArrayList`，使用`ArrayList`实例是合理的，就像这样：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 16-9](#javacook-threads-EX-9) is a web servlet that I wrote for use
    in the classroom, following a suggestion from fellow Learning Tree instructor
    Scott Weingust.^([3](ch16.html#idm45290630859608)) It lets you play a quiz show
    game of the style where the host asks a question and the first person to press
    their buzzer (buzz in) gets to try to answer the question correctly. To ensure
    against having two people buzz in simultaneously, the code uses a synchronized
    block around the code that updates the `Boolean` `buzzed` variable. And for reliability,
    any code that accesses this `Boolean` is also synchronized.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-9](#javacook-threads-EX-9)是一个Web Servlet，我写了一个用于课堂使用的建议，来自Learning Tree的同事Scott
    Weingust的建议。^([3](ch16.html#idm45290630859608)) 它允许您玩一个类似游戏节目主持人提问并且第一个按下蜂鸣器的人（按蜂鸣器键）尝试回答问题的风格的游戏。为了确保不会同时有两个人按蜂鸣器，代码在更新`Boolean`
    `buzzed`变量的代码周围使用了同步块。而且为了可靠性，任何访问这个`Boolean`的代码也是同步的。'
- en: Example 16-9\. main/src/main/java/threads/BuzzInServlet.java
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-9\. main/src/main/java/threads/BuzzInServlet.java
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Two HTML pages lead to the servlet. The contestant’s page simply has a large
    link (`<a href=/servlet/BuzzInServlet>`). Anchor links generate an HTML GET, so
    the servlet engine calls `doGet()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个HTML页面导致Servlet。参赛者页面简单地有一个大链接（`<a href=/servlet/BuzzInServlet>`）。锚点链接生成HTML
    GET，因此Servlet引擎调用`doGet()`：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The HTML is pretty plain, but it does the job. [Figure 16-3](#javacook-threads-FIG-3)
    shows the look and feel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 很简单，但完成了工作。 [图 16-3](#javacook-threads-FIG-3) 展示了外观和感觉。
- en: '![jcb4 1603](assets/jcb4_1603.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1603](assets/jcb4_1603.png)'
- en: Figure 16-3\. BuzzInServlet in action
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-3\. BuzzInServlet 运行中
- en: The game show host has access to an HTML form with a POST method, which calls
    the `doPost()` method. This displays the winner to the game show host and resets
    the buzzer for the next question.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏主持人可以访问一个具有 POST 方法的 HTML 表单，该方法调用 `doPost()` 方法。这会向游戏主持人显示获胜者并为下一题重置蜂鸣器。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A password is provided; it’s hardcoded here, but in reality the password would
    come from a properties file ([Recipe 7.10](ch07.html#javacook-structure-SECT-7))
    or a servlet initialization parameter (as described in *[Java Servlet Programming](http://shop.oreilly.com/product/9780596000400.do)*
    [O’Reilly]):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个密码；这里是硬编码的，但实际上密码可以来自属性文件（[配方 7.10](ch07.html#javacook-structure-SECT-7)）或
    servlet 初始化参数（如 *[Java Servlet Programming](http://shop.oreilly.com/product/9780596000400.do)*
    [O’Reilly] 中描述的）：
- en: The game show host functionality is shown in [Figure 16-4](#javacook-threads-FIG-4).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏主持人功能显示在 [图 16-4](#javacook-threads-FIG-4) 中。
- en: '![jcb4 1604](assets/jcb4_1604.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1604](assets/jcb4_1604.png)'
- en: Figure 16-4\. BuzzInServlet game show host function
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-4\. BuzzInServlet 游戏主持人功能
- en: For a more complete game, of course, the servlet would keep a `Stack` (see [Recipe
    7.16](ch07.html#javacook-structure-SECT-14)) of people in the order they buzzed
    in, in case the first person doesn’t answer the question correctly. Access to
    this would have to be synchronized, too.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了更完整的游戏体验，Servlet 还会保持一个人们按顺序蜂鸣的 `Stack`（参见 [配方 7.16](ch07.html#javacook-structure-SECT-14)），以防第一个人回答问题不正确。对此的访问也必须进行同步。
- en: 16.6 Simplifying Synchronization with Locks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.6 使用锁简化同步
- en: Problem
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want an easier means of synchronizing threads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望更简单地同步线程。
- en: Solution
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Lock` mechanism in `java.util.concurrent.locks`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.util.concurrent.locks` 中的 `Lock` 机制。
- en: Discussion
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Use the `java.util.concurrent.locks` package; its major interface is `Lock`.
    This interface has several methods for locking and one for unlocking. Here is
    the general pattern for using it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.util.concurrent.locks` 包；其主要接口是 `Lock`。该接口有几种锁定和一种解锁方法。以下是使用它的一般模式：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The point of putting the `unlock()` call in the `finally` block is, of course,
    to ensure that it is not bypassed if an exception occurs (the code may also include
    one or more `catch` blocks, as required by the work being performed).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `unlock()` 调用放在 `finally` 块中的目的当然是确保在发生异常时不会被绕过（代码也可能包含一个或多个 `catch` 块，根据所执行的工作需要）。
- en: The improvement here, compared with the traditional synchronized methods and
    blocks, is that using a `Lock` actually looks like a locking operation! And, as
    I mentioned, several means of locking are available, shown in [Table 16-1](#javacook-threads-TABLE-1).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 synchronized 方法和代码块相比，使用 `Lock` 的改进之处在于它实际上看起来像是一个锁定操作！正如我所提到的，有多种锁定方法可用，如
    [表 16-1](#javacook-threads-TABLE-1) 所示。
- en: Table 16-1\. Locking methods of the Lock class
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-1\. Lock 类的锁定方法
- en: '| Return type | Method | Meaning |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 方法 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| void | `lock( )` | Get the lock, even if you have to wait until another thread
    frees it first |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| void | `lock( )` | 获取锁，即使必须等待直到另一个线程释放它 |'
- en: '| boolean | `tryLock( )` | Get the lock only if it is free right now |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| boolean | `tryLock( )` | 只有在当前锁空闲时才获取锁 |'
- en: '| boolean | `tryLock(long time, TimeUnit units) throws` `InterruptedException`
    | Try to get the lock, but only wait for the length of time indicated |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| boolean | `tryLock(long time, TimeUnit units) throws` `InterruptedException`
    | 尝试获取锁，但只等待指定的时间长度 |'
- en: '| void | `lockInterruptibly( ) throws` `InterruptedException` | Get the lock,
    waiting unless interrupted |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| void | `lockInterruptibly( ) throws` `InterruptedException` | 获取锁，除非被中断否则一直等待
    |'
- en: '| void | `unlock( )` | Release the lock |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| void | `unlock( )` | 释放锁 |'
- en: The `TimeUnit` class lets you specify the units for the amount of time specified,
    including `TimeUnit.SECONDS`, `TimeUnit.MILLISECONDS`, `TimeUnit.MICROSECONDS`,
    and `TimeUnit.NANOSECONDS`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeUnit` 类允许您指定指定时间量的单位，包括 `TimeUnit.SECONDS`、`TimeUnit.MILLISECONDS`、`TimeUnit.MICROSECONDS`
    和 `TimeUnit.NANOSECONDS`。'
- en: In all cases, the lock must be released with `unlock()` before it can be locked
    again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，在再次锁定之前必须使用 `unlock()` 释放锁。
- en: 'The standard `Lock` is useful in many applications, but depending on the application’s
    requirements, other types of locks may be more appropriate. Applications with
    asymmetric load patterns may benefit from a common pattern called the *reader-writer
    lock*; I call this one a readers-writer lock to emphasize that there can be many
    readers but only one writer. It’s actually a pair of interconnected locks; any
    number of readers can hold the read lock and read the data, as long as it’s not
    being written (shared read access). A thread trying to lock the write lock, however,
    waits until all the readers are finished and then locks them out until the writer
    is finished (exclusive write access). To support this pattern, both the `ReadWriteLock`
    interface and the implementing class `ReentrantReadWriteLock` are available. The
    interface has only two methods, `readLock()` and `writeLock()`, which provide
    a reference to the appropriate `Lock` implementation. *These methods do not, in
    themselves, lock or unlock the locks*; they only provide access to them, so it
    is common to see code like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`Lock`在许多应用程序中很有用，但根据应用程序的要求，其他类型的锁可能更合适。具有非对称负载模式的应用程序可能会从一种称为*读写锁*的常见模式中受益；我将其称为读写锁以强调可以有多个读取者但只能有一个写入者。实际上它是一对互联的锁；任意数量的读取者可以持有读锁并读取数据，只要数据不被写入（共享读取访问）。然而，尝试锁定写锁的线程将等待所有读取者完成，然后在写者完成之前将它们锁定（独占写入访问）。为支持此模式，`ReadWriteLock`接口和实现类`ReentrantReadWriteLock`都可用。该接口仅有两个方法，`readLock()`和`writeLock()`，它们提供对适当`Lock`实现的引用。*这些方法本身不会锁定或解锁锁*；它们仅提供对它们的访问，因此通常可以看到像这样的代码：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To demonstrate `ReadWriteLock` in action, I wrote the business logic portion
    of a web-based voting application. It could be used in voting for candidates or
    for the more common web poll. Presuming that you display the results on the home
    page and change the data only when somebody takes the time to click a response
    to vote, this application fits one of the intended criteria for `ReadWriteLock`—that
    is, that you have more readers than writers. The main class, `ReadersWritersDemo`,
    is shown in [Example 16-10](#javacook-threads-EX-10). The helper class `BallotBox`
    is online; it simply keeps track of the votes and returns a read-only `Iterator`
    upon request. Note that in the `run()` method of the reading threads, you could
    obtain the iterator while holding the lock but release the lock before printing
    it; this allows greater concurrency and better performance, but it could (depending
    on your application) require additional locking against concurrent update.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`ReadWriteLock`的实际应用，我编写了基于网络的投票应用程序的业务逻辑部分。它可以用于候选人的投票或更常见的网络投票。假设您在主页上显示结果，并且仅在有人点击投票响应时更改数据，此应用程序符合`ReadWriteLock`的预期标准之一——即您有更多的读取者而不是写入者。主类`ReadersWritersDemo`如示例[Example 16-10](#javacook-threads-EX-10)所示。辅助类`BallotBox`在线上；它简单地跟踪投票并在请求时返回只读的`Iterator`。请注意，在读取线程的`run()`方法中，您可以在持有锁的同时获取迭代器，但在打印之前释放锁；这样可以提高并发性能，但根据您的应用程序可能需要额外的并发更新锁定。
- en: Example 16-10\. main/src/main/java/threads/ReadersWriterDemo.java
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-10\. main/src/main/java/threads/ReadersWriterDemo.java
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because this is a simulation and the voting is random, it does not always come
    out 50/50\. In two consecutive runs, the following were the last line of each
    run:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一次模拟，投票是随机的，所以不总是会得出50/50的结果。在两次连续运行中，以下是每次运行的最后一行：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See Also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Lock` interface also makes available `Condition` objects, which provide
    even more flexibility. Consult the online documentation for more information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口还提供了`Condition`对象，提供了更多的灵活性。有关更多信息，请参阅在线文档。'
- en: 16.7 Simplifying Producer/Consumer with the Queue Interface
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.7 使用队列接口简化生产者/消费者
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to control producer/consumer implementations involving multiple threads.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要控制涉及多个线程的生产者/消费者实现。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Queue` interface or the `BlockingQueue` subinterface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Queue`接口或`BlockingQueue`子接口。
- en: Discussion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As an example of the simplifications possible with the `java.util.Concurrent`
    package, consider the standard producer/consumer program. An implementation synchronized
    using traditional `Thread` code (`wait()` and `notifyAll()`) is in the online
    source as `ProdCons2`. [Example 16-11](#javacook-threads-EX-13), *ProdCons15.java*,
    uses the `java​.util.BlockingQueue` (a subinterface of `java.util.Queue`) to reimplement
    `ProdCons2` in about two-thirds the number of lines of code, and it’s simpler.
    The application simply puts items into a queue and takes them from it. In the
    example, I have four producers and only three consumers, so the producers eventually
    wait. Running the application on one of my older notebooks, the producers’ lead
    over the consumers increases to about 350 over the 10 seconds or so of running
    it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`java.util.Concurrent`包可能带来的简化示例，考虑标准的生产者/消费者程序。使用传统`Thread`代码（`wait()`和`notifyAll()`）同步的实现在在线源代码中称为`ProdCons2`。[示例16-11](#javacook-threads-EX-13)，*ProdCons15.java*，使用`java.util.BlockingQueue`（`java.util.Queue`的子接口）重新实现了`ProdCons2`，代码行数约为其三分之二，而且更简单。该应用程序简单地将项目放入队列中并从中取出。在示例中，我有四个生产者和只有三个消费者，因此生产者最终会等待。在我的一台较旧的笔记本电脑上运行该应用程序，生产者在大约10秒钟的运行时间内超过消费者约350个。
- en: Example 16-11\. main/src/main/java/threads/ProdCons15.java
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例16-11\. main/src/main/java/threads/ProdCons15.java
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ProdCons15` is superior to `ProdCons2` in almost all aspects. However, the
    queue sizes that are output no longer necessarily exactly reflect the size of
    the queue after the object is inserted or removed. Because there’s no longer any
    locking ensuring atomicity here, any number of queue operations could occur on
    other threads between the `Producer` thread’s `queue.put()` and the `Consumer`
    thread’s queue size query.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProdCons15`在几乎所有方面都优于`ProdCons2`。然而，输出的队列大小不再必然准确反映对象插入或移除后队列的大小。因为这里不再有任何锁定来确保原子性，在`Producer`线程的`queue.put()`和`Consumer`线程的队列大小查询之间，其他线程可以执行任意数量的队列操作。'
- en: 16.8 Optimizing Parallel Processing with Fork/Join
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.8 使用Fork/Join优化并行处理
- en: Problem
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to optimize use of multiple processors and/or large problem spaces.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要优化多处理器和/或大问题空间的使用。
- en: Solution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Fork/Join framework.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fork/Join框架。
- en: Discussion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Fork/Join is an `ExecutorService` intended mainly for reasonably large tasks
    that can naturally be divided recursively, where you don’t have to ensure equal
    timing for each division. It uses work-stealing to keep threads busy.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join是一个主要用于可以自然递归地划分的相当大的任务的`ExecutorService`，在这里，您不必确保每个划分的时间相等。它使用工作窃取来使线程保持繁忙。
- en: 'The basic means of using Fork/Join is to extend `RecursiveTask` or `RecursiveAction`
    and override its `compute()` method along these lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fork/Join的基本方法是扩展`RecursiveTask`或`RecursiveAction`并根据这些行覆盖其`compute()`方法：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are two classes: `RecursiveTask` and `RecursiveAction`. The main difference
    is that `RecursiveTask` has each step of the work returning a value, whereas `RecursiveAction`
    does not. In other words, the `RecursiveAction` method `compute()` has a return
    type of void, whereas the `RecursiveAction` method of the same name has a return
    type of `T`, some type parameter. You might use `RecursiveTask` when each call
    returns a value that represents the computation for its subset of the overall
    task, in other words, to divide a problem like summarizing data—each task would
    summarize one part and return that. You might use `RecursiveAction` to operate
    over a large data structure performing some transform of the data in place.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个类：`RecursiveTask`和`RecursiveAction`。主要区别在于`RecursiveTask`的每个工作步骤都返回一个值，而`RecursiveAction`则不返回。换句话说，`RecursiveAction`方法`compute()`的返回类型为`void`，而具有相同名称的`RecursiveTask`方法的返回类型为`T`，某些类型参数。当每次调用返回代表其总体任务子集的计算的值时，您可能会使用`RecursiveTask`，换句话说，要划分像汇总数据这样的问题—每个任务将汇总一部分并返回该部分。您可能会使用`RecursiveAction`来操作大型数据结构，在原地执行数据的某种变换。
- en: 'There are two demos of the Fork/Join framework here, named after the `ForkJoinTask`
    that each subclasses:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个Fork/Join框架的演示，命名为每个子类的`ForkJoinTask`：
- en: '`RecursiveTaskDemo` uses `fork()` and `join()` directly.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecursiveTaskDemo`直接使用`fork()`和`join()`。'
- en: '`RecursiveActionDemo` uses `invokeAll()` to invoke the two subtasks. `invoke()`
    is just a `fork()` and a `join()`; and `invokeAll()` just does this repeatedly
    until done. Compare the versions of `compute()` in Examples [16-12](#javacook-threads-forkjoin-recursiveActionDemo)
    and [16-13](#javacook-threads-forkjoin-recursiveTaskDemo) and this will make sense.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecursiveActionDemo`使用`invokeAll()`来调用两个子任务。`invoke()`只是一个`fork()`和一个`join()`；而`invokeAll()`只是重复执行这个过程直到完成。比较示例[16-12](#javacook-threads-forkjoin-recursiveActionDemo)和[16-13](#javacook-threads-forkjoin-recursiveTaskDemo)中的`compute()`版本，这将会让您明白。'
- en: Example 16-12\. main/src/main/java/threads/RecursiveActionDemo.java
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-12\. 主要/src/main/java/threads/RecursiveActionDemo.java
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 16-13\. main/src/main/java/threads/RecursiveTaskDemo.java
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-13\. 主要/src/main/java/threads/RecursiveTaskDemo.java
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The biggest undefined part there is “small enough”; you may have to do some
    experimentation to see what works well as a chunk size. Or, better yet, write
    more code using a feedback control system, measuring the system throughput as
    the parameter is dynamically tweaked up and down, and have the system automatically
    arrive at the optimal value for that particular computer system and runtime. This
    is left as an extended exercise for the reader.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的未定义部分是“足够小的”；您可能需要进行一些实验，看看什么大小的块效果最好。或者，更好的做法是，编写更多使用反馈控制系统的代码，当动态调整参数时，测量系统吞吐量，并使系统自动达到特定计算机系统和运行时的最佳值。这留给读者作为扩展练习。
- en: '16.9 Scheduling Tasks: Future Times, Background Saving in an Editor'
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.9 定时任务：未来时间，编辑器中的后台保存
- en: Problem
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to schedule something for a fixed time in the future. You need to save
    the user’s work periodically in an interactive program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在将来的固定时间安排某些事情。您需要定期保存用户的工作在交互式程序中。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For one-shot future tasks, use the `Timer` service with a `TimerTask` object.
    For recurring tasks, either use a background thread, or use the `Timer` service
    and recompute the next time. For more complex tasks, such as running something
    at high noon every second Thursday, consider using a third-party scheduling library
    such as [Quartz](http://www.quartz-scheduler.org) or, in JavaEE/Jakarta, the [EJB
    Timer Service](https://eclipse-ee4j.github.io/jakartaee-tutorial/ejb-basicexamples005.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性的将来任务，请使用`Timer`服务和`TimerTask`对象。对于循环任务，可以使用后台线程，或使用`Timer`服务并重新计算下一次时间。对于更复杂的任务，比如每个第二个星期四的正午运行某些内容，请考虑使用第三方调度库，例如[Quartz](http://www.quartz-scheduler.org)，或在JavaEE/Jakarta中使用[EJB定时器服务](https://eclipse-ee4j.github.io/jakartaee-tutorial/ejb-basicexamples005.html)。
- en: Discussion
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are several ways of scheduling things in the future. For one-shot scheduling,
    you can use the `Timer` service from `java.util`. For recurring tasks, you can
    use a `Runnable`, which sleeps in a loop.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以安排将来的事情。对于一次性安排，您可以使用`java.util`中的`Timer`服务。对于循环任务，您可以使用一个`Runnable`，它在循环中睡眠。
- en: 'Here is an example of the `Timer` service in `java.util`. These are the basics
    of using this API:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`java.util`中`Timer`服务的示例。这些是使用此API的基础知识：
- en: Create a `Timer` service object.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Timer`服务对象。
- en: Use it to schedule instances of `TimerTask` with a legacy `Date` object indicating
    the date and time.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来安排`TimerTask`实例，其中包含指示日期和时间的传统`Date`对象。
- en: 'The example code in [Example 16-14](#javacook-CHAPTER-EX-ReminderService) uses
    `Item` as a subclass of `TimerTask` to perform a simple notification action in
    the future, based on reading lines with `year-month-day-hour-minute Task`, such
    as the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码在[示例 16-14](#javacook-CHAPTER-EX-ReminderService)中使用`Item`作为`TimerTask`的子类，以便基于读取具有`年-月-日-小时-分钟
    任务`格式的行执行简单的通知操作。
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 16-14\. main/src/main/java/threads/ReminderService.java
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-14\. 主要/src/main/java/threads/ReminderService.java
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In real life the program would need to run for long periods of time and use
    some more sophisticated messaging pattern; here we only show the timing scheduling
    portion.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，程序需要长时间运行，并使用一些更复杂的消息模式；这里我们只显示定时调度部分。
- en: The code fragment in [Example 16-15](#javacook-CHAPTER-EX-AutoSave) creates
    a background thread to handle background saves, as in most word processors.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-15\. 创建一个后台线程来处理后台保存，如大多数文字处理器中所示。
- en: Example 16-15\. main/src/main/java/threads/ReminderService.java
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-15\. 主要/src/main/java/threads/ReminderService.java
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the `run()` method, this code sleeps for five minutes (300
    seconds), then checks whether it should do anything. If the user has turned autosave
    off, or hasn’t made any changes since the last save, nothing needs to be done.
    Otherwise, we call the `saveFile()` method in the main program, which saves the
    data to the current file. It would be smarter to save it to a recovery file of
    some name, as the better word processors do.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在`run()`方法中所看到的，这段代码会休眠五分钟（300秒），然后检查是否需要执行任何操作。如果用户已关闭自动保存功能，或者自上次保存以来未做任何更改，则不需要执行任何操作。否则，我们会在主程序中调用`saveFile()`方法，将数据保存到当前文件中。最好将其保存到某个恢复文件中，就像更好的文字处理器所做的那样。
- en: What’s not shown is that now all the methods must be synchronized. It’s easy
    to see why if you think about how the save method would work if the user clicked
    the Save button at the same time that the autosave method called it, or if the
    user clicked Exit while the file save method had just opened the file for writing.
    The strategy of saving to a recovery file gets around some of this, but it still
    needs a great deal of care.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显示的是现在所有方法都必须是同步的。如果考虑用户在自动保存方法调用它时同时点击了保存按钮，或者在文件保存方法刚打开文件准备写入时用户点击了退出按钮，就很容易明白为什么要这样做。将数据保存到恢复文件的策略可以解决部分问题，但仍需要极大的注意。
- en: See Also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For details on `java.util.concurrent`, see the documentation accompanying the
    JDK. For background on JSR 166, see [Doug Lea’s home page](http://gee.cs.oswego.edu)
    and his [JSR 166 page](http://gee.cs.oswego.edu/dl/concurrency-interest/index.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`java.util.concurrent`的详细信息，请参阅随JDK附带的文档。有关JSR 166的背景，请参阅[Doug Lea的主页](http://gee.cs.oswego.edu)及其[JSR
    166页面](http://gee.cs.oswego.edu/dl/concurrency-interest/index.html)。
- en: A great reference on Java threading is *Java Concurrency in Practice* by Brian
    Goetz et al. (Addison-Wesley).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于Java多线程的极好参考书是《Java Concurrency in Practice》（Brian Goetz等人著，Addison-Wesley出版）。
- en: '[Project Loom: Fibers and Continuations](https://wiki.openjdk.java.net/display/loom/Main)
    aims to promote easier-to-use, lighter-weight concurrency mechanisms.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[Project Loom: Fibers and Continuations](https://wiki.openjdk.java.net/display/loom/Main)旨在推广更易于使用、轻量级的并发机制。'
- en: ^([1](ch16.html#idm45290633711352-marker)) JSR stands for Java Specification
    Request. The Java Community Process calls standards, both proposed and adopted,
    JSRs. See [*http://www.jcp.org*](http://www.jcp.org) for details.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.html#idm45290633711352-marker)) JSR代表Java规范请求。Java社区流程将提议和采纳的标准称为JSR。详情请见[*http://www.jcp.org*](http://www.jcp.org)。
- en: ^([2](ch16.html#idm45290632776280-marker)) The title belies some unfulfilled
    ambitions to make the animations follow the bouncing curves seen in some flashier
    animation demonstrations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch16.html#idm45290632776280-marker)) 标题掩盖了一些未实现的野心，即使在一些更花哨的动画演示中看到的反弹曲线也无法实现。
- en: ^([3](ch16.html#idm45290630859608-marker)) A *servlet* is a low-level server-side
    API for interacting with remote clients; today it would probably be written in
    the form of a JavaServer Faces (JSF) handler.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch16.html#idm45290630859608-marker)) 一个*servlet*是用于与远程客户端交互的低级服务器端API；今天可能会以JavaServer
    Faces (JSF)处理程序的形式编写。
