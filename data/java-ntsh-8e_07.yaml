- en: Chapter 6\. Java’s Approach to Memory and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。Java 对内存和并发的处理方式
- en: 'This chapter is an introduction to the handling of concurrency (multithreading)
    and memory in the Java platform. These topics are inherently intertwined, so it
    makes sense to treat them together. We will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是介绍 Java 平台中的并发（多线程）和内存处理的入门。这些主题本质上是相互交织在一起的，因此将它们一起处理是有意义的。我们将涵盖以下内容：
- en: Introduction to Java’s memory management
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 内存管理简介
- en: The basic mark-and-sweep garbage collection (GC) algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的标记-清除垃圾收集（GC）算法
- en: How the HotSpot JVM optimizes GC according to the lifetime of the object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HotSpot JVM 如何根据对象的生命周期优化 GC
- en: Java’s concurrency primitives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的并发原语
- en: Data visibility and mutability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的可见性和可变性
- en: Basic Concepts of Java Memory Management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 内存管理的基本概念
- en: In Java, the memory occupied by an object is automatically reclaimed when the
    object is no longer needed. This is done through a process known as *garbage collection*
    (or GC). Garbage collection is a technique that has been around for years and
    was pioneered by languages such as Lisp. It takes some getting used to for those
    programmers accustomed to languages such as C and C++, in which you must call
    the `free()` function or the `delete` operator to reclaim memory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，当不再需要对象时，对象所占用的内存会自动释放。这是通过一种称为 *垃圾收集*（或 GC）的过程来完成的。垃圾收集是一种已经存在多年的技术，由诸如
    Lisp 等语言率先采用。对于那些习惯于诸如 C 和 C++ 之类的语言，在其中必须调用 `free()` 函数或 `delete` 运算符来回收内存的程序员来说，这需要一些适应。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that you don’t need to remember to destroy every object you create
    is one of the features that makes Java a pleasant language to work with. It is
    also one of the features that makes programs written in Java less prone to bugs
    than those written in languages that don’t support automatic garbage collection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要记住销毁每个创建的对象的事实是使 Java 成为一种愉快的工作语言的特性之一。这也是使用 Java 编写的程序比那些不支持自动垃圾收集的语言编写的程序更不容易出现错误的特性之一。
- en: Different VM implementations handle garbage collection in different ways, and
    the specifications do not impose very stringent restrictions on how GC must be
    implemented. Later in this chapter, we will discuss the HotSpot JVM (which is
    the basis of both the Oracle and OpenJDK implementations of Java). Although this
    is not the only JVM that you may encounter, it is by far the most common among
    server-side deployments and provides the reference example of a modern production
    JVM.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的虚拟机实现以不同的方式处理垃圾收集，并且规范对GC的实现没有很严格的限制。在本章的后面，我们将讨论 HotSpot JVM（这是 Oracle 和
    OpenJDK Java 实现的基础）。尽管这不是你可能会遇到的唯一的 JVM，但它在服务器端部署中是最常见的，并提供了现代生产 JVM 的参考示例。
- en: Memory Leaks in Java
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 中的内存泄漏
- en: The fact that Java supports garbage collection dramatically reduces the incidence
    of *memory leaks*. A memory leak occurs when memory is allocated and never reclaimed.
    At first glance, it might seem that garbage collection prevents all memory leaks
    because it reclaims all unused objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持垃圾收集的事实大大降低了 *内存泄漏* 的发生率。内存泄漏是指分配了内存但从未释放的情况。乍一看，似乎垃圾收集可以防止所有内存泄漏，因为它回收了所有未使用的对象。
- en: 'A memory leak can still occur in Java, however, if a valid (but unused) reference
    to an unused object is left hanging around. For example, when a method runs for
    a long time (or forever), the local variables in that method can retain object
    references much longer than they are actually required. The following code illustrates:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Java 中，如果对未使用的对象保留了一个有效的（但未使用的）引用，仍然可能发生内存泄漏。例如，当一个方法运行了很长时间（或永远）时，该方法中的局部变量可能会比实际需要的时间长保留对象引用。以下代码为例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Memory leaks can also occur when you use a `HashMap` or similar data structure
    to associate one object with another. Even when neither object is required anymore,
    the association remains in the map, preventing the objects from being reclaimed
    until the map itself is reclaimed. If the map has a substantially longer lifetime
    than the objects it holds, this can cause memory leaks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `HashMap` 或类似的数据结构将一个对象与另一个对象关联起来时，也可能会发生内存泄漏。即使这两个对象都不再需要，关联仍然存在于映射中，直到映射本身被回收。如果映射的寿命远远长于它所持有的对象，这可能会导致内存泄漏。
- en: Introducing Mark-and-Sweep
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍标记-清除算法
- en: Java GC typically relies on an algorithm from a family broadly known as *mark-and-sweep*.
    To understand these algorithms, recall that all Java objects are created in the
    heap, and a reference (basically a pointer) to them is stored in a Java local
    variable (or field) when an object is created. Local variables live in the method’s
    stack frame, and if an object is returned from a method, then the reference is
    passed back to the caller’s stack frame when the method exits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java GC通常依赖于被广泛称为*标记-清除*的算法家族。要理解这些算法，回顾一下所有Java对象都是在堆中创建的，当对象创建时，一个引用（基本上是指针）存储在Java局部变量（或字段）中。局部变量存在于方法的堆栈帧中，如果一个对象从方法中返回，那么当方法退出时，引用将传回调用者的堆栈帧。
- en: As all objects are allocated in the heap, GC will trigger when the heap gets
    full (or before, depending on the details). The basic idea of mark-and-sweep is
    to *trace* the heap and identify which objects are still in use. This can be done
    by examining the stack frames of each Java thread (and a few other sources of
    references) and following any references into the heap. Each object located is
    *marked* as still alive and can then be checked to see if it has any fields that
    are of reference type. If so, these references can be traced and marked as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有对象都分配在堆中，当堆变满时（或者在细节上取决之前），GC将会触发。标记-清除的基本思想是*追踪*堆并确定哪些对象仍在使用中。这可以通过检查每个Java线程的堆栈帧（以及一些其他引用来源）并跟随任何引用到堆中来完成。定位到的每个对象都会被*标记*为仍然存活，并且随后可以检查它是否具有任何引用类型的字段。如果有，这些引用也可以被跟踪和标记。
- en: When the recursive tracing activity has completed, all remaining unmarked objects
    are known to be no longer needed and the heap space they occupy can be *swept*
    as garbage, i.e., the memory they used is reclaimed to use in further object allocations.
    If this analysis can be carried out exactly, then this type of collector is known,
    unsurprisingly enough, as an *exact garbage collector*. For all practical purposes,
    all Java GCs can be considered to be exact, but this may not be true in other
    software environments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归跟踪活动完成时，所有剩余的未标记对象都被认为不再需要，并且它们占据的堆空间可以作为垃圾进行*清除*，即，它们使用的内存可以用于进一步的对象分配。如果此分析可以精确执行，那么这种类型的收集器被称为*精确垃圾收集器*，这并不奇怪。在所有实际目的上，所有Java
    GC都可以被认为是精确的，但在其他软件环境中可能并非如此。
- en: In a real JVM, there will very likely be different areas of heap memory, and
    real programs will use all of them in normal operation. In [Figure 6-1](#javanut8-CHP-6-FIG-1)
    we show one possible layout of the heap, with two threads (T1 and T2) holding
    references that point into the heap.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的JVM中，堆内存很可能会有不同的区域，并且真实的程序将在正常操作中使用它们全部。在[图 6-1](#javanut8-CHP-6-FIG-1)中，我们展示了堆的一个可能布局，其中两个线程（T1和T2）持有指向堆的引用。
- en: The different areas are called *Eden*, *Survivor* and *Tenured*; we’ll meet
    each of these later in the chapter and see how they relate to each other. For
    the sake of simplicity, the figures show an older form of the Java heap, where
    each memory area is a single lump of memory. Modern collectors don’t actually
    lay objects out this way, but it’s easier to understand by thinking about it this
    way first!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的区域被称为*伊甸园*、*幸存者*和*老年代*；我们稍后将在本章中了解每一个区域及其彼此之间的关系。为了简单起见，图示展示了Java堆的旧形式，其中每个内存区域是一个单一的内存块。现代的收集器实际上并不是这样布置对象的，但首先这样考虑会更容易理解！
- en: '![JN7 0601](assets/jns8_0601.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0601](assets/jns8_0601.png)'
- en: Figure 6-1\. Heap structure
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 堆结构
- en: The figure also shows that it would be dangerous to move objects that application
    threads have references to while the program is running.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图中还显示，在程序运行时移动应用线程引用的对象将是危险的。
- en: To avoid this, a simple tracing GC like the one just described will cause a
    *stop-the-world* (STW) pause when it runs. This works because all application
    threads are stopped, then GC occurs, and finally application threads are started
    up again. The runtime takes care of this by halting application threads as they
    reach a *safepoint*—for example, the start of a loop or just before a method call
    returns. At these execution points, the runtime knows that it can stop an application
    thread without a problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，像刚才描述的简单追踪GC将在运行时导致*停顿*（STW）。这是因为所有应用程序线程都被停止，然后进行GC，最后再次启动应用程序线程。运行时通过在达到*安全点*时停止应用程序线程来处理此问题——例如，循环开始或方法调用返回之前。在这些执行点上，运行时知道可以停止应用程序线程而没有问题。
- en: These pauses sometimes worry developers, but for most mainstream usages, Java
    is running on top of an operating system (and possibly multiple virtualization
    layers) that is constantly swapping processes on and off processor cores, so this
    slight additional stoppage is usually not a concern. In the HotSpot case, a large
    amount of work has been done to optimize GC and to reduce STW times, for those
    cases where it is important to an application’s workload. We will discuss some
    of those optimizations in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些暂停有时会让开发人员担心，但对于大多数主流用途来说，Java运行在一个不断在处理器核心上交换进程的操作系统（可能还有多个虚拟化层）上，因此这种轻微的额外停顿通常不是一个问题。在HotSpot情况下，已经做了大量工作来优化GC并减少STW时间，对于那些对应用程序工作负载重要的情况。我们将在下一节讨论其中的一些优化。
- en: How the JVM Optimizes Garbage Collection
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM 如何优化垃圾收集
- en: The *weak generational hypothesis* (WGH) is a great example of one of the runtime
    facts about software that we introduced in [Chapter 1](ch01.xhtml#javanut8-CHP-1).
    Simply put, it is that objects tend to have one of a small number of possible
    life expectancies (referred to as *generations*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*弱分代假设*（WGH）是我们在[第1章](ch01.xhtml#javanut8-CHP-1)中介绍的关于软件的运行时事实的一个很好的例子。简单来说，对象倾向于具有少数几种可能的寿命期望（称为*代*）。'
- en: Usually objects are alive for only a very short amount of time (sometimes called
    transient objects) and then become eligible for garbage collection. However, some
    small fraction of objects live longer and are destined to become part of the longer-term
    state of the program (sometimes referred to as the *working set*). This can be
    seen in [Figure 6-2](#javanut8-CHP-6-FIG-2) where we see volume of memory (or
    number of objects created) plotted against expected lifetime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常对象只存活了很短的时间（有时称为瞬态对象），然后就变得符合垃圾回收的条件。然而，有一小部分对象存活时间较长，注定成为程序长期状态的一部分（有时称为*工作集*）。这可以在[图 6-2](#javanut8-CHP-6-FIG-2)中看到，我们看到内存量（或创建的对象数）根据预期生命周期进行了绘制。
- en: '![JN7 0602](assets/jns8_0602.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0602](assets/jns8_0602.png)'
- en: Figure 6-2\. Weak generational hypothesis
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 弱分代假设
- en: This fact is not deducible from static analysis of programs, and yet when we
    measure the runtime behavior of software, we see that it is broadly true across
    a wide range of workloads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实无法从程序的静态分析中推断出来，然而当我们测量软件的运行时行为时，我们看到这在广泛的工作负载范围内都是正确的。
- en: The HotSpot JVM has a garbage collection subsystem that is designed specifically
    to take advantage of the weak generational hypothesis, and in this section, we
    will discuss how these techniques apply to short-lived objects (which is the majority
    case). This discussion is directly applicable to HotSpot, but other JVMs often
    employ similar or related techniques.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot JVM有一个专门设计用于利用弱分代假设的垃圾收集子系统，在本节中，我们将讨论这些技术如何适用于短寿命对象（这是主要情况）。这个讨论直接适用于HotSpot，但其他JVM通常也采用类似或相关的技术。
- en: In its simplest form, a *generational garbage collector* is one that takes notice
    of the WGH. They take the position that some extra bookkeeping to monitor memory
    will be more than paid for by gains obtained by being friendly to the WGH. In
    the simplest forms of generational collector, there are usually just two generations—usually
    referred to as young and old generation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，*分代垃圾收集器*是一种注意到**WGH**的收集器。他们认为，通过监视内存的一些额外记录，将会比通过友好对待**WGH**而获得的收益更加有利。在最简单的分代收集器中，通常只有两代——通常被称为年轻代和老年代。
- en: Evacuation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 疏散
- en: In our original formulation of mark-and-sweep, during the cleanup phase, the
    GC reclaimed individual objects for reuse. This is fine, as far as it goes, but
    it leads to issues such as memory fragmentation and the GC needing to maintain
    a “free list” of memory blocks that are available. However, if the WGH is true,
    and on any given GC cycle most objects are dead, then it may make sense to use
    an alternative approach to reclaiming space.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初的标记-清除方法中，在清理阶段，GC回收了个别对象以便重用。这在某种程度上是可以接受的，但会导致内存碎片化以及GC需要维护一个可用的“空闲列表”内存块。然而，如果WGH成立，并且在任何给定的GC周期中大多数对象都是死的，那么使用替代方法来回收空间可能是有意义的。
- en: This works by dividing the heap up into separate memory spaces; new objects
    are created in a space called *Eden*. Then, on each GC run, we locate only the
    live objects and move them to a different space, in a process called *evacuation*.
    Collectors that do this are referred to as *evacuating collectors*, and they have
    the property that the entire memory space can be wiped at the end of the collection,
    to be reused again and again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过将堆划分为不同的内存空间来实现；新对象在*Eden*空间创建。然后，在每次GC运行时，我们仅定位活动对象并将它们移动到不同的空间，这个过程称为*evacuation*。执行这种操作的收集器称为*evacuating
    collectors*，它们的特性是在收集结束时可以清空整个内存空间，以便重复使用。
- en: '[Figure 6-3](#javanut8-CHP-6-FIG-3) shows an evacuating collector in action,
    with solid blocks representing surviving objects, and hatched boxes representing
    allocated but now dead (and unreachable) objects.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#javanut8-CHP-6-FIG-3)展示了一个正在运行的evacuating collector，实心块表示存活对象，而斜线框表示已分配但已经死亡（且不可达）的对象。'
- en: '![JN7 0603](assets/jns8_0603.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0603](assets/jns8_0603.png)'
- en: Figure 6-3\. Evacuating collectors
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3\. 疏散收集器
- en: This is potentially much more efficient than the naive collection approach,
    because the dead objects are never touched. This means that the GC time is proportional
    to the number of live objects, rather than the number of allocated objects. The
    only downside is slightly more bookkeeping—we have to pay the cost of copying
    the live objects, but this is almost always a very small price compared to the
    huge gains realized by evacuation strategies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这比朴素的收集方法潜在地更高效，因为不会触及死亡对象。这意味着GC时间与活动对象的数量成正比，而不是已分配对象的数量。唯一的缺点是略微增加的簿记成本——我们必须支付复制活动对象的成本，但这几乎总是与通过疏散策略实现的巨大收益相比微不足道。
- en: The use of an evacuating collector also allows the use of per-thread allocation.
    This means that each application thread can be given a contiguous chunk of memory
    (called a *thread-local allocation buffer* or TLAB) for its exclusive use when
    allocating new objects. When new objects are allocated, this just involves bumping
    a pointer in the allocation buffer, an extremely cheap operation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用疏散收集器还允许使用每线程分配。这意味着每个应用程序线程可以被分配一个连续的内存块（称为*thread-local allocation buffer*或TLAB），用于分配新对象时的独占使用。当分配新对象时，只需在分配缓冲区中递增指针，这是一个极其廉价的操作。
- en: If an object is created just before a collection starts, then it will not have
    time to fulfill its purpose and die before the GC cycle starts. In a collector
    with only two generations, this short-lived object will be moved into the long-lived
    region, die almost immediately, and then stay there until the next full collection.
    As these are a lot less frequent (and typically a lot more expensive), this seems
    rather wasteful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象在收集开始前刚创建，那么它将没有时间完成其目的并在GC周期开始之前死亡。在只有两个代的收集器中，这种短寿命对象将被移动到长寿命区域，几乎立即死亡，并在下一次完全收集之前一直保留在那里。由于这些收集事件较少（通常也更昂贵），这显得相当浪费。
- en: To mitigate this, HotSpot has a concept of a *survivor space*, an area used
    to house objects that have survived previous collections of young objects. A surviving
    object is copied by the evacuating collector between survivor spaces until a *tenuring
    threshold* is reached, when the object will be *promoted* to the old generation,
    known as *Tenured* or *OldGen*. This solves the problem of short-lived objects
    cluttering up the old generation, at the cost of more complexity in the GC subsystem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，HotSpot引入了*survivor space*的概念，用于存放已经经历过前几次年轻对象收集的对象。存活的对象在*tenuring
    threshold*达到之前会在survivor spaces之间被疏散收集器复制，当对象被*promoted*到老年代时，称为*Tenured*或*OldGen*。这解决了短寿命对象堆积在老年代的问题，但也增加了GC子系统的复杂性。
- en: Compaction
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: A different form of collection algorithm is known as a *compacting collector*.
    The main feature of these collectors is that, at the end of the collection cycle,
    allocated memory (i.e., surviving objects) is arranged as a single contiguous
    area within the collected region.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种收集算法形式称为*compacting collector*。这些收集器的主要特点是，在收集周期结束时，分配的内存（即存活对象）被安排在收集区域内的单一连续区域中。
- en: The normal case is that all the surviving objects have been “shuffled up” within
    the memory pool (or region) usually to the start of the memory range, and there
    is now a pointer indicating the start of empty space available for objects to
    be written into once application threads restart.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下，所有存活对象都已经在内存池（或区域）内“洗牌”到了内存范围的开始位置，现在有一个指针指示可供应用程序线程重新启动后写入对象的空闲空间的开始位置。
- en: Compacting collectors will avoid memory fragmentation but typically are much
    more expensive in terms of amount of CPU consumed than evacuating collectors.
    There are design trade-offs between the two algorithms (the details of which are
    beyond the scope of this book), but both techniques are used in production collectors
    in Java (and in many other programming languages). The space where long-lived
    objects end up is typically cleaned using a compacting collector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩收集器将避免内存碎片化，但在消耗CPU量方面通常比疏散收集器昂贵得多。这两种算法之间存在设计权衡（其细节超出本书的范围），但这两种技术都在Java（以及许多其他编程语言的）生产收集器中使用。长期存活对象最终进入的空间通常使用压缩收集器进行清理。
- en: A full discussion of the details of the GC subsystem is outside the scope of
    this book. For production applications that have to care about these details,
    specialist material such as [*Optimizing Java*](http://shop.oreilly.com/product/0636920121718.do)
    (O’Reilly) should be consulted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不讨论GC子系统的详细细节。对于需要关心这些细节的生产应用程序，应当查阅专业材料，比如[*优化Java*](http://shop.oreilly.com/product/0636920121718.do)（O'Reilly）。
- en: The HotSpot Heap
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HotSpot堆
- en: The HotSpot JVM is a relatively complex piece of code, made up of an interpreter
    and a just-in-time compiler, as well as a user-space memory management subsystem.
    It is composed of a mixture of C, C++, and a fairly large amount of platform-specific
    assembly code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot JVM是一个相对复杂的代码片段，由解释器和即时编译器组成，以及一个用户空间内存管理子系统。它由C、C++以及相当大量的平台特定的汇编代码组成。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: HotSpot manages the JVM heap itself, more-or-less completely in user space,
    and does not need to perform system calls to allocate or free memory. The area
    where objects are initially created is usually called Eden (or the Nursery), and
    most production JVMs will use an evacuating strategy when collecting Eden.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot管理JVM堆本身，基本上完全在用户空间中进行，并且不需要执行系统调用来分配或释放内存。对象最初创建的区域通常称为Eden（或者Nursery），大多数生产JVM都会在收集Eden时使用疏散策略。
- en: 'At this point, let’s summarize our description of the HotSpot heap and recap
    its basic features:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下HotSpot堆的描述，并回顾其基本特性：
- en: The Java heap is a contiguous block of memory, which is reserved at JVM startup.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java堆是JVM启动时预留的连续内存块。
- en: Only some of the heap is initially allocated to the various memory pools.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一部分堆最初分配给各种内存池。
- en: As the application runs, memory pools are resized as needed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序运行时，内存池会根据需要调整大小。
- en: These resizes are performed by the GC subsystem.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些调整由GC子系统执行。
- en: Objects are created in Eden by application threads and are removed by a nondeterministic
    GC cycle.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象由应用程序线程在Eden中创建，并在非确定性GC周期中删除。
- en: The GC cycle runs when necessary (i.e., when memory is getting low).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时（即内存紧张时），GC周期会运行。
- en: The heap is divided into two generations, young and old.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆分为两代，年轻代和老年代。
- en: The young generation is made up of Eden and survivor spaces, whereas the old
    generation is just one memory space.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年轻代由Eden和幸存者空间组成，而老年代只是一个内存空间。
- en: After surviving several GC cycles, objects get promoted to the old generation.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过几个GC周期后，对象会晋升到老年代。
- en: Collections that collect only the young generation are usually very cheap (in
    terms of computation required).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只收集年轻代的集合通常非常廉价（就所需计算而言）。
- en: HotSpot uses an advanced form of mark-and-sweep and is prepared to do extra
    bookkeeping to improve GC performance.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HotSpot使用一种高级形式的标记-清除，并准备额外的簿记以提高GC性能。
- en: 'When discussing garbage collectors, developers should know one other important
    terminology distinction:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论垃圾收集器时，开发人员应了解另一个重要的术语区分：
- en: Parallel collector
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并行收集器
- en: A garbage collector that uses multiple threads to perform collection
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个垃圾收集器可以使用多个线程执行收集。
- en: Concurrent collector
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并发收集器
- en: A garbage collector that can run at the same time as application threads are
    still running
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个垃圾收集器可以在应用程序线程运行时同时运行。
- en: In the discussion so far, the collection algorithms we have been describing
    have implicitly all been parallel, but not concurrent, collectors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述的收集算法隐含地都是并行的，但不是并发的收集器。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In modern approaches to GC, there is a growing trend toward using partially
    concurrent algorithms. These types of algorithms are much more elaborate and computationally
    expensive than STW algorithms and involve trade-offs. However, today’s applications
    are typically willing to trade some extra computation for reduced application
    pauses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代GC方法中，越来越多地采用部分并发算法的趋势。这些类型的算法比STW算法更为复杂且计算成本更高，并涉及权衡。然而，今天的应用程序通常愿意为减少应用程序暂停而进行一些额外的计算。
- en: 'In legacy Java versions (version 8 and older), the heap has a simple structure:
    each memory pool (Eden, survivor spaces, and Tenured) is a contiguous block of
    memory. This is the structure that we’ve shown in the diagrams, as it’s easier
    for beginners to visualize. The default collector for the old generation in these
    older versions is called *Parallel*. However, in modern versions of HotSpot, a
    new, partially concurrent collection algorithm known as *Garbage First* (G1) has
    become the default.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Java版本（版本8及更早版本）中，堆具有简单的结构：每个内存池（Eden、幸存者空间和Tenured）都是连续的内存块。这是我们在图表中展示的结构，因为它更容易让初学者可视化。这些旧版本中老年代的默认收集器称为*并行*。然而，在现代版本的HotSpot中，一个名为*垃圾优先*（G1）的新型部分并发收集算法已成为默认。
- en: G1
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: G1
- en: G1 is an example of a *region-based collector* and has a different heap layout
    than the old-style heap. A region is an area of memory (usually 1M in size, but
    larger heaps may have regions of 2, 4, 8, 16, or 32M) where all the objects belong
    to the same memory pool. However, in a regional collector, the different regions
    that make up a pool are not necessarily located next to each other in memory.
    This is unlike the Java 8 heap, where each pool is contiguous, although in both
    cases the entire heap remains contiguous.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: G1是*基于区域的收集器*的一个示例，并且与旧式堆的布局不同。一个区域是一个内存区域（通常大小为1M，但较大堆可能有2、4、8、16或32M的区域），其中所有对象都属于同一个内存池。然而，在区域收集器中，组成池的不同区域不一定位于内存中的相邻位置。这与Java
    8堆不同，在Java 8堆中，每个池都是连续的，尽管在这两种情况下整个堆仍然是连续的。
- en: Warning
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: G1 uses a different version of the algorithm in each Java version, and there
    are some important differences in terms of performance and other behavior between
    versions. It is very important that, when upgrading from Java 8 to a later version
    and adopting G1, you undertake a full performance retest. You may find that when
    switching to Java 11 or 17, you require fewer resources (and may even save money).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: G1在每个Java版本中使用不同版本的算法，各版本在性能和其他行为方面有一些重要的差异。从Java 8升级到更高版本并采用G1时，进行全面性能重新测试非常重要。您可能会发现，切换到Java
    11或17时，您需要更少的资源（甚至可以节省金钱）。
- en: G1 focuses its attention on regions that are mostly garbage, as they have the
    best free memory recovery. It is an evacuating collector and does *incremental
    compaction* when evacuating individual regions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: G1的注意点在于它主要集中在大部分是垃圾的区域上，因为这些区域有最佳的自由内存回收。它是一个撤离收集器，在撤离单个区域时进行*增量整理*。
- en: The G1 collector was originally intended to take over from a previous collector,
    CMS, as the low-pause collector, and it allows the user to specify *pause goals*
    in terms of how long and how often to pause when doing GC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，G1收集器的目标是取代之前的CMS作为低暂停时间收集器，并允许用户根据GC时的暂停时间和频率指定*暂停目标*。
- en: 'The JVM provides a command-line switch that controls how long the collector
    will aim to pause: `-XX:MaxGCPauseMillis=200`. This means that the default pause
    time goal is 200 ms, but you can change this value depending on your needs.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JVM提供了一个命令行开关来控制收集器的暂停目标：`-XX:MaxGCPauseMillis=200`。这意味着默认的暂停时间目标是200毫秒，但您可以根据需要更改此值。
- en: There are, of course, limits to how far the collector can be pushed. Java GC
    is driven by the rate at which new memory is allocated, which can be highly unpredictable
    for many Java applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，收集器能推动的极限是有限的。Java GC受到新分配内存速度的驱动，对于许多Java应用程序来说，这是非常不可预测的。
- en: As noted, G1 was originally intended to be a replacement low-pause collector.
    However, the overall characteristics of its behavior have meant that it has actually
    evolved into a more general-purpose collector (which is why it has now become
    the default).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，G1最初是为了成为一种低暂停的替代收集器。然而，其行为的整体特性使得它实际上演变成了一种更通用的收集器（这就是为什么它现在成为默认收集器的原因）。
- en: Note that the development of a new production-grade collector that is suitable
    for general use is not a quick process. In the next section, let’s move on to
    discuss the alternative collectors that are provided by HotSpot (including the
    parallel collector of Java 8).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，开发一个适用于通用使用的新生产级收集器并非一蹴而就的过程。在接下来的章节中，让我们继续讨论HotSpot提供的替代收集器（包括Java 8的并行收集器）。
- en: A detailed full treatment is outside the scope of the book, but it is worth
    knowing about the existence of alternate collectors. For non-HotSpot users, you
    should consult your JVM’s documentation to see what options may be available for
    you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的全面处理超出了本书的范围，但了解备选收集器的存在是值得的。对于非HotSpot用户，您应该查阅您的JVM文档，了解可能适合您的选项。
- en: ParallelOld
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行老年代（ParallelOld）
- en: 'By default, in Java 8 the collector for the old generation is a parallel (but
    not concurrent) mark-and-sweep collector. It seems, at first glance, to be similar
    to the collector used for the young generation. However, it differs in one very
    important respect: it is *not* an evacuating collector. Instead, the old generation
    is compacted when collection occurs. This is important so that the memory space
    does not become fragmented over time.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在Java 8中，老年代的收集器是一个并行（但不是并发）的标记-清除收集器。乍看之下，它似乎与年轻代使用的收集器相似。然而，它在一个非常重要的方面有所不同：它*不*是一个疏散式收集器。相反，老年代在进行收集时进行压缩。这是重要的，以防止内存空间随着时间的推移变得碎片化。
- en: 'The `ParallelOld` collector is very efficient, but it has two properties that
    make it less desirable for modern applications. It is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelOld` 收集器非常高效，但有两个特性使其在现代应用中不太理想。它是：'
- en: Fully STW
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全STW
- en: Linear in pause time with the size of the heap
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆大小的暂停时间线性增长
- en: This means that once GC has started, it cannot be aborted early, and the cycle
    must be allowed to finish. As heap sizes increase, this makes `ParallelOld` a
    less attractive option than G1, which can often keep a constant pause time regardless
    of heap size (assuming the allocation rate is manageable).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦GC开始，就无法提前中止，并且必须允许循环完成。随着堆大小的增加，这使得`ParallelOld` 收集器比G1收集器不那么吸引人，后者可以在管理可分配速率的情况下通常保持恒定的暂停时间。
- en: In modern deployments, especially for Java 11+, G1 gives typically better performance
    on a large majority of applications that previously used `ParallelOld`. The `ParallelOld`
    collector is still available as of Java 17, for those (hopefully few) apps that
    still need it, but the direction of the platform is clear—toward using G1 wherever
    possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代部署中，特别是针对Java 11+，G1通常在以前使用`ParallelOld`的大多数应用程序中表现更好。`ParallelOld` 收集器截至Java
    17仍然可用，供那些（希望很少）仍然需要的应用程序使用，但平台的方向显而易见——尽可能地使用G1。
- en: Serial
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行
- en: 'The Serial and SerialOld collectors operate in a similar fashion to the Parallel
    collectors, with one important difference: they use only a single CPU core to
    perform fully STW GC.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 串行和SerialOld收集器与并行收集器的运行方式类似，但有一个重要区别：它们仅使用单个CPU核心执行完全STW的GC。
- en: On modern multicore systems, there is no benefit from using these collectors,
    and so they should not be used, as they are just an inefficient form of the parallel
    collectors. However, one place where you may still encounter these collectors
    is when running Java applications in containers. A full discussion of containerized
    Java is outside the scope of this book. However, if your application is run in
    too small a container (either too little memory or with only a single CPU), then
    the JVM will automatically select the Serial collector.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代多核系统上，使用这些收集器没有任何好处，因此不应使用它们，因为它们只是并行收集器的低效形式。然而，您仍可能在容器中运行Java应用程序时遇到这些收集器。有关容器化Java的完整讨论超出了本书的范围。但是，如果您的应用程序在容器中运行的环境过小（内存不足或仅有单个CPU），那么JVM将自动选择串行收集器。
- en: Therefore, we do not recommend running Java in a single-core container, as the
    Serial collector performs noticeably worse than G1 under almost all realistic
    load scenarios.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不建议在单核容器中运行Java，因为串行收集器在几乎所有实际负载场景下的表现明显比G1差。
- en: Shenandoah
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shenandoah
- en: Shenandoah is a new GC algorithm developed by Red Hat to work effectively with
    certain use cases where G1 and other algorithms do not perform well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah 是 Red Hat 开发的一种新的 GC 算法，可以有效地处理某些情况下 G1 和其他算法表现不佳的情况。
- en: The aim of Shenandoah is to bring down pause times, especially on large heaps,
    and to guarantee (as far as possible) that pause times will not exceed 1 ms, no
    matter the size of the heap.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah 的目标是降低暂停时间，特别是在大堆上，并尽可能地保证暂停时间不会超过 1 毫秒，无论堆的大小如何。
- en: Like G1, Shenandoah is an evacuating regional collector that performs concurrent
    marking. The evacuation of regions causes incremental compaction but the key difference
    is that in G1, evacuation happens during a STW phase, whereas in Shenandoah the
    evacuation is concurrent with application threads.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像 G1 一样，Shenandoah 是一种执行并发标记的疏散区域收集器。区域的疏散导致增量压缩，但关键的区别在于，在 G1 中，疏散发生在 STW 阶段，而在
    Shenandoah 中，疏散是与应用线程并发进行的。
- en: There is no such thing as a free lunch, however, and users of Shenandoah could
    experience up to 15% overhead (i.e., reduction in application throughput), but
    the exact figure will depend on the details of the workload. For example, on some
    targeted benchmarks you can observe a significant overhead, towards the upper
    end of the expected range.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有免费的午餐，Shenandoah 的用户可能会经历高达 15% 的额外开销（即，应用吞吐量的减少），但确切的数字将取决于工作负载的细节。例如，在一些特定的基准测试中，您可以观察到显著的开销，接近预期范围的上限。
- en: 'Shenandoah can be activated with this command line switch:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令行开关激活 Shenandoah：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One important point to note is that, at time of writing, Shenandoah is not yet
    a generational collector, although work is underway to add generations to the
    implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是，在撰写本文时，Shenandoah 还不是一个分代收集器，尽管正在进行将分代添加到实现中的工作。
- en: ZGC
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC
- en: As well as Shenandoah, Oracle has also created a new ultra-low-pause collector,
    known as ZGC. It is designed to appeal to the same sorts of workloads as Shenandoah
    and is broadly similar in intent, effect, and overhead. ZGC is a single-generation,
    region-based, NUMA-aware, compacting collector. However, the implementation of
    ZGC is quite different from Shenandoah.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Shenandoah 外，Oracle 还创建了一种新的超低暂停收集器，称为 ZGC。它的设计旨在吸引与 Shenandoah 类似的工作负载，并且在意图、效果和开销上基本相似。ZGC
    是一种单代、区域化、NUMA-aware、压缩收集器。然而，ZGC 的实现与 Shenandoah 大不相同。
- en: 'ZGC can be activated with this command line switch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令行开关激活 ZGC：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ZGC needs only a stop-the-world pause to perform root scanning, which means
    that GC pause times do not increase with the size of the heap or the number of
    live objects. Due to its intended domain of applicability (ultra-low pause on
    large heaps), ZGC is most commonly used by Oracle customers on the Oracle-supported
    builds of Java.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 只需一个停止-世界暂停来执行根扫描，这意味着 GC 暂停时间不会随着堆的大小或活动对象的数量增加而增加。由于其预期的适用领域（大堆的超低暂停），ZGC
    最常由 Oracle 客户在 Oracle 支持的 Java 构建上使用。
- en: Finalization
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终结
- en: For completeness, developers should be aware of an old technique for resource
    management known as *finalization*. However, this technique is *extremely* heavily
    deprecated and the vast majority of Java developers should *not* directly use
    it under any circumstances.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，开发人员应该知道一种称为 *终结* 的旧的资源管理技术。然而，这种技术已经 *极度* 被弃用，绝大多数 Java 开发人员在任何情况下 *不应该*
    直接使用它。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Finalization has been deprecated and will be removed in a future release. The
    mechanism remains enabled by default for now but can be disabled with a switch.
    In a future release, it will be disabled by default and then eventually removed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 终结已经被弃用，并将在未来的发布中删除。目前机制仍然默认启用，但可以使用开关禁用。在未来的发布中，它将默认禁用，然后最终删除。
- en: The finalization mechanism was intended to automatically release resources once
    they are no longer needed. Garbage collection automatically frees up the memory
    resources used by objects, but objects can hold other kinds of resources, such
    as open files and network connections. The garbage collector cannot free these
    additional resources for you, so the finalization mechanism was intended to allow
    the developer to perform cleanup tasks as closing files, terminating network connections,
    deleting temporary files, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化机制旨在自动释放不再需要的资源。垃圾收集器可以自动释放对象使用的内存资源，但对象可能持有其他类型的资源，例如打开的文件和网络连接。垃圾收集器无法释放这些额外的资源，因此最终化机制旨在允许开发人员执行清理任务，如关闭文件、终止网络连接、删除临时文件等。
- en: 'The finalization mechanism works as follows: if an object has a `finalize()`
    method (usually called a *finalizer*), this is invoked some time after the object
    becomes unused (or unreachable) but before the garbage collector reclaims the
    space allocated to the object. The finalizer is used to perform resource cleanup
    for an object.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化机制的工作方式如下：如果一个对象有一个`finalize()`方法（通常称为*终结器*），那么在对象变得未使用（或不可达）但在垃圾收集器回收对象分配的空间之前，将调用该方法。终结器用于执行对象的资源清理工作。
- en: The central problem with finalization is that Java makes no guarantees about
    when garbage collection will occur or in what order objects will be collected.
    Therefore, the platform can make no guarantees about when (or even whether) a
    finalizer will be invoked or in what order finalizers will be invoked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化的核心问题在于Java不保证何时进行垃圾收集或对象收集的顺序。因此，平台无法保证何时（甚至是否）调用终结器或调用终结器的顺序。
- en: Finalization Details
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终化细节
- en: The finalization mechanism is an attempt to implement a similar concept present
    in other languages and environments. In particular, C++ has a pattern known as
    RAII (Resource Acquisition Is Initialization) that provides automatic resource
    management in a similar way. In that pattern, a destructor method (which would
    be called `finalize()` in Java) is provided by the programmer, to perform cleanup
    and release resources when the object is destroyed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化机制是试图在其他语言和环境中实现类似概念的一种尝试。特别是，C++有一种称为RAII（资源获取即初始化）的模式，以类似的方式提供自动资源管理。在该模式中，程序员提供一个析构函数（在Java中称为`finalize()`），用于在对象销毁时执行清理和释放资源。
- en: 'The basic use case for this is fairly simple: when an object is created, it
    takes ownership of some resource, and the object’s ownership of that resource
    is tied to the lifetime of the object. When the object dies, the ownership of
    the resource is automatically relinquished, as the platform calls the destructor
    without any programmer intervention.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本用例非常简单：当对象被创建时，它获取某些资源的所有权，并且对象对该资源的所有权与对象的生命周期相关联。当对象销毁时，资源的所有权会自动释放，因为平台会调用析构函数而无需程序员介入。
- en: While finalization superficially sounds similar to this mechanism, in reality
    it is fundamentally different. In fact, the finalization language feature is fatally
    flawed, due to differences in the memory management schemes of Java versus C++.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最终化听起来与此机制表面上相似，但实际上它们是根本不同的。事实上，最终化语言特性存在致命缺陷，这是由于Java与C++的内存管理方案之间的差异。
- en: In the C++ case, memory is handled manually, with explicit lifetime management
    of objects under the control of the programmer. This means that the destructor
    can be called immediately after the object is deleted (the platform guarantees
    this), and so the acquisition and release of resources is directly tied to the
    lifetime of the object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++的情况下，内存是手动处理的，对象的生命周期由程序员控制。这意味着在对象删除后可以立即调用析构函数（平台保证这一点），因此资源的获取和释放直接与对象的生命周期相关联。
- en: On the other hand, Java’s memory management subsystem is a garbage collector
    that runs as needed, in response to running out of available memory to allocate.
    It therefore runs at variable (and nondeterministic) intervals and so `finalize()`
    is run only when the object is collected, and this will be at an unknown time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Java的内存管理子系统是一个根据需要运行的垃圾收集器，响应内存不足以分配时运行。因此，它以可变（非确定性）的间隔运行，因此`finalize()`只有在对象被收集时才会运行，而这将在未知时间发生。
- en: If the `finalize()` mechanism was used to automatically release resources (e.g.,
    filehandles), then there is no guarantee as to when (if ever) those resources
    will actually become available. This has the result of making the finalization
    mechanism fundamentally unsuitable for its stated purpose—automatic resource management.
    We cannot guarantee that finalization will happen fast enough to prevent us from
    running out of resources. As an automatic cleanup mechanism for protecting scarce
    resources (such as filehandles), finalization is broken by design.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`finalize()`机制自动释放资源（例如文件句柄），则不能保证这些资源何时（如果有的话）会实际可用。这导致最终化机制在其所声明的自动资源管理目的上基本不适用——我们无法保证最终化会在资源不足之前足够快地发生。作为保护稀缺资源（例如文件句柄）的自动清理机制，最终化在设计上存在缺陷。
- en: Finalization has only a very small number of legitimate use cases, and only
    a tiny minority of Java developers will ever encounter them. If in any doubt,
    do not use finalization—try-with-resources is usually the correct alternative.
    More details about `try`-with-resources can be found in [Chapter 10](ch10.xhtml#javanut8-CHP-10).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化只有极少数合法用例，只有少数Java开发人员会遇到它们。如果有任何疑问，请不要使用最终化——通常正确的替代方法是使用`try`-with-resources。有关`try`-with-resources的更多详细信息，请参见[第10章](ch10.xhtml#javanut8-CHP-10)。
- en: Java’s Support for Concurrency
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对并发的支持
- en: The idea of a *thread* is that of a lightweight unit of execution—smaller than
    a process, but still capable of executing arbitrary Java code. The usual way that
    this is implemented is for each thread to be a fully fledged unit of execution
    to the operating system but to belong to a process, with the address space of
    the process being shared between all threads comprising that process. This means
    each thread can be scheduled independently and has its own stack and program counter
    but shares memory and objects with other threads in the same process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*的概念是执行的轻量级单位——比进程小，但仍能执行任意Java代码。通常的实现方式是每个线程作为操作系统的完全成熟执行单元，但属于一个进程，该进程的地址空间与该进程组成的其他线程共享。这意味着每个线程可以独立调度，具有自己的堆栈和程序计数器，但与同一进程中的其他线程共享内存和对象。'
- en: The Java platform has supported multithreaded programming from the very first
    version. The platform exposes the ability to create new threads of execution to
    the developer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台从第一个版本开始就支持多线程编程。该平台为开发人员提供了创建新执行线程的能力。
- en: 'To understand this, first we must consider what happens in detail when a Java
    program starts up and the original application thread (usually referred to as
    *main* thread) appears:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，首先我们必须详细考虑Java程序启动时发生的情况以及原始应用程序线程（通常称为*主*线程）的出现：
- en: The programmer executes `java Main` (other startup cases are possible).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员执行`java Main`（也可能是其他启动方式）。
- en: This causes the Java Virtual Machine, the context within which all Java programs
    run, to start up.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得Java虚拟机，即所有Java程序运行的上下文，启动起来。
- en: The JVM examines its arguments and sees that the programmer has requested execution
    starting at the entry point (the `main()` method) of `Main.class`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM检查其参数，并看到程序员请求从`Main.class`的入口点（`main()`方法）开始执行。
- en: Assuming that `Main` passes classloading checks, a dedicated thread for the
    execution of the program is started (main thread).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`Main`通过类加载检查，为程序的执行启动了一个专用线程（主线程）。
- en: The JVM bytecode interpreter is started on main thread.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM字节码解释器在主线程上启动。
- en: Main thread’s interpreter reads the bytecode of `Main::main()` and execution
    begins, one bytecode at a time.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程的解释器读取`Main::main()`的字节码，执行开始，逐个字节码执行。
- en: 'Every Java program starts this way, but this also means:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java程序都是这样开始的，但这也意味着：
- en: Every Java program starts as part of a managed model with one interpreter per
    thread.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Java程序都作为管理模型的一部分开始，每个线程都有一个解释器。
- en: Every Java program always runs as part of a multithreaded operating system process.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Java程序始终作为多线程操作系统进程的一部分运行。
- en: The JVM has a certain ability to control a Java application thread.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM具有控制Java应用程序线程的能力。
- en: 'Following from this, when we create new threads of execution in Java code,
    this is usually as simple as:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由此引发的是，在Java代码中创建新的执行线程通常很简单：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This small piece of code creates and starts a new thread, which executes the
    body of the lambda expression and then executes. Technically speaking, the lambda
    is converted to an instance of the `Runnable` interface before being passed to
    the `Thread` constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码创建并启动一个新线程，该线程执行lambda表达式的主体，然后执行。从技术上讲，lambda在传递给`Thread`构造函数之前被转换为`Runnable`接口的实例。
- en: The threading mechanism allows new threads to execute concurrently with the
    original application thread and the threads that the JVM itself starts up for
    various purposes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 线程机制允许新线程与原始应用程序线程以及JVM本身为各种目的启动的线程并发执行。
- en: For mainstream implementations of the Java platform, every time we call `Thread::start()`
    this call is delegated to the operating system, and a new OS thread is created.
    This new OS thread `exec()`’s a new copy of the JVM bytecode interpreter. The
    interpreter starts executing at the `run()` method (or, equivalently, at the body
    of the lambda).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java平台的主流实现，每当我们调用`Thread::start()`时，此调用被委托给操作系统，并创建一个新的OS线程。这个新的OS线程`exec()`了JVM字节码解释器的一个新副本。解释器从`run()`方法（或等效地从lambda的主体）开始执行。
- en: This means that application threads have their access to the CPU controlled
    by the operating system *scheduler*—a built-in part of the OS that is responsible
    for managing timeslices of processor time (and that will not allow an application
    thread to exceed its allocated time).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序线程的CPU访问由操作系统的*调度程序*控制——这是操作系统的内置部分，负责管理处理器时间片段（并且不允许应用程序线程超出其分配的时间）。
- en: In more recent versions of Java, an increasing trend toward *runtime-managed
    concurrency* has appeared. This is the idea that for many purposes it’s not desirable
    for developers to explicitly manage threads. Instead, the runtime should provide
    “fire and forget” capabilities, whereby the program specifies what needs to be
    done, but the low-level details of how this is to be accomplished are left to
    the runtime. This viewpoint can be seen in the concurrency toolkit contained in
    `java.util.concurrent`, which we discuss briefly in [Chapter 8](ch08.xhtml#javanut8-CHP-8).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的较新版本中，出现了越来越多的*运行时管理并发*的趋势。这是指对于许多目的来说，显式管理线程并不理想。相反，运行时应该提供“点火并忘记”的能力，程序指定需要做什么，但如何完成这些工作的底层细节留给运行时处理。这一观点可以在`java.util.concurrent`中的并发工具包中看到，我们在[第8章](ch08.xhtml#javanut8-CHP-8)中简要讨论。
- en: For the remainder of this chapter, we will introduce the low-level concurrency
    mechanisms that the Java platform provides and that every Java developer should
    be aware of. The reader is strongly encouraged to understand both the low-level
    `Thread`-based and the runtime-managed approaches before doing any significant
    concurrent programming.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将介绍Java平台提供的低级并发机制，每个Java开发人员都应该了解。强烈建议读者在进行任何重要的并发编程之前，理解基于低级`Thread`和运行时管理方法。
- en: Thread Lifecycle
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: 'Let’s start by looking at the lifecycle of an application thread. Every operating
    system has a view of threads that can differ in the details (but in most cases
    is broadly similar at a high level). Java tries hard to abstract these details
    away and has an enum called `Thread.State`, which wrappers over the operating
    system’s view of the thread’s state. The values of `Thread.State` provide an overview
    of the lifecycle of a thread:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看应用程序线程的生命周期开始。每个操作系统都有一个线程视图，其细节可能不同（但在大多数情况下在高层次上是大致相似的）。Java努力将这些细节抽象化，并有一个称为`Thread.State`的枚举，它包装了操作系统对线程状态的视图。`Thread.State`的值提供了线程生命周期的概述：
- en: '`NEW`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`NEW`'
- en: The thread has been created, but its `start()` method has not yet been called.
    All threads start in this state.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 线程已创建，但尚未调用其`start()`方法。所有线程都从这个状态开始。
- en: '`RUNNABLE`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUNNABLE`'
- en: The thread is running or is available to run when the operating system schedules
    it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统安排它时，线程正在运行或可运行。
- en: '`BLOCKED`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOCKED`'
- en: The thread is not running because it is waiting to acquire a lock so that it
    can enter a `synchronized` method or block. We’ll see more about `synchronized`
    methods and blocks later in this section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 线程没有运行，因为它正在等待获取锁定，以便可以进入`synchronized`方法或块。在本节的后面部分，我们将进一步了解`synchronized`方法和块。
- en: '`WAITING`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`WAITING`'
- en: The thread is not running because it has called `Object.wait()` or `Thread.join()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 线程没有运行，因为它已调用`Object.wait()`或`Thread.join()`。
- en: '`TIMED_WAITING`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`'
- en: The thread is not running because it has called `Thread.sleep()` or has called
    `Object.wait()` or `Thread.join()` with a timeout value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 线程不在运行，因为它已调用`Thread.sleep()`或已调用`Object.wait()`或`Thread.join()`并带有超时值。
- en: '`TERMINATED`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`TERMINATED`'
- en: The thread has completed execution. Its `run()` method has exited normally or
    by throwing an exception.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 线程已完成执行。它的`run()`方法已正常退出或通过抛出异常退出。
- en: These states represent the view of a thread that is common (at least across
    mainstream operating systems), leading to a view like [Figure 6-4](#javanut8-CHP-6-FIG-4).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态代表了一个线程的视图，这在至少主流操作系统中是通用的，导致一个像图[6-4](#javanut8-CHP-6-FIG-4)那样的视图。
- en: '![JN7 0604](assets/jns8_0604.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0604](assets/jns8_0604.png)'
- en: Figure 6-4\. Thread lifecycle
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 线程生命周期
- en: 'Threads can also be made to sleep, by using the `Thread.sleep()` method. This
    takes an argument in milliseconds, which indicates how long the thread would like
    to sleep like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 线程也可以使用`Thread.sleep()`方法使其休眠。这需要一个以毫秒为单位的参数，表示线程希望休眠的时间，如下所示：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The argument to sleep is a request to the operating system, not a demand. For
    example, your program may sleep for longer than requested, depending on load and
    other factors specific to the runtime environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep`方法的参数是对操作系统的请求，而不是一个要求。例如，您的程序可能因负载和其他特定于运行时环境的因素而睡眠时间超过请求的时间。'
- en: We will discuss the other methods of `Thread` later in this chapter, but first
    we need to cover some important theory that deals with how threads access memory
    and that is fundamental to understanding why multithreaded programming is hard
    and can cause developers a lot of problems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论`Thread`的其他方法，但首先我们需要涵盖一些重要的理论，这些理论涉及线程如何访问内存，并且对理解为何多线程编程困难且可能给开发者带来许多问题至关重要。
- en: Visibility and Mutability
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性和可变性
- en: In mainstream Java implementations, all Java application threads in a process
    have their own call stacks (and local variables) but share a single heap. This
    makes it very easy to share objects between threads, as all that is required is
    to pass a reference from one thread to another. This is illustrated in [Figure 6-5](#javanut8-CHP-6-FIG-5).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在主流的 Java 实现中，一个进程中所有 Java 应用程序线程都有自己的调用堆栈（和本地变量），但共享一个单一的堆。这使得在线程之间共享对象非常容易，因为只需从一个线程传递一个引用到另一个线程即可。这在图[6-5](#javanut8-CHP-6-FIG-5)中有所说明。
- en: This leads to a general design principle of Java—that objects are *visible by
    default*. If I have a reference to an object, I can copy it and hand it off to
    another thread with no restrictions. A Java reference is essentially a typed pointer
    to a location in heap—and threads share the same heap, so visible by default is
    a natural model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了 Java 的一个通用设计原则——对象*默认是可见的*。如果我有一个对象的引用，我可以复制它并将其交给另一个线程，没有任何限制。Java 的引用实质上是指向堆中某个位置的类型化指针——线程共享同一个堆，因此默认可见是一种自然的模型。
- en: 'In addition to visible by default, Java has another property that is important
    to fully understand concurrency, which is that objects are *mutable*: the contents
    of an object instance’s fields can usually be changed. We can make individual
    variables or references constant by using the `final` keyword, but this does not
    apply to the contents of the object.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认可见性，Java 还有另一个对完全理解并发性非常重要的属性，即对象是*可变的*：对象实例字段的内容通常可以更改。我们可以通过使用`final`关键字使个别变量或引用常量化，但这并不适用于对象的内容。
- en: As we will see throughout the rest of this chapter, the combination of these
    two properties—visibility across threads and object mutability—gives rise to a
    great many complexities when trying to reason about concurrent Java programs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章的其余部分看到的那样，这两个属性的结合——跨线程的可见性和对象的可变性——在尝试推理并发 Java 程序时引发了许多复杂性。
- en: '![JN7 0605](assets/jns8_0605.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0605](assets/jns8_0605.png)'
- en: Figure 6-5\. Shared memory between threads
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 线程之间共享的内存
- en: Concurrent safety
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发安全性
- en: If we’re to write correct multithreaded code, then we want our programs to satisfy
    a certain important property.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编写正确的多线程代码，那么我们希望我们的程序满足某个重要的属性。
- en: In [Chapter 5](ch05.xhtml#javanut8-CHP-5), we defined a safe object-oriented
    program to be one where we move objects from legal state to legal state by calling
    their accessible methods. This definition works well for single-threaded code.
    However, there is a particular difficulty that comes about when we try to extend
    it to concurrent programs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#javanut8-CHP-5)中，我们定义了一个安全的面向对象程序，即通过调用其可访问方法将对象从合法状态移动到合法状态。这个定义对于单线程代码很有效。然而，当我们尝试将其扩展到并发程序时，会遇到一个特殊的困难。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A *safe multithreaded program* is one in which it is impossible for any object
    to be seen in an illegal or inconsistent state by any other object, no matter
    what methods are called, and no matter in what order the application threads are
    scheduled by the operating system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全的多线程程序* 是指任何对象不论调用什么方法，以及应用程序线程由操作系统按何种顺序调度，都不会被其他对象看到处于非法或不一致状态的程序。'
- en: For most mainstream cases, the operating system will schedule threads to run
    on particular processor cores at seemingly random times, depending on load and
    what else is running in the system. If load is high, then there may be other processes
    that also need to run.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数主流情况，操作系统将根据负载和系统中其他运行情况，在特定处理器核心上安排线程运行。如果负载很高，可能还有其他需要运行的进程。
- en: The operating system will forcibly remove a Java thread from a CPU core if it
    needs to. The thread is suspended immediately, no matter what it’s doing—including
    being partway through executing a method. However, as we discussed in [Chapter 5](ch05.xhtml#javanut8-CHP-5),
    a method can temporarily put an object into an illegal state while it is working
    on it, providing it corrects it before the method exits.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统如果需要的话，会强制从CPU核心上删除Java线程。该线程会立即暂停，无论它当前在做什么，包括正在执行方法的中间过程。然而，正如我们在[第5章](ch05.xhtml#javanut8-CHP-5)中讨论的那样，一个方法在操作对象时可能会将其临时置于非法状态，只要在方法退出之前纠正即可。
- en: This means that if a thread is swapped off before it has completed a long-running
    method, it may leave an object in an inconsistent state, *even if the program
    follows the safety rules*. Another way of saying this is that even data types
    that have been correctly modeled for the single-threaded case still need to protect
    against the effects of concurrency. Code that adds this extra layer of protection
    is called *concurrently safe* or (more informally) threadsafe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果一个线程在完成长时间方法之前被换出，即使程序遵循安全规则，也可能会使对象处于不一致状态。另一种说法是，即使正确建模了单线程情况下的数据类型，也仍需保护免受并发影响。为此添加额外保护层的代码称为*并发安全*
    或（更非正式地）线程安全。
- en: In the next section, we’ll discuss the primary means of achieving this safety,
    and at the end of the chapter, we’ll meet some other mechanisms that can also
    be useful under some circumstances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论实现这种安全性的主要手段，而在本章末尾，我们将介绍一些在某些情况下也可能有用的其他机制。
- en: Exclusion and Protecting State
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除和保护状态
- en: 'Any code that modifies *or reads* state that can become inconsistent must be
    protected. To achieve this, the Java platform provides only one mechanism: *exclusion*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 任何修改或读取可能导致状态不一致的代码都必须受到保护。为此，Java平台只提供了一种机制：*排除*。
- en: Consider a method that contains a sequence of operations that, if interrupted
    partway through, could leave an object in an inconsistent or illegal state. If
    this illegal state was visible to another object, incorrect code behavior could
    occur.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个方法，其中包含一系列操作，如果中途被中断，可能会使对象处于不一致或非法状态。如果这种非法状态对其他对象可见，则可能导致代码执行错误。
- en: 'For example, consider an ATM or other cash-dispensing machine:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个ATM或其他发放现金的机器：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The sequence of operations that happens inside `withdraw()` can leave the object
    in an inconsistent state. In particular, after we’ve checked the balance, a second
    thread could come in while the first was sleeping in simulated risk checks, and
    the account could be overdrawn, in violation of the constraint that `balance >=
    0`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`withdraw()` 内发生的操作序列可能会使对象处于不一致状态。特别是在检查余额后，第二个线程可能在第一个线程在模拟风险检查时休眠时介入，并且账户可能会透支，违反了`balance
    >= 0`的约束。'
- en: This is an example of a system where the operations on the objects are single-threaded
    safe (because the objects cannot reach an illegal state (`balance < 0`) if called
    from a single thread) but not concurrently safe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统的例子，对象上的操作是单线程安全的（因为如果从单个线程调用，则对象不会达到非法状态（`balance < 0`）），但不是并发安全的。
- en: To allow the developer to make code like this concurrently safe, Java provides
    the `synchronized` keyword. This keyword can be applied to a block or to a method,
    and when it is used, the platform uses it to restrict access to the code inside
    the block or method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发人员使此类代码具备并发安全性，Java提供了`synchronized`关键字。此关键字可以应用于块或方法，当使用它时，平台将其用于限制块或方法内部代码的访问。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because `synchronized` surrounds code, many developers are led to the conclusion
    that concurrency in Java is about code. Some texts even refer to the code that
    is inside the synchronized block or method as a *critical section* and consider
    that to be the crucial aspect of concurrency. This is not the case; instead, it
    is the inconsistency of data that we must guard against, as we will see.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`synchronized`包围了代码，许多开发人员得出结论，Java中的并发性是关于代码的。一些文本甚至将位于同步块或方法内部的代码称为*临界区*，并认为这是并发性的关键方面。实际情况并非如此；相反，我们必须防范的是数据的不一致性，正如我们将看到的那样。
- en: 'The Java platform keeps track of a special token, called a *monitor*, for every
    object that it ever creates. These monitors (also called *locks*) are used by
    `synchronized` to indicate that the following code could temporarily render the
    object inconsistent. The sequence of events for a synchronized block or method
    is:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台为其创建的每个对象跟踪一个特殊的标记，称为*监视器*。这些监视器（也称为*锁*）被`synchronized`用来指示以下代码可能会暂时使对象不一致。`synchronized`块或方法的事件序列是：
- en: Thread needs to modify an object and may make it briefly inconsistent as an
    intermediate step
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程需要修改对象，并可能在中间步骤中使其暂时不一致
- en: Thread acquires the monitor, indicating it requires temporary exclusive access
    to the object
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程获取监视器，表示它需要临时独占对象的访问权限
- en: Thread modifies the object, leaving it in a consistent, legal state when done
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程修改对象，在完成时将其保留在一致的、合法状态
- en: Thread releases the monitor
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程释放监视器
- en: If another thread attempts to acquire the lock while the object is being modified,
    then the attempt to acquire the lock blocks, until the holding thread releases
    the lock.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个线程在修改对象时尝试获取锁定，则获取锁定的尝试将被阻塞，直到持有线程释放锁定。
- en: Note that you do not have to use the `synchronized` statement unless your program
    creates multiple threads that share data. If only one thread ever accesses a data
    structure, there is no need to protect it with `synchronized`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除非您的程序创建了多个共享数据的线程，否则无需使用`synchronized`语句来保护数据结构。如果只有一个线程访问数据结构，就无需用`synchronized`保护它。
- en: One point is of critical importance—acquiring the monitor does *not* prevent
    access to the object. It only prevents any other thread from claiming the lock.
    Correct concurrently safe code requires developers to ensure that all accesses
    that might modify *or read* potentially inconsistent state acquire the object
    monitor before operating on or reading that state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的要点是——获取监视器并不会阻止访问对象。它只是防止其他线程获取锁。正确的并发安全代码要求开发人员确保所有可能修改或读取潜在不一致状态的访问都在操作或读取该状态之前获取对象监视器。
- en: Put another way, if a `synchronized` method is working on an object and has
    placed it into an illegal state, and another method (which is not synchronized)
    reads from the object, it can still see the inconsistent state.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果一个`synchronized`方法正在操作一个对象并将其置于非法状态，而另一个（非同步的）方法读取该对象，则可能看到不一致的状态。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Synchronization is a cooperative mechanism for protecting state, and it is very
    fragile as a result. A single bug (such as missing a single `synchronized` keyword
    from a method it’s required on) can have catastrophic results for the safety of
    the system as a whole.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同步是一种保护状态的协作机制，因此非常脆弱。一个错误（例如在所需的方法上漏掉一个`synchronized`关键字）可能会对系统整体的安全性产生灾难性的后果。
- en: The reason we use the word `synchronized` as the keyword for “requires temporary
    exclusive access” is that in addition to acquiring the monitor, the JVM also rereads
    the current state of the object from main memory when the block is entered. Similarly,
    when the `synchronized` block or method is exited, the JVM flushes any modified
    state of the object back to main memory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字`synchronized`作为“需要临时独占访问”的关键字的原因是，除了获取监视器之外，JVM还会在进入代码块时重新从主内存中读取对象的当前状态。同样，在退出`synchronized`块或方法时，JVM会将对象的任何修改状态刷新回主内存。
- en: Without synchronization, different CPU cores in the system may not see the same
    view of memory, and memory inconsistencies can damage the state of a running program,
    as we saw in our ATM example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 没有同步，系统中不同的CPU核心可能看到内存的不同视图，内存不一致性可能会损坏运行程序的状态，就像我们在ATM示例中看到的那样。
- en: 'The simplest example of this is known as *lost update*, as demonstrated in
    the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这最简单的例子称为*丢失更新*，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can be driven via a simple control program:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一个简单的控制程序来驱动这一点：
- en: '[PRE7]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If this concurrent program was correct, then the value for the anomaly (number
    of lost updates) should be exactly zero. It is not, and so we may conclude that
    unsynchronized access is fundamentally unsafe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个并发程序是正确的，那么异常值（丢失更新的数量）应该完全为零。但事实并非如此，因此我们可以得出结论，非同步访问基本上是不安全的。
- en: By contrast, we also see that the addition of the keyword `synchronized` to
    the increment method is sufficient to reduce the lost update anomaly to zero—​that
    is, to make the method correct, even in the presence of multiple threads.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们还看到将关键字`synchronized`添加到增量方法中足以将丢失更新异常减少到零—即使在多个线程存在的情况下，也能使方法正确。
- en: volatile
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: Java provides another keyword for dealing with concurrent access to data. This
    is the `volatile` keyword, and it indicates that before being used by application
    code, the value of the field or variable must be reread from main memory. Equally,
    after a volatile value has been modified, as soon as the write to the variable
    has completed, it must be written back to main memory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了另一个关键字来处理对数据的并发访问。这就是`volatile`关键字，它指示在应用程序代码使用字段或变量之前，必须重新从主内存中读取其值。同样，在修改了`volatile`值后，一旦写入变量完成，它必须立即写回主内存。
- en: 'One common usage of the `volatile` keyword is in the “run-until-shutdown” pattern.
    This is used in multithreaded programming where an external user or system needs
    to signal to a processing thread that it should finish the current job being worked
    on and then shut down gracefully. This is sometimes called the “graceful completion”
    pattern. Let’s look at a typical example, supposing that this code for our processing
    thread is in a class that implements `Runnable`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`关键字的一个常见用法是“运行直到关闭”模式。这在多线程编程中被使用，其中外部用户或系统需要向处理线程发出信号，告知它应该完成当前正在进行的工作，然后优雅地关闭。有时这被称为“优雅完成”模式。让我们看一个典型的例子，假设这段代码用于实现`Runnable`的类中的处理线程：'
- en: '[PRE8]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All the time that the `shutdown()` method is not called by another thread, the
    processing thread continues to sequentially process tasks (this is often combined
    very usefully with a `BlockingQueue` to deliver work). Once `shutdown()` is called
    by another thread, the processing thread immediately sees the `shutdown` flag
    change to `true`. This does not affect the running job, but once the task finishes,
    the processing thread will not accept another task and instead will shut down
    gracefully.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 只要另一个线程没有调用`shutdown()`方法，处理线程就会继续顺序处理任务（这通常与`BlockingQueue`结合非常有用以传递工作）。一旦另一个线程调用了`shutdown()`，处理线程立即看到`shutdown`标志改为`true`。这不会影响正在运行的作业，但一旦任务完成，处理线程将不会接受另一个任务，而是会优雅地关闭。
- en: However, useful as the `volatile` keyword is, it does not provide a complete
    protection of state—as we can see by using it to mark the field in `Counter` as
    `volatile`. We might naively assume that this would protect the code in `Counter`.
    However, it does not. To see this, modify the previous `Counter` example and add
    the word `volatile` to the field `i` and rerun the example. The observed nonzero
    value of the anomaly (and therefore, the presence of the lost update problem)
    tells us that by itself, `volatile` does not make code threadsafe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管 `volatile` 关键字很有用，但它并不能完全保护状态——正如我们在 `Counter` 中使用它来标记字段 `volatile` 一样。我们可能天真地假设这会保护
    `Counter` 中的代码。然而，实际上并非如此。为了验证这一点，修改之前的 `Counter` 示例，并在字段 `i` 中添加 `volatile` 关键字，然后重新运行示例。观察到的非零异常值（因此丢失更新问题的存在）告诉我们，仅凭
    `volatile` 关键字并不能使代码线程安全。
- en: Useful Methods of Thread
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thread 的有用方法
- en: The `Thread` class has a number of methods to make your life easier when you’re
    creating new application threads. This is not an exhaustive list—there are many
    other methods on `Thread`, but this is a description of some of the more common
    methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类具有许多方法，可在创建新应用程序线程时为您提供便利。这不是一个详尽的列表——`Thread` 上还有许多其他方法，但这是一些常见方法的描述。'
- en: getId()
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getId()
- en: This method returns the ID number of the thread, as a `long`. This ID will stay
    the same for the lifetime of the thread and is guaranteed to be unique within
    this instance of the JVM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回线程的ID号，作为 `long` 类型。此ID在线程生命周期内保持不变，并且在此 JVM 实例中保证是唯一的。
- en: getPriority() and setPriority()
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getPriority() 和 setPriority()
- en: These methods are used to control the priority of threads. The scheduler decides
    how to handle thread priorities; for example, one strategy could be to not have
    any low-priority threads run while there are high-priority threads waiting. In
    most cases, there is no way to influence how the scheduler will interpret priorities.
    Thread priorities are represented as an integer between 1 and 10, with 10 being
    the highest.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于控制线程的优先级。调度程序决定如何处理线程优先级；例如，一种策略可能是在高优先级线程等待时不运行低优先级线程。在大多数情况下，无法影响调度程序如何解释优先级。线程优先级表示为一个介于1和10之间的整数，10表示最高优先级。
- en: setName() and getName()
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setName() 和 getName()
- en: These methods allow the developer to set or retrieve a name for an individual
    thread. Naming threads is good practice, as it can make debugging much, much easier,
    especially in a tool such as JDK Mission Control (which we will discuss briefly
    in [Chapter 13](ch13.xhtml#javanut8-CHP-13)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许开发者为每个线程设置或检索名称。命名线程是一种良好的实践，特别是在像 JDK Mission Control 这样的工具中，它可以极大地简化调试（我们将在[第13章](ch13.xhtml#javanut8-CHP-13)中简要讨论）。
- en: getState()
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getState()
- en: This returns a `Thread.State` object that indicates which state this thread
    is in, as per the values defined in [“Thread Lifecycle”](#javanut8-CHP-6-SECT-5.1).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个 `Thread.State` 对象，指示此线程处于哪种状态，其值如[“线程生命周期”](#javanut8-CHP-6-SECT-5.1)中定义的那样。
- en: isAlive()
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isAlive()
- en: This method is used to test whether a thread is still alive.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于测试线程是否仍然存活。
- en: start()
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: start()
- en: This method is used to create a new application thread, and to schedule it,
    with the `run()` method being the entry point for execution. A thread terminates
    normally when it reaches the end of its `run()` method or when it executes a `return`
    statement in that method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于创建一个新的应用程序线程，并安排其运行，其中 `run()` 方法是执行的入口点。当线程在其 `run()` 方法中达到结尾或在该方法中执行
    `return` 语句时，线程会正常终止。
- en: interrupt()
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: interrupt()
- en: If a thread is blocked in a `sleep()`, `wait()`, or `join()` call, then calling
    `interrupt()` on the `Thread` object that represents the thread will cause the
    thread to be sent an `InterruptedException` (and to wake up).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程在 `sleep()`、`wait()` 或 `join()` 调用中被阻塞，则在表示该线程的 `Thread` 对象上调用 `interrupt()`
    将导致线程收到 `InterruptedException`（并唤醒）。
- en: If the thread was involved in interruptible I/O, then the I/O will be terminated
    and the thread will receive a `ClosedByInterruptException`. The interrupt status
    of the thread will be set to `true`, even if the thread was not engaged in any
    activity that could be interrupted.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程涉及可中断 I/O，则 I/O 将被终止，并且线程将收到 `ClosedByInterruptException`。即使线程未参与可以中断的任何活动，线程的中断状态也将设置为
    `true`。
- en: join()
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: join()
- en: The current thread waits until the thread corresponding to the `Thread` object
    has died. It can be thought of as an instruction not to proceed until the other
    thread has completed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程等待，直到与 `Thread` 对象对应的线程已经终止。可以将其视为一条指令，要求在另一个线程完成之前不要继续执行。
- en: setDaemon()
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setDaemon()
- en: A *user thread* is a thread that will prevent the process from exiting if it
    is still alive—this is the default for threads. Sometimes, programmers want threads
    that will not prevent an exit from occurring—these are called *daemon threads*.
    The status of a thread as a daemon or user thread can be controlled by the `setDaemon()`
    method and checked using `isDaemon()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户线程*是一种线程，如果它仍然活动，将阻止进程退出 — 这是线程的默认行为。有时，程序员希望线程不阻止退出的发生 — 这些称为*守护线程*。线程作为守护线程或用户线程的状态可以通过`setDaemon()`方法来控制，并可以使用`isDaemon()`来检查。'
- en: setUncaughtExceptionHandler()
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setUncaughtExceptionHandler()
- en: 'When a thread exits by throwing an exception (i.e., one that the program did
    not catch), the default behavior is to print the name of the thread, the type
    of the exception, the exception message, and a stack trace. If this isn’t sufficient,
    you can install a custom handler for uncaught exceptions in a thread. For example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程通过抛出异常（即程序没有捕获的异常）退出时，默认行为是打印线程的名称、异常类型、异常消息和堆栈跟踪。如果这不足够，您可以为线程安装自定义的未捕获异常处理程序。例如：
- en: '[PRE9]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This can be useful in some situations; for example, if one thread is supervising
    a group of other worker threads, then this pattern can be used to restart any
    threads that die.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能很有用；例如，如果一个线程正在监督一组其他工作线程，那么这种模式可以用来重新启动任何死掉的线程。
- en: There is also `setDefaultUncaughtExceptionHandler()`, a `static` method that
    sets a backup handler for catching any thread’s uncaught exceptions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`setDefaultUncaughtExceptionHandler()`，一个`static`方法，设置一个备用处理程序来捕获任何线程的未捕获异常。
- en: Deprecated Methods of Thread
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程的弃用方法
- en: In addition to the useful methods of `Thread`, there are a number of dangerous
    methods you should not use. These methods form part of the original Java thread
    API but were quickly found to be unsuitable for developer use. Unfortunately,
    due to Java’s backward compatibility requirements, it has not been possible to
    remove them from the API. Developers simply need to be aware of them and to avoid
    using them under *all* circumstances.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Thread`的有用方法外，还有一些危险的方法不应使用。这些方法是原始Java线程API的一部分，但很快就被发现不适合开发者使用。不幸的是，由于Java的向后兼容性要求，无法将它们从API中移除。开发者需要意识到它们，并在*所有*情况下都避免使用。
- en: stop()
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stop()
- en: '`Thread.stop()` is almost impossible to use correctly without violating concurrent
    safety, as `stop()` kills the thread immediately, without giving it any opportunity
    to recover objects to legal states. This is in direct opposition to principles
    such as concurrent safety and so should never be used.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.stop()` 几乎不可能正确使用，因为`stop()`会立即终止线程，而不给它恢复对象到合法状态的机会。这与并发安全等原则直接相反，因此永远不应使用。'
- en: suspend(), resume(), and countStackFrames()
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: suspend()、resume()和countStackFrames()
- en: The `suspend()` mechanism does not release any monitors it holds when it suspends,
    so any other thread that attempts to access those monitors will deadlock. In practice,
    this mechanism produces race conditions between these deadlocks and `resume()`
    that render this group of methods unusable. The method `countStackFrames()` only
    works when called on a suspended thread so is also made nonfunctional by this
    restriction.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当`suspend()`机制挂起时，不会释放它所持有的任何监视器，因此任何试图访问这些监视器的其他线程都将导致死锁。在实践中，这种机制在这些死锁和`resume()`之间产生竞态条件，使得这组方法无法使用。方法`countStackFrames()`仅在对挂起线程调用时才起作用，因此也被此限制禁用。
- en: destroy()
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: destroy()
- en: This method was never implemented—it would have suffered from the same race
    condition issues as `suspend()` if it had been.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从未被实现 — 如果实现了，它将会遇到与`suspend()`相同的竞态条件问题。
- en: All of these deprecated methods should always be avoided. A set of safe alternative
    patterns that achieve the same intended aims as the preceding methods have been
    developed. A good example of one of these patterns is the run-until-shutdown pattern
    that we already met.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些已弃用的方法都应该被始终避免使用。已开发出一组安全替代模式，这些模式实现了与前述方法相同的预期目标。其中一个良好的示例是我们已经见过的运行至关闭模式。
- en: Working with Threads
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程处理
- en: 'To work effectively with multithreaded code, you need the basic facts about
    monitors and locks at your command. This checklist contains the main facts you
    should know:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地处理多线程代码，您需要掌握关于监视器和锁的基本事实。这份清单包含了您应该了解的主要事实：
- en: Synchronization is about protecting object state and memory, not code.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步是保护对象状态和内存，而不是代码。
- en: Synchronization is a cooperative mechanism between threads. One bug can break
    the cooperative model and have far-reaching consequences.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步是线程之间的一种合作机制。一个 bug 可能会破坏这种合作模型，并产生深远的后果。
- en: Acquiring a monitor only prevents other threads from acquiring the monitor—it
    does not protect the object.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取监视器只会防止其他线程获取监视器 —— 它并不会保护对象本身。
- en: Unsynchronized methods can see (and modify) inconsistent state, even while the
    object’s monitor is locked.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非同步方法在锁定对象的监视器时可能会看到（并修改）不一致的状态。
- en: Locking an `Object[]` doesn’t lock the individual objects.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定 `Object[]` 不会锁定各个对象。
- en: Primitives are not mutable, so they can’t (and don’t need to) be locked.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型是不可变的，因此它们不能（也不需要）被锁定。
- en: '`synchronized` can’t appear on a method declaration in an interface.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口方法声明中不能出现 `synchronized`。
- en: Inner classes are just syntactic sugar, so locks on inner classes have no effect
    on the enclosing class (and vice versa).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部类只是语法糖，因此对内部类的锁定对外部类没有影响（反之亦然）。
- en: Java’s locks are *reentrant*. This means that if a thread holding a monitor
    encounters a synchronized block for the same monitor, it can enter the block.^([1](ch06.xhtml#idm45927729626048))
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的锁是 *可重入* 的。这意味着如果持有监视器的线程遇到同一监视器的同步块，它可以进入该块。^([1](ch06.xhtml#idm45927729626048))
- en: We’ve also seen that threads can be asked to sleep for a period of time. It
    is also useful to go to sleep for an unspecified amount of time and wait until
    a condition is met. In Java, this is handled by the `wait()` and `notify()` methods
    that are present on `Object`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到线程可以被要求睡眠一段时间。同样有用的是无限期地睡眠，直到满足条件。在 Java 中，这通过 `Object` 上存在的 `wait()` 和
    `notify()` 方法来处理。
- en: Just as every Java object has a lock associated with it, every object maintains
    a list of waiting threads. When a thread calls the `wait()` method of an object,
    any locks the thread holds are temporarily released, and the thread is added to
    the list of waiting threads for that object and stops running. When another thread
    calls the `notifyAll()` method of the same object, the object wakes up the waiting
    threads and allows them to continue running.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个 Java 对象都有一个关联的锁一样，每个对象都维护着一个等待线程的列表。当线程调用对象的 `wait()` 方法时，线程持有的任何锁都会被临时释放，并且该线程会被添加到该对象的等待线程列表中，并停止运行。当另一个线程调用相同对象的
    `notifyAll()` 方法时，对象会唤醒等待的线程，并允许它们继续运行。
- en: 'For example, let’s look at a simplified version of a queue that is safe for
    multithreaded use:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一个简化版本的队列，它对多线程使用是安全的：
- en: '[PRE10]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class uses a `wait()` on the instance of `WaitingQueue` if the queue is
    empty (which would make the `pop()` fail). The waiting thread temporarily releases
    its monitor, allowing another thread to claim it—a thread that might `push()`
    something new onto the queue. When the original thread is woken up again, it is
    restarted where it originally began to wait, and it will have reacquired its monitor.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列为空（导致 `pop()` 失败），这个类会在 `WaitingQueue` 的实例上使用 `wait()`。等待的线程会暂时释放其监视器，允许另一个线程来获取它
    —— 一个可能会在队列上 `push()` 新内容的线程。当原始线程再次被唤醒时，它会从最初等待的位置重新开始运行，并重新获取它的监视器。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`wait()` and `notify()` must be used inside a `synchronized` method or block,
    because of the temporary relinquishing of locks required for them to work properly.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 和 `notify()` 必须在 `synchronized` 方法或块中使用，因为它们需要临时放弃锁才能正常工作。'
- en: In general, most developers shouldn’t roll their own classes like the one in
    this example—instead, use the libraries and components that the Java platform
    provides for you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，大多数开发者不应该像本例中这样自己编写类——而是应该使用 Java 平台为你提供的库和组件。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve discussed Java’s view of memory and concurrency and seen
    how these topics are intrinsically linked.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Java 对内存和并发的视图，以及这些主题如何密切相关。
- en: Java’s garbage collection is one of the major aspects of the platform that simplifies
    development by removing the need for programmers to manually manage memory. We
    have seen how Java provides advanced GC capabilities and how modern versions of
    Java use the partially concurrent G1 collector by default.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的垃圾回收是简化开发的重要方面之一，因为它消除了程序员手动管理内存的需要。我们已经看到 Java 提供了先进的 GC 能力，以及现代版本默认使用部分并发的
    G1 收集器。
- en: We have also discussed how, as processors develop more and more cores, we will
    need to use concurrent programming techniques to use those cores effectively.
    In other words, concurrency is key to the future of well-performing applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着处理器开发出越来越多的核心，我们将需要使用并发编程技术来有效地利用这些核心。换句话说，并发性是未来高性能应用的关键。
- en: 'Java’s threading model is based on three fundamental concepts:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Java的线程模型基于三个基本概念：
- en: Shared, visible-by-default mutable state
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的、默认可见的可变状态
- en: Objects are easily shared between different threads in a process, and they can
    be changed (“mutated”) by any thread holding a reference to them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以在进程中的不同线程之间轻松共享，并且任何持有它们引用的线程都可以对它们进行改变（“突变”）。
- en: Preemptive thread scheduling
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 抢占式线程调度
- en: The OS thread scheduler can swap threads on and off cores at more or less any
    time.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统线程调度程序可以随时在核心上切换线程。
- en: Object state can only be protected by locks
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对象状态只能由锁来保护
- en: Locks can be hard to use correctly, and state is quite vulnerable—even in unexpected
    places such as read operations.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 锁可能难以正确使用，状态在意想不到的地方（如读操作）也很容易受到影响。
- en: Taken together, these three aspects of Java’s approach to concurrency explain
    why multithreaded programming can cause so many headaches for developers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，Java在并发处理方面的这三个方面解释了为什么多线程编程会给开发者带来这么多头痛。
- en: ^([1](ch06.xhtml#idm45927729626048-marker)) Outside of Java, not all implementations
    of locks have this property.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm45927729626048-marker)) 除了Java之外，不是所有的锁实现都具有这种属性。
