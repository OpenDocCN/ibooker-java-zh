- en: Chapter 11\. Functional Approaches in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。Java中的函数式方法
- en: 'Java is—and remains—an object-oriented language. All of the design patterns
    and class types we saw in [Chapter 5](ch05.html#learnjava6-CHP-5) are still core
    to how most developers write Java code. Java is also flexible, with individual
    and corporate contributors proposing and making improvements. As *functional programming*
    (FP) moves back into the limelight, Java is keeping up. FP represents an alternate
    way to approach programming: functions, rather than objects, are the focus.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一个始终如一的面向对象语言。我们在[第5章](ch05.html#learnjava6-CHP-5)中看到的所有设计模式和类型仍然是大多数开发人员编写Java代码的核心。Java
    也是灵活的，个人和公司的贡献者提出并进行改进。随着*函数式编程*（FP）再次引起关注，Java 正在跟上。FP 代表了一种编程的替代方式：函数而不是对象是重点。
- en: Starting as far back as Java 8, Java has supported a reasonable set of functional
    features with the `java.util.function` package. This package includes several
    classes and interfaces that allow developers to use popular functional approaches
    to problem-solving. We’ll explore some of these approaches in this chapter, but
    we want to emphasize that verb, *allow*. If you don’t enjoy functional programming,
    you can safely ignore this chapter. We hope you’ll try some of the examples, though.
    There are some nice features that can make your code more compact while retaining
    its readability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8开始，Java 支持了合理的函数式特性集合，包括`java.util.function`包。该包包括几个类和接口，允许开发人员使用流行的函数式方法解决问题。我们将在本章中探讨其中一些方法，但我们想强调的是，这个动词*允许*。如果你不喜欢函数式编程，你可以安全地忽略本章。不过，我们希望你尝试一些示例。有些很好的功能可以使你的代码更加简洁，同时保持其可读性。
- en: Functions 101
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数基础
- en: The roots of functional programming extend all the way back to the 1930s, with
    American mathematician Alonzo Church and his lambda calculus. Church wasn’t running
    his calculus on any hardware, but lambda calculus formalized a way of problem-solving
    that would lead to early programming languages written for real, operating machines.^([1](ch11.html#id2199))
    The Lisp language was developed in the 1950s at MIT and ran on early iterations
    of modern computers like the IBM 700 series. If you can picture an old black-and-white
    photo with bookshelf-sized walls of blinking lights, you’ve got the right idea
    for how far back FP ideas and patterns go in the history of computing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的根源可以追溯到20世纪30年代，美国数学家阿隆佐·邱奇和他的λ演算。邱奇并没有在任何硬件上运行他的演算，但λ演算形式化了一种解决问题的方式，这种方式后来导致了为真实操作的计算机编写的早期编程语言^([1](ch11.html#id2199))。Lisp语言在20世纪50年代在MIT开发，并在像IBM
    700系列这样的现代计算机的早期版本上运行。如果你能想象一张旧的黑白照片，上面有书架大小的闪烁灯光墙，你就能理解FP思想和模式在计算机历史中有多久。
- en: But FP is not the only way to program a computer. Other paradigms, such as procedural
    programming and object-oriented programming (OOP), regularly vie for popularity.
    Happily, you can accomplish the same goals in any of those paradigms. The paradigm
    you choose usually comes down to the problem domain and more than a bit of personal
    preference.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是FP并不是编程计算机的唯一方式。其他范式，如过程式编程和面向对象编程（OOP），经常争相流行。幸运的是，你可以在任何这些范式中实现相同的目标。你选择的范式通常取决于问题域和一些个人偏好。
- en: 'Consider the simple tasks of adding two numbers and assigning that result to
    a variable. We can do this in object-oriented languages like Java, in functional
    languages like Clojure,^([2](ch11.html#id2202)) or procedural languages like C:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将两个数字相加并将结果分配给变量的简单任务。我们可以在像Java这样的面向对象语言中，也可以在像Clojure这样的函数式语言中^([2](ch11.html#id2202))，或者像C这样的过程化语言中完成这个任务：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java hit the digital scene as OOP was (again) on the rise, and it reflects those
    roots. Still, FP has always had its evangelists. Java 8 offered some substantial
    additions to the language and opened the door for fans of functional programming
    to work with Java. Let’s take a look at some of those additions and see how they
    integrate with the larger world of Java.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在面向对象编程（OOP）再次兴起时进入了数字场景，并且反映了这些根源。然而，函数式编程（FP）始终有其狂热的拥护者。Java 8 在语言中提供了一些重要的增强，并为喜欢函数式编程的人们打开了大门。让我们看看其中一些新增功能，并看看它们如何与Java的更大世界融合。
- en: Lambdas
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Inspired by the lambda calculus, *lambda expressions* (or more simply, lambdas)
    form the core unit of functional programming in Java. Lambdas are a means of encapsulating
    a bit of logic. In a functional language, functions are “first-class citizens”
    and can be created, stored, referenced, used, and passed around just like objects
    in Java. To mimic that, uh, functionality, Java 8 introduced some new syntax alongside
    several special interfaces. These additions allow you to quickly define a function
    that can replace an entire inner class. The result of that definition is still
    an object under the hood, of course, but one whose “objectness” is mostly hidden.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 受λ演算的启发，*lambda表达式*（或简称为lambdas）构成了Java中函数式编程的核心单元。在函数式语言中，函数是“一等公民”，可以像Java中的对象一样被创建、存储、引用、使用和传递。为了模仿这种功能，Java
    8引入了一些新的语法以及几个特殊的接口。这些新增功能允许你快速定义一个可以替代整个内部类的函数。当然，这种定义的结果在内部实现上仍然是一个对象，但其“对象性”大多数情况下是隐藏的。
- en: We’ll cover lambda expressions and those special interfaces in more detail throughout
    the rest of this section. Then we’ll look at a popular, concrete example of using
    these expressions to do real work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的本节中，我们将更详细地介绍lambda表达式和那些特殊的接口。然后我们将看一个流行的具体例子，演示如何使用这些表达式来进行实际工作。
- en: Lambda Expressions
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Lambda expressions are small bits of code that can accept parameters and return
    values, just like methods. Unlike methods, though, you can easily pass a lambda
    as an argument to some other method or store it in a variable like you might with
    an object reference. FP proponents prize this ability to move code around like
    data. It allows you to write interesting and dynamic code without the clutter
    of creating inner or anonymous inner classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一小段代码，可以接受参数并返回值，就像方法一样。不过，与方法不同的是，你可以轻松地将lambda作为参数传递给其他方法，或者像操作对象引用一样将其存储在变量中。函数式编程支持者看重这种能力，因为它允许你像处理数据一样编写有趣且动态的代码，而不需要创建内部或匿名内部类。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Lambdas are not meant to provide a performance boost. Although judicious use
    of lambdas often makes for more compact, more concise source code, that compression
    does not remove any complexity. Lambdas may require less typing, but they don’t
    do less work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式并不意味着提供性能提升。尽管精心使用lambda通常会导致更紧凑、更简洁的源代码，但这种压缩并未减少任何复杂性。Lambda可能需要更少的打字，但它们并不做更少的工作。
- en: 'Recall the `run()` method used by threads, which we saw so often in [Chapter 9](ch09.html#learnjava6-CHP-9).
    We created more than a few small classes that implemented the `Runnable` interface
    to supply a “body” to our threads. Small classes that do not include any state
    as instance variables are prime candidates for using lambdas: you have a well-defined
    task that you use in a well-defined situation.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下线程中经常见到的`run()`方法，我们在[第9章](ch09.html#learnjava6-CHP-9)中看到过它。我们创建了多个实现了`Runnable`接口的小类，用来为我们的线程提供“主体”。那些不包含任何状态作为实例变量的小类是使用lambda的最佳候选对象：你有一个明确定义的任务，在一个明确定义的情境中使用它。
- en: 'Let’s revisit one of our thread demonstrations and then take a peek at how
    we could use a lambda expression as an alternative to the explicit use of `Runnable`.
    We’ll simplify the `VirtualDemo` class from [“Death of a Thread”](ch09.html#learnjava6-CHP-9-SECT-2)
    and concentrate on the anonymous inner class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的一个线程演示，然后看看如何使用lambda表达式作为使用`Runnable`的明确替代方案。我们将简化来自[“线程的结束”](ch09.html#learnjava6-CHP-9-SECT-2)的`VirtualDemo`类，并专注于匿名内部类：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a new instance of `Runnable` with a simple `run()` method that prints
    a greeting and the thread’s ID number:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`Runnable`实例，其中包含一个简单的`run()`方法，用于打印问候语和线程的ID号：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Great. Everything works as expected. Now let’s replace that `runnable` variable
    with a lambda expression:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。一切都如预期那样工作。现在让我们用lambda表达式替换那个`runnable`变量：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We still start a new virtual thread, and we still store that thread in a variable
    (`t`, in both examples), but there is no evidence of the `Runnable` interface.
    We passed a somewhat strange argument to the `startVirtualThread()` method instead
    of a reference to some object. That “strange argument” is our lambda expression,
    annotated in [Figure 11-1](#learnjava6-CHP-11-FIG-lambda-1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然启动一个新的虚拟线程，并将该线程存储在一个变量中（在两个示例中都是`t`），但是没有`Runnable`接口的迹象。我们传递了一个有点奇怪的参数给`startVirtualThread()`方法，而不是一个指向某个对象的引用。那个“奇怪的参数”就是我们的lambda表达式，详见[图11-1](#learnjava6-CHP-11-FIG-lambda-1)。
- en: '![ljv6 1101](assets/ljv6_1101.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1101](assets/ljv6_1101.png)'
- en: Figure 11-1\. Basic structure of a lambda expression
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-1\. lambda表达式的基本结构
- en: This particular lambda is very simple. We don’t pass it any arguments, and it
    does not return a value. Often that’s all you need. But lambdas are capable of
    much more. Lambda expressions also support arguments, can return values, and can
    have more interesting bodies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的lambda非常简单。我们不传递任何参数给它，它也不返回任何值。通常这就是你需要的全部。但是lambda可以做得更多。Lambda表达式还支持参数，可以返回值，并且可以有更有趣的主体。
- en: Passing arguments
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: If we think about lambdas as bits of code, it’s reasonable to compare them to
    regular methods. Regular methods do encapsulate logic, just like lambdas. But
    many of the methods we’ve seen in previous chapters also accept arguments. Can
    we supply arguments to a lambda?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将lambda视为代码片段，将它们与常规方法进行比较是合理的。常规方法确实封装了逻辑，就像lambda一样。但是在前几章中看到的许多方法还接受参数。我们可以给lambda提供参数吗？
- en: 'Consider an iterator that walks through the elements of a Java collection.
    We saw several examples in [Chapter 7](ch07.html#learnjava6-CHP-7). In those examples,
    we used an iterator inside a loop, with the body of the loop doing something with
    the given element of the collection on each pass. Recall our tree-painting loop
    from [“Application: Trees on the Field”](ch07.html#learnjava6-CHP-7-SECT-8):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个遍历Java集合元素的迭代器。我们在[第7章](ch07.html#learnjava6-CHP-7)中看到了几个示例。在这些示例中，我们在循环中使用迭代器，循环的主体在每次通过时对集合的给定元素执行某些操作。回想一下我们从[“应用程序：树在田野上”](ch07.html#learnjava6-CHP-7-SECT-8)中的树绘制循环：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The alternate `for` loop uses the iterator from `trees` to get every individual
    tree, and then tells that tree to draw itself on our field. We could replace that
    loop with a lambda and the `forEach()` method of the `Iterable` interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 替代的`for`循环使用了来自`trees`的迭代器来获取每棵独立的树，然后告诉该树在我们的领域上绘制自己。我们可以用一个lambda和`Iterable`接口的`forEach()`方法替换那个循环：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the same arrow operator, but instead of an empty pair of parentheses,
    we have a variable, `t` on the lefthand side. That variable receives one tree
    at a time from the `trees` collection, just like the alternate `for` loop from
    the first snippet. And just like the body of that `for` loop, you can use the
    current tree on the righthand side of the expression. With this arrangement, we
    get a slightly more concise version of our loop, but it retains its readability.
    You can use this handy trick with any collection that implements the `Iterable`
    interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到相同的箭头操作符，但是左边没有一对空括号，而是一个变量`t`。该变量从`trees`集合中一次接收一棵树，就像第一个片段中的替代`for`循环一样。就像那个`for`循环的主体一样，你可以在表达式的右边使用当前树。通过这种安排，我们得到了一个稍微简洁的循环版本，但它保留了其可读性。你可以在任何实现了`Iterable`接口的集合中使用这个方便的技巧。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Terms like *concise* and *readable* are subjective judgments. Proponents of
    FP definitely find the more compact syntax of lambdas easier to read, but those
    folks are already comfortable with the notation. We hope you’ll try the examples
    and exercises in this chapter to gain a little of that familiarity. We do like
    lambdas and use them in a number of situations, but they are never required. If
    you don’t find lambdas useful or readable after trying them out, you don’t need
    to use them in your own code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 像*简洁*和*可读性*这样的术语是主观判断。函数式编程的支持者确实发现lambda更紧凑的语法更易读，但这些人已经对这种符号感到满意。我们希望你能尝试本章中的例子和练习，以获得一点熟悉感。我们确实喜欢lambda，并在许多情况下使用它们，但它们从来不是必需的。如果你尝试过后发现lambda对你没有用处或不易读，则不需要在自己的代码中使用它们。
- en: You may have noticed that our first lambda expression for a simple thread body
    took no arguments, so we used an empty set of parentheses on the lefthand side.
    But in this most recent example, we had one argument and no parentheses. The single
    argument form is so common that the compiler allows this shorthand with no parentheses.
    If you have no arguments, or more than one argument, the parentheses are required.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们第一个简单线程主体的lambda表达式没有接受任何参数，所以我们在左边用了一个空括号。但在这个最近的例子中，我们有一个参数却没有括号。单个参数形式是如此常见，以至于编译器允许这种简写，即没有括号。如果你没有参数，或者有多个参数，则需要括号。
- en: Expression bodies
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式主体
- en: Lambda expressions shine in situations where you would otherwise use an anonymous
    inner class. You can’t substitute lambdas for all situations that call for anonymous
    inner classes, but there are a surprising number of spots throughout Java that
    do work with lambdas. With this variety of applications comes the need for more
    complex computing beyond print statements. If you need to perform a few statements
    or work with a temporary variable, for example, you can enclose the body of the
    expression in curly braces, just like a method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式在你原本需要使用匿名内部类的情况下表现出色。你不能将lambda替换为所有需要匿名内部类的情况，但是在Java中有许多意外的情况可以使用lambda。随着这种应用的多样化，需要更复杂的计算超出了打印语句。例如，如果你需要执行几个语句或使用临时变量，你可以将表达式体放在花括号中，就像一个方法一样。
- en: 'Imagine the trees in our game are seasonal. You could specify the color of
    their leaves before drawing them. You can still use a lambda:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们游戏中的树木是季节性的。你可以在绘制之前指定它们叶子的颜色。你仍然可以使用lambda：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Presumably our fictitious `getSeasonalColor()` method does some nice date-based
    calculating and returns an appropriate color. Notice that you can use methods
    (and most variables) from the rest of the class inside our lambda expression.
    Lambdas are quite powerful. But part of their power comes from judicious use—a
    20-line expression body would probably hurt the readability of your code. But
    if you have a few lambdas with a few lines, you’re in good shape.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们虚构的`getSeasonalColor()`方法执行一些基于日期的漂亮计算，并返回一个合适的颜色。注意，在我们的lambda表达式中，你可以使用来自类其余部分的方法（和大多数变量）。Lambda非常强大。但是它们的一部分力量来自于明智的使用——一个20行的表达式体可能会影响你代码的可读性。但是如果你有几个只有几行的lambda，那你就很好了。
- en: Beyond keeping your lambdas readable, we want to point out a few quirks that
    might crop up for you. If you do want to use a local variable from the enclosing
    scope, it must be “effectively final” per the documentation. Recall that `final`
    variables can’t be modified. *Effectively final* variables are ones that *are
    not* modified even though they might not have the official `final` keyword in
    their declaration. If you try to use a nonfinal, local variable, the compiler
    will complain. Happily, this restriction only applies to local variables. You
    are free to use (and even modify) variables declared as members of the enclosing
    class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保持你的lambda表达式易读之外，我们想指出一些可能会出现的特殊情况。如果你确实想要使用来自封闭作用域的局部变量，则必须“有效地是最终的”，如文档所述。记住，`final`变量是不能被修改的。*有效最终*变量是那些*虽然可能没有官方的`final`关键字在它们的声明中，但实际上并没有被修改*的变量。如果你试图使用一个非最终的局部变量，编译器会报错。幸运的是，这个限制只适用于局部变量。你可以自由地使用（甚至修改）声明为封闭类成员的变量。
- en: 'The other quirk revolves around the keyword `this`. If you recall from [“The
    “this” reference”](ch05.html#learnjava6-CHP-5-SECT-2.2.1), `this` gives you a
    reference to the current object. It’s handy when methods or constructors have
    argument names that overlap with member variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关键字`this`的另一个特殊之处是。如果你还记得[“this引用”](ch05.html#learnjava6-CHP-5-SECT-2.2.1)，`this`给你一个对当前对象的引用。当方法或构造函数的参数名与成员变量重叠时，这非常方便：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While you might reasonably think that `this` inside a lambda body would refer
    to the lambda itself, it actually still refers to the enclosing class. This quirk
    means you can use `this` inside a lambda just as you would with the constructor
    in the previous example. It makes sure your lambdas have access to the stuff in
    your class, even if a local variable would otherwise shadow something.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能合理地认为lambda体内的`this`会引用lambda本身，实际上它仍然引用封闭类。这种特殊情况确保你可以像前面的构造函数一样在lambda内部使用`this`。它确保你的lambda可以访问类中的内容，即使一个局部变量本来会掩盖某些内容。
- en: Returning values
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: 'Whether your lambda is a pithy one-liner or includes a readability-busting
    dozen lines, you can also return a value. A (deceptively) simple example is an
    incrementing function that takes an integer argument and returns an integer that
    is one more than the input. The expression itself would look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的lambda是一个简短的一行还是包含了十几行的代码，你也可以返回一个值。一个（看似）简单的例子是一个递增函数，它接受一个整数参数并返回比输入多一的整数。表达式本身看起来会像这样：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this form, Java will compute the answer to `x + 1` and return it. If we
    have a multiline body that should return a value, we can use the `return` keyword:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，Java将计算`x + 1`的答案并返回它。如果我们有一个多行体应该返回一个值，我们可以使用`return`关键字：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Explicit returns can be handy when you have `if` statements in the body. But
    the simpler form is preferable if your expression fits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的表达式中包含`if`语句时，显式返回可能会很方便。但如果你的表达式适合简单形式，则简单形式更可取。
- en: Functional Interfaces
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能接口
- en: 'You may be wondering how Java categorizes our simple lambda expression. Is
    it an `int` like the input, or the result? Is it an object like so much of Java?
    Is it something we haven’t seen yet? Let’s see if *jshell* can shed any light:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想知道Java如何对我们简单的lambda表达式进行分类。它是像输入一样的`int`，还是结果？它是像Java的很多对象一样的对象？还是我们尚未见过的东西？让我们看看*jshell*是否能为此提供任何线索：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Hmm, not really what we were hoping for, but that phrase *functional interface*
    is a clue. Let’s try that `var` keyword we saw in [“Inferring types”](ch04.html#learnjava6-CHP-4-SECT-4.2.1)
    and see if our lambda expression can be inferred:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不是我们所希望的，但短语*功能接口*是一个线索。让我们尝试在[“推断类型”](ch04.html#learnjava6-CHP-4-SECT-4.2.1)中看到的`var`关键字，看看我们的lambda表达式是否可以推断出来：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Shoot. *jshell* did recognize our lambda expression, but that recognition isn’t
    enough to establish a type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕。*jshell* 确实识别了我们的lambda表达式，但这种识别并不足以确定类型。
- en: 'So what is a lambda expression’s type? In the case of our simple incrementing
    lambda, it turns out to be an `IntFunction`, a function that accepts one `int`
    as an argument and returns an `int`. The `IntFunction` interface lives in the
    `java.util.function` package alongside several other functional interfaces. Each
    interface in this package represents a different “shape” that a lambda expression
    can take. Let’s try it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么lambda表达式的类型是什么？对于我们简单的递增lambda来说，它的类型是`IntFunction`，一个接受一个`int`作为参数并返回一个`int`的函数。`IntFunction`接口位于`java.util.function`包中，与该包中的其他几个功能接口并列。让我们试试看：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hooray! We didn’t get an error! (Although that resulting value looks rather
    daunting.) Happily, we don’t need to worry about the internal details of our lambda,
    as long as we can apply it to some data. But just how would we apply it?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！我们没有得到错误！（尽管结果看起来相当令人生畏。）幸运的是，只要我们可以将其应用于一些数据，我们就不需要担心lambda的内部细节。但是我们该如何应用它呢？
- en: 'Take a look at the [online documentation](https://oreil.ly/pgX7J) for the interface
    and you’ll see it has one method, `apply()`, appropriately enough:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[在线文档](https://oreil.ly/pgX7J)以了解界面，你会发现它有一个方法，`apply()`，相当恰当：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another hooray! Our incrementor increments! The other interfaces have a similar
    method defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个万岁！我们的增量器增加了！其他接口有类似定义的方法。
- en: 'The shapes that we mentioned cover the different arrangements of the arguments
    and results of lambda expressions. If we wanted to work with `double` values instead
    of `int`s, for example, we could use the `DoubleFunction` interface. If we want
    to supply an object as an argument but don’t need to return a value, we could
    use the `Consumer<T>` interface. (Since `Consumer` works on reference types, it
    is parameterized. If we really did want to store a lambda that accepted a string,
    we would use the type `Consumer<String>`.) Or maybe we have a lambda that takes
    no arguments but generates a `long` value: the `LongSupplier` interface will do
    the trick. We won’t reproduce the full list of functional interfaces here, but
    it’s worth looking at the [package summary](https://oreil.ly/ksK1Z) online.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的形状涵盖了lambda表达式参数和结果的不同排列方式。例如，如果我们想使用`double`值而不是`int`，我们可以使用`DoubleFunction`接口。如果我们想要提供一个对象作为参数但不需要返回值，我们可以使用`Consumer<T>`接口。（由于`Consumer`适用于引用类型，它是参数化的。如果我们确实想存储接受字符串的lambda表达式，我们将使用类型`Consumer<String>`。）或者也许我们有一个不接受参数但生成`long`值的lambda：`LongSupplier`接口将解决问题。我们不会在此重现所有功能接口的完整列表，但值得查看[包摘要](https://oreil.ly/ksK1Z)在线查看。
- en: As you find more situations where you can use lambdas, you’ll see how all these
    different shapes get used. But it’s important to point out that the term *functional
    interface* can apply to any interface that has a single abstract method (often
    abbreviated as SAM in the documentation). In [Chapter 12](ch12.html#learnjava6-CHP-12),
    for example, we’ll use lambdas to handle user interface events like clicking a
    button. Button events are reported to `ActionListener`s. The `ActionListener`
    interface has one abstract method, `actionPerformed()`, so it qualifies as a functional
    interface, even though it was part of Java long before these functional features
    were added.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发现更多可以使用lambda的情况时，您会看到所有这些不同的形状如何被使用。但重要的是要指出，“功能接口”这个术语可以应用于具有单个抽象方法的任何接口（文档中通常缩写为SAM）。例如，在[第12章](ch12.html#learnjava6-CHP-12)中，我们将使用lambda来处理用户界面事件，比如单击按钮。按钮事件被报告给`ActionListener`。`ActionListener`接口有一个抽象方法，`actionPerformed()`，因此它符合功能接口的条件，即使在添加这些功能特性之前，它早已是Java的一部分。
- en: Method References
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'One other feature is associated with Java’s functional approach: a *method
    reference*. Sometimes your lambda expressions are really just wrappers for other
    methods. Consider the very popular task of printing out the contents of a collection.
    We could use the `forEach()` method we just learned about and print the elements
    of a list using a lambda:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java的功能性方法相关的另一个特性是*方法引用*。有时，您的lambda表达式实际上只是其他方法的包装器。考虑到一个非常流行的任务，即打印集合的内容。我们可以使用刚学到的`forEach()`方法，并使用lambda打印列表的元素：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that our lambda expression simply shuttles each string to the `System.out.println()`
    method. This is just the right candidate for a method reference.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们的lambda表达式只是将每个字符串传递到`System.out.println()`方法。这正是方法引用的合适候选者。
- en: 'We specify such a reference with a double-colon operator separating the method
    from its object (or its class, in the case of a `static` method):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个双冒号运算符来指定这样的引用，将方法与其对象（或其类，对于`static`方法而言）分开：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Very compact and still readable. Method references only work in a narrow set
    of circumstances, but they are popular options wherever they’re allowed. As with
    lambda expressions in general, there is no real performance benefit versus using
    a lambda. Indeed, the Java compiler creates a lambda expression out of our method
    reference behind the scenes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 非常紧凑但仍然易读。方法引用只在一组狭窄的情况下起作用，但它们是受欢迎的选择，只要允许的地方都可以使用。与一般的lambda表达式一样，使用方法引用并没有真正的性能优势。事实上，Java编译器在幕后将我们的方法引用创建为lambda表达式：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Feel free to use method references where they fit, but it’s also fine to stick
    with an explicit lambda expression if you find it easier to read.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现阅读起来更容易，可以随意使用方法引用来适应它们，但如果您觉得更容易阅读，则使用明确的lambda表达式也是可以的。
- en: 'Practical Lambdas: Sorting'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用的Lambda表达式：排序
- en: 'Gosh, that was a lot of theory! It’s time to put these lambda expressions to
    use in some code you often find in real applications: sorting data. Sorting is
    a common task; we talked about it in [“A Closer Look: The sort() Method”](ch07.html#learnjava6-CHP-7-SECT-7)
    while discussing collections. Where do lambdas fit in?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪，那是很多的理论！现在是时候在一些您在真实应用程序中经常找到的代码中使用这些lambda表达式了：对数据进行排序。排序是一个常见的任务；我们在讨论集合时已经谈过它了[“更近距离观察：sort()方法”](ch07.html#learnjava6-CHP-7-SECT-7)。lambda在哪里适合？
- en: To put any list in order, you need a way of comparing two elements in the list
    so you know which one should come before the other. Some lists—say a list of employee
    salaries or a list of file and subfolder names in a given directory—have a fairly
    natural ordering that suffices in most cases. But sometimes you need a more complex
    ordering, like sorting the subfolders to the top before the files. You could implement
    the `Comparable` interface like you did before, or create a custom class that
    implements the closely related `Comparator` interface, but you could also supply
    a lambda.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要对任何列表进行排序，您需要一种比较列表中两个元素的方法，以便知道哪个应该排在前面。有些列表——比如员工薪水列表或给定目录中文件和子文件夹名称列表——有一个相当自然的排序，在大多数情况下足够。但有时您需要更复杂的排序，比如将子文件夹在文件之前排序。您可以像以前一样实现`Comparable`接口，或者创建一个实现紧密相关的`Comparator`接口的自定义类，但也可以提供lambda。
- en: 'For a lambda expression to help with sorting, it needs to behave like the `compare()`
    method of `Comparator`. We need an expression that takes two arguments, say `a`
    and `b`, and returns one of three `int` values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于lambda表达式来帮助排序，它需要像`Comparator`的`compare()`方法那样运行。我们需要一个接受两个参数，比如`a`和`b`，并返回三个`int`值之一的表达式：
- en: Something less than zero if `a < b`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a < b` 则为负数
- en: Something greater than zero if `a > b`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a > b` 则为正数
- en: Zero if `a == b`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a == b` 则为零
- en: 'The magic of lambdas allows us to decide *how* we organize a list in a dynamic
    way. The `java.util.Collections` helper class contains a `sort()` method that
    accepts a collection to sort, along with a comparator to provide the ordering.
    We can use a lambda to do that comparing. For example, we could create a simple
    lambda to sort our `names` list in alphabetical order:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的魔力使我们能够动态地决定如何组织列表。`java.util.Collections` 辅助类包含一个 `sort()` 方法，该方法接受要排序的集合，以及提供排序顺序的比较器。我们可以使用
    lambda 来进行比较。例如，我们可以创建一个简单的 lambda 来按字母顺序排序我们的 `names` 列表：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Arranged as expected, although we could have used any of Java’s sorting tricks
    to get this default ordering. Let’s reverse the ordering:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 排序如预期一样，虽然我们可以使用 Java 的任何排序技巧来获得这种默认排序。让我们反转排序：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Neat! All we had to do was swap the order of the arguments using the `compareTo()`
    method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！我们只需使用 `compareTo()` 方法交换参数的顺序。
- en: 'Lambdas can do more, of course, especially when you need to order something
    a little more complex than a list of names. Imagine taking the trees in our apple
    tossing game and sorting them by their distance from the origin, `(0,0)`, using
    a slightly more interesting lambda:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，lambda 可以做更多的事情，特别是当您需要对一些比名字列表更复杂的东西进行排序时。想象一下，将我们苹果投掷游戏中的树按照它们距离原点 `(0,0)`
    的距离进行排序，使用一个稍微有趣的 lambda：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We made this expression body more verbose than necessary to emphasize that
    lambdas can have many lines of code. This lambda probably strains readability,
    but it also highlights a handy side effect of such expressions: you get to see
    the code being used to sort right where the sorting is done. This self-documenting
    feature is another reason FP has so many proponents.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个表达式体写得比必要的更冗长，以强调 lambda 可以有多行代码。这个 lambda 可能会使可读性下降，但它也突显了这种表达式的一个方便的副作用：您可以在排序时直接看到用于排序的代码。这个自我记录的特性是
    FP 有这么多支持者的另一个原因。
- en: Streams
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: As we’ve noted before, lambda expressions don’t do anything that you couldn’t
    accomplish using other features of Java, but they provide a different way to think
    about problems. In that same vein, the Java Streams API (not to be confused with
    all of the various “Stream” classes, like `PrintStream` in the `java.io` package)
    provides a different way to think about data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所指出的，lambda 表达式并没有做任何其他 Java 功能无法完成的事情，但它们提供了一种不同的解决问题的方式。在同样的思路下，Java
    Streams API（不要与所有各种“Stream”类混淆，比如 `java.io` 包中的 `PrintStream`）提供了一种不同的处理数据的方式。
- en: You can get a stream from one of the classes in the `java.util.stream` package
    or by using the `stream()` method of a collection. A stream provides a steady
    flow of objects, and you perform *operations* on each object as you encounter
    it. Operations can filter out unwanted objects, count them, or even alter them
    before passing them along. In situations where you have very large amounts of
    data, streams offer a concise way to process all of that data. As a programmer,
    you can concentrate on how you handle a single object and let the stream do the
    work of getting those single objects ready for you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 `java.util.stream` 包中的某个类中获取流，或者使用集合的 `stream()` 方法。流提供了对象的稳定流动，您在遇到对象时对每个对象执行
    *操作*。操作可以过滤掉不需要的对象，计数它们，甚至在将它们传递之前对它们进行修改。在有大量数据的情况下，流提供了一种简洁的方式来处理所有这些数据。作为程序员，您可以专注于如何处理单个对象，并让流完成为您准备这些单个对象的工作。
- en: Sources and Operations
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来源和操作
- en: To try out streams, we’ll need a source of data. An easy start is using the
    `stream()` method on any class implementing the `Collection` interface or one
    of its descendants. (Arrays don’t have a built-in stream option, but you can create
    one easily enough with the `Stream.of()` static method.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试流，我们需要数据源。一个简单的开始是在任何实现 `Collection` 接口或其后代之一的类上使用 `stream()` 方法。（数组没有内置的流选项，但您可以使用
    `Stream.of()` 静态方法轻松创建一个。）
- en: 'Once we have a stream going, we can operate on it. We’ll look at many more
    operations next, but a popular and simple starting point is the `count()` operation.
    Not surprisingly, this operation counts each element of the stream as it goes
    by and produces a single result. For example, we can use our `names` list in *jshell*
    and find out how many friends are in our list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了流，就可以对其进行操作。我们将在接下来看到更多操作，但是一个受欢迎且简单的起点是 `count()` 操作。毫不奇怪，此操作在流中的每个元素经过时计数并生成单一结果。例如，我们可以在
    *jshell* 中使用我们的 `names` 列表并找出列表中有多少个朋友：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Admittedly, this example doesn’t do anything amazing, but we’ll build up to
    more complex operations. The important thing to note is the way we attach an operation
    to our stream. The `stream()` returns a stream object, and we use the dot operator
    (`.`) immediately to get our count.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个示例并没有做什么惊人的事情，但我们将逐步进行到更复杂的操作。重要的是注意我们如何将操作附加到我们的流上。`stream()` 返回一个流对象，我们立即使用点操作符
    (`.`) 来获取我们的计数。
- en: 'We could use another operation to print out our names:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个操作来打印出我们的名称：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We supplied a method reference to the `forEach()` operation, but you can also
    provide a lambda that takes one argument (the current name from the stream) and
    does not return a value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `forEach()` 操作提供了一个方法引用，但您也可以提供一个接受一个参数（流中的当前名称）且不返回值的 lambda。
- en: Stream reuse
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流的重用
- en: 'You may have noticed that we did not store our stream in a variable for reuse
    between our `count()` example and the similar `forEach()` example. Streams are
    one-way and single use. You can actually store a stream in a variable, but if
    you try to reuse the stream after you have processed it, you’ll get an error:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在我们的 `count()` 示例和类似的 `forEach()` 示例之间，我们没有将流存储在可重用的变量中。流是单向且一次性的。实际上可以将流存储在变量中，但是如果在处理完流后尝试重复使用它，将会出错：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We created a parameterized `Stream` object for our stream of `String` objects.
    We successfully started the stream and used the `count()` operation, but we failed
    to use that same stream for our `forEach()` operation. Processing a stream does
    not alter the original source, so you can safely start a new stream as often as
    needed. But once a stream has ended, it cannot be restarted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的 `String` 对象流创建了一个参数化的 `Stream` 对象。我们成功启动了流并使用了 `count()` 操作，但是未能在 `forEach()`
    操作中使用相同的流。处理流不会改变原始来源，因此您可以安全地根据需要频繁地启动新的流。但是一旦流结束，就无法重新启动它。
- en: Stream generators
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流生成器
- en: Another source of stream data is a *generator*. Generators create data according
    to some rule. Some generators produce a fixed value over and over, while others
    produce random content. You can generate simple things like numbers or complex
    things like objects. If getting real data is an expensive operation, you can use
    generators to more easily test your stream logic. Similarly, you can use a generator
    to create good (or quirky, or error-filled) data to test other parts of your application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 流的另一个数据来源是*生成器*。生成器根据某些规则创建数据。一些生成器重复生成固定值，而其他生成器生成随机内容。您可以生成简单的东西，如数字，也可以生成复杂的对象。如果获取真实数据是昂贵的操作，您可以使用生成器更轻松地测试流逻辑。同样，您可以使用生成器创建良好（或古怪、错误填充）的数据来测试应用程序的其他部分。
- en: 'The `Stream.generate()` method takes an instance of the `Supplier` interface.
    A supplier has one job: to supply an infinite stream of elements. It has one method:
    `get()`, which returns an element of the appropriate type. And the element’s type
    is really the only restriction that Java places on your generator. Let’s try generating
    something simple: a steady stream of the number 42:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.generate()` 方法接受一个 `Supplier` 接口的实例。供应商的工作是提供无限流的元素。它只有一个方法：`get()`，它返回适当类型的元素。元素的类型实际上是
    Java 对生成器施加的唯一限制。让我们尝试生成一些简单的东西：一个稳定的数字 42 的流：'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `Supplier` in this case is the very simple lambda, `() → 42`. There are
    no arguments, and every time the lambda expression is used or evaluated, the result
    is 42\. Notice that we follow our `generate()` method with a new method, `limit()`,
    that sits between the generator and our `println()` step. On their own, generators
    generate forever. We’ll discuss `limit()` and other related methods in the next
    section, but we need something in the short term to rein in our generators. If
    you don’t believe us, try removing that piece. Just be ready to hit Ctrl-C quickly
    (and repeatedly) to stop the onslaught of infinite 42s!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`Supplier`是一个非常简单的lambda，`() → 42`。它没有参数，每次使用或评估lambda表达式时，结果都是42。注意，在我们的`generate()`方法后面跟着一个新方法`limit()`，它位于生成器和我们的`println()`步骤之间。单独使用生成器会无限生成。我们将在下一节讨论`limit()`和其他相关方法，但我们需要在短期内找到一些方法来限制我们的生成器。如果你不相信我们，试试删除那一部分。只需准备好快速（并且重复地）按下Ctrl-C来停止无限的42！
- en: 'We can implement the `Supplier` interface (or any of its base-type cousins
    such as `IntSupplier`) in a class when we need a more interesting set of generated
    data. Consider a stream of random day names. We need a random number generator
    and a list of valid days. Those requirements would probably make for a messy inline
    lambda, but they’re trivial in a small class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更有趣的生成数据集时，我们可以在类中实现`Supplier`接口（或者像`IntSupplier`这样的基类型表亲）。考虑一个随机日期名称流。我们需要一个随机数生成器和一个有效日期的列表。这些要求可能会导致一个混乱的内联lambda，但在一个小类中却很简单：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `main()` method here isn’t necessary, but it makes it easy to test. Just
    compile and run the class from the *ch11/examples* folder. You should see five
    random days of the week:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`main()`方法并不是必需的，但它使得测试变得更加容易。只需编译并从*ch11/examples*文件夹运行该类。你将看到一周中的五个随机日期：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Try running it a few times just to confirm that the random feature is working.
    Your generating class can be as rich as necessary. You just need to make sure
    `get()` returns an appropriate object or value: notice we implemented a parameterized
    version of our interface: `Suppler<String>`, and our `get()` method returns `String`.
    Now you’re good to go!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行几次以确认随机特性是否正常工作。你的生成类可以尽可能丰富。你只需确保`get()`返回一个合适的对象或值：注意我们实现了接口的参数化版本：`Supplier<String>`，我们的`get()`方法返回`String`。现在你可以开始了！
- en: Stream iterators
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流迭代器
- en: 'In addition to generators, streams can be built from iterators. These iterators
    aren’t quite the same as the iterators you use to walk through a collection, but
    the idea is similar. *Stream iterators* have the same notion of a “next” value
    as collection iterators, but for streams, that next value comes from performing
    a calculation on the previous value. If you need a range of sequential numbers,
    for example, an iterator is ideal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成器外，流还可以从迭代器构建。这些迭代器与用于遍历集合的迭代器不完全相同，但思想是相似的。*流迭代器*具有与集合迭代器相同的“下一个”值的概念，但对于流来说，下一个值来自于对前一个值执行计算。例如，如果你需要一系列顺序数字，迭代器就是理想的选择：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `iterate()` source method takes two arguments: a starting value and a lambda
    expression. The lambda takes one argument and uses it to create the next element.
    That second element will be put back through the same lambda expression to create
    the third, and so on. We certainly could have done that with a custom `Supplier`,
    but for many sequences, iterators offer a simpler entry point. And you aren’t
    restricted to iterating on numbers—you can iterate on any object type that suits
    your needs. As long as you have a way to calculate the next object for the stream,
    you can use an iterator as a source. Let’s try creating a sequence of `LocalDate`
    objects as an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate()`源方法接受两个参数：起始值和一个lambda表达式。Lambda接受一个参数，并用它创建下一个元素。第二个元素将通过相同的lambda表达式放回，以创建第三个元素，依此类推。我们当然可以用自定义的`Supplier`来完成这个操作，但对于许多序列来说，迭代器提供了一个更简单的入口点。而且你不仅仅限于迭代数字，你可以迭代任何符合你需求的对象类型。只要你有一种方法来计算流的下一个对象，你就可以使用迭代器作为源。让我们尝试创建一个`LocalDate`对象的序列作为示例：'
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `LocalDate.now()` static method to get the current date for our starting
    value. The iterating expression takes a `LocalDate` object as input, uses the
    `plus()` method to add one day, and returns the new `LocalDate`. (And we end on
    such a lovely date.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`LocalDate.now()`静态方法来获取当前日期作为我们的起始值。迭代表达式接受一个`LocalDate`对象作为输入，使用`plus()`方法添加一天，并返回新的`LocalDate`。（然后我们以这样一个可爱的日期结束。）
- en: Filtering Streams
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤流
- en: Both the `count()` and the `forEach()` operations in the previous snippets are
    examples of *terminal* operations. Terminal operations “terminate” a stream. You
    can have only one, final terminating operation when processing a stream. The `limit()`
    operation, in contrast, is an example of an *intermediate* operation. An intermediate
    operation may alter or remove some of the data in the stream, but the stream continues.
    Filtering is a popular type of intermediate operation, and limiting the number
    of elements that continue on down the stream is a form of filtering. But you can
    filter for all kinds of reasons. You can filter to select desirable data or to
    toss out undesirable data. You can filter out duplicates. You can input a stream
    of objects to your filter and have it output an essentially new stream for use
    by the next operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中的`count()`和`forEach()`操作都是*终端*操作的示例。终端操作“终止”了流。在处理流时，只能有一个最终的终端操作。相比之下，`limit()`操作是*中间*操作的示例。中间操作可能会修改或删除流中的某些数据，但流仍然存在。过滤是一种流行的中间操作类型，限制继续流下去的元素数量是一种过滤形式。但你可以基于各种原因进行过滤。你可以过滤以选择理想的数据，或者排除不想要的数据。你可以过滤掉重复的数据。你可以将一系列对象输入到过滤器中，并使其输出一个基本上新的流供下一个操作使用。
- en: 'As luck would have it, generic filters are just lambdas that return `boolean`
    values. This is the `Predicate` shape from the big list of functional interfaces
    in the `java.util.function` package. You send one argument in, and either `true`
    or `false` comes out. For example, we could use a filter to count the names that
    contain the letter “o” like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通用的过滤器只是返回`boolean`值的lambda表达式。这是来自`java.util.function`包中大列表功能接口中的`Predicate`形式。你将一个参数传入，然后会得到`true`或者`false`。例如，我们可以使用一个过滤器来计算包含字母“o”的名字的数量，像这样：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our filtering lambda takes one name and uses the `indexOf()` operation to see
    if the name contains an “o”. Since `indexOf()` returns an `int` value, we compare
    it to an impossible index, -1, to create the required `boolean` result. If the
    predicate returns `true`, that name will be passed along. If the predicate returns
    `false`, the name is simply dropped from the stream.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤lambda接收一个名字，并使用`indexOf()`操作来查看名字是否包含“o”。由于`indexOf()`返回一个`int`值，我们将其与一个不可能的索引-1进行比较，以生成所需的`boolean`结果。如果谓词返回`true`，该名字将被传递下去。如果谓词返回`false`，则该名字将从流中被简单地丢弃。
- en: 'The important detail again is the “in the middle” nature of a filter. We can
    keep doing things with our stream. It’s common to stack multiple filters, for
    example. Each filter selects different desired elements (or removes unwanted elements,
    depending on how you look at it). Another popular built-in filter is the `distinct()`
    operation that weeds out duplicates. Let’s add some repeated names to our list
    and try using two intermediate operations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次重要的细节是过滤器的“中间”特性。我们可以持续对流进行操作。例如，堆叠多个过滤器是很常见的。每个过滤器选择不同的所需元素（或者从另一个角度看，移除不需要的元素）。另一个流行的内置过滤器是`distinct()`操作，它可以除去重复项。让我们在列表中添加一些重复的名字，然后尝试使用两个中间操作：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can stack as many filters as you need, although it’s still important to
    keep your code readable. (If you have a gauntlet of 20 filters, you may want to
    reconsider how you process the source for the stream.) But you can do more than
    simply filter the elements in your stream: you can turn them into something else!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以堆叠任意多个过滤器，尽管保持代码可读性仍然很重要（如果你有一连串的20个过滤器，可能需要重新考虑如何处理流的源）。但是你可以做的不仅仅是过滤流中的元素：你可以将它们转换成其他形式！
- en: Mapping Streams
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射流
- en: In streams, *mapping* is the process of altering an element in a stream before
    passing it along. Like filtering, you use a lambda expression to perform the alteration.
    You can map simple changes, like adding sales tax to a stream of prices, or you
    can create complex maps that convert one type of object into a wholly different
    type. Or you can do both! Mapping is also an intermediate operation, so you can
    stack map operations just as you did with filters. Indeed, you will see many examples
    online of programmers mixing maps and filters to achieve their final result.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在流中，*映射* 是在传递元素之前修改流中元素的过程。与过滤类似，您使用lambda表达式执行修改。您可以映射简单的更改，如向价格流中添加销售税，或者创建将一种对象类型转换为完全不同类型的复杂映射。或者两者兼而有之！映射也是一个中间操作，因此您可以像使用过滤器一样堆叠映射操作。事实上，您会在许多在线示例中看到程序员将映射和过滤器混合使用以达到最终结果。
- en: 'Let’s start by trying the task of adding sales tax. We’ll start with a short
    list of `double` values and a 5% tax. We can `map()` the tax onto the prices like
    so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从尝试添加销售税的任务开始。我们将从一个包含`double`值和5%税率的简短列表开始。我们可以这样将税应用到价格上：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The formatting of our prices isn’t very polished, but the tax has been correctly
    applied. While we have them handy, we can try out another useful terminal operation,
    `sum()`, to add up all the prices:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的价格格式并不是很精致，但税已经正确应用。虽然它们很方便，但我们可以尝试另一个有用的终端操作，`sum()`，将所有价格相加：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, the output isn’t nicely formatted, but we summed up an entire array of
    numbers in one line!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，输出并不是很好地格式化，但我们在一行中总结了整个数组的数字！
- en: Mapping object attributes
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射对象属性
- en: 'You can also use maps to peer inside objects. Let’s create a simplified variation
    of our `Employee` class from [Chapter 7](ch07.html#learnjava6-CHP-7) with an additional
    `salary` attribute. We’ll call this version a `PaidEmployee`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用映射来查看对象的内部。让我们创建一个简化版本的`Employee`类，它增加了一个额外的`salary`属性，这个版本我们称为`PaidEmployee`：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In a stream of employees, we can now use `map()` to extract specific attributes,
    like their names. Let’s write a test class that creates a few example employee
    objects and then uses a stream to process the employees:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个员工流中，我们现在可以使用`map()`来提取特定的属性，比如他们的名字。让我们编写一个测试类，创建几个示例员工对象，然后使用流来处理这些员工：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `publishNames()` method uses `map()` to take our `PaidEmployee` object and
    grab the employee’s name. That name (a simple `String` object) continues on down
    the stream. With the names available, we could add filters, like our “names with
    an o” filter from earlier examples, or watch out for duplicate employee records.
    Any time you need to massage your data, `map()` is the method to use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`publishNames()`方法使用`map()`来获取我们的`PaidEmployee`对象并获取员工的名字。这个名字（一个简单的`String`对象）继续在流中传递。有了这些名字，我们可以添加过滤器，比如我们之前示例中的“带有o的名字”过滤器，或者注意避免重复的员工记录。每当您需要处理数据时，`map()`方法就是要使用的方法。'
- en: Mapping conversions
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射转换
- en: 'In the previous example, we quietly converted our stream from one with `PaidEmployee`
    objects to one with `String` objects. Because both types are reference types,
    we don’t really have to worry about the fact that we have different before and
    after types. If you need to move from a reference type to a base type—or vice
    versa—you have to be a little more explicit about the conversion. This is definitely
    a common task, so Java supplies some handy variations of `map()` for just this
    purpose. Let’s get a sum of all our employees’ annual salaries to know what our
    wage budget should be:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们悄悄地将我们的流从一个具有`PaidEmployee`对象的流转换为一个具有`String`对象的流。因为这两种类型都是引用类型，我们实际上不必担心我们在之前和之后的类型不同的问题。如果您需要从引用类型移动到基本类型，或者反之，则必须更加明确地进行转换。这绝对是一个常见的任务，所以Java提供了一些很方便的`map()`的变体来完成这个目的。让我们对所有员工的年薪进行汇总，以了解我们的工资预算应该是多少：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Figure 11-2](#learnjava6-CHP-11-FIG-obj-to-int) illustrates the data moving
    through this budget-calculating stream.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](#learnjava6-CHP-11-FIG-obj-to-int)说明了通过这个预算计算流的数据移动。'
- en: '![ljv6 1102](assets/ljv6_1102.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1102](assets/ljv6_1102.png)'
- en: Figure 11-2\. Converting between objects and ints in a stream
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-2\. 在流中在对象和int之间转换
- en: 'Similar classes exist for moving to two other base types: `mapToDouble()` and
    `mapToLong()`. If you already have a stream of numbers and want to move to an
    object, the base type streams, like `IntStream`, all include the `mapToObj()`
    operation.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在将转移到另外两种基本类型的相似类：`mapToDouble()`和`mapToLong()`。如果您已经有一个数字流并想转移到一个对象，比如`IntStream`这样的基本类型流，都包含`mapToObj()`操作。
- en: Flatmaps
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flatmaps
- en: 'We want to introduce one other type of mapping operation commonly used with
    streams: the *flatmap*. The flatmap operation takes lumpy inputs and smooths them
    into a single (you might even say flat!) stream of elements. What do we mean by
    lumpy input? It’s mostly a cute way of saying multidimensional data. Consider
    the array-of-arrays chessboard we discussed in [“Multidimensional Arrays”](ch04.html#learnjava6-CHP-4-SECT-6.5).
    We can play with a similar setup in *jshell* using simple `int` values. The “board”
    is an array of rows, where each row is an array of numbers. What happens if we
    try to start a stream from our two-dimensional array? Let’s try it out with a
    reduced 4 × 4 matrix:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想介绍另一种与流常用的映射操作：*flatmap*。flatmap操作将块状输入平滑地转换为单一（你甚至可以说是平坦的！）元素流。什么是块状输入？这主要是一种说多维数据的可爱方式。考虑我们在[“多维数组”](ch04.html#learnjava6-CHP-4-SECT-6.5)中讨论的数组数组棋盘。我们可以在*jshell*中使用简单的`int`值进行类似设置。“棋盘”是一组行，其中每行是一组数字。如果我们尝试从我们的二维数组开始一个流会发生什么？让我们试试一个减少为4
    × 4矩阵的示例：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hmm, that appears to be a stream of `int[]` objects, not individual integers.
    (Those ugly blobs are Java’s default way of printing objects that don’t have a
    pretty `toString()` method. The format is “object type @ memory address”.) What
    if we try to start a stream from the first row?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，那似乎是一个`int[]`对象流，而不是单个整数流。（那些丑陋的斑点是Java默认的打印没有漂亮`toString()`方法的对象的方式。“对象类型
    @ 内存地址”的格式。）如果我们尝试从第一行开始一个流会发生什么？
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That output looks better—it’s a list of our made-up chess piece values, but
    it’s only one row. We could put the stream in the middle of a `for` loop and process
    a separate stream for every row, but that seems cumbersome and would make any
    kind of counting or summing step much more difficult.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那个输出看起来更好——这是我们虚构的棋子价值清单，但只有一行。我们可以将流放在`for`循环的中间，并处理每一行的独立流，但这看起来很麻烦，而且会使任何计数或求和步骤变得更加困难。
- en: 'For a nice, stream-friendly way to get all of our chess pieces into one stream,
    we’ll use `flatMap()`, or in our case of going from an object (each row is an
    array object) to a base type (each chess piece is an `int`), we’ll use `flatMapToInt()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个友好的、适合流的方式将所有棋子放入一个流中，我们将使用`flatMap()`，或者在我们的情况下，从一个对象（每行是一个数组对象）到一个基本类型（每个棋子是一个`int`），我们将使用`flatMapToInt()`：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Hooray, it worked! We started with a stream of dense objects and broke up those
    dense objects into a single stream of smaller parts. You can use `flatMap()` and
    its base-type cousins to toss any tabular, cubic, or generic multidimensional
    data into a pleasant stream of individual elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁，成功了！我们从一组密集对象开始，将这些密集对象拆分为更小部分的单一流。您可以使用`flatMap()`及其基本类型的衍生物将任何表格化、立方体化或通用的多维数据转换为一流的个体元素。
- en: 'Let’s look at another example that combines several of the stream topics we’ve
    covered so far. A common task for system and network administrators is parsing
    log files. Web servers, for example, log each visitor’s Internet Protocol (IP)
    address and the resource they requested. Here’s a small example, with the long
    lines truncated for readability:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例，结合我们到目前为止已经讨论过的几个流主题。系统和网络管理员的常见任务是解析日志文件。例如，Web服务器记录每个访问者的Internet
    Protocol（IP）地址和他们请求的资源。这里是一个小例子，为了可读性，长行被截断了：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Each line contains lots of information: that IP address, the date and time
    of the request, what was requested, how it was requested, and (if you peek at
    the real log file in the *ch11/examples* folder) information about what browser
    or user agent made the request. Real-world log files can be huge, and admins usually
    keep them compressed on disk.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每行包含大量信息：IP地址、请求的日期和时间、请求的内容、请求的方式，以及（如果您查看*ch11/examples*文件夹中的真实日志文件）有关哪个浏览器或用户代理发出请求的信息。真实世界的日志文件可能非常庞大，管理员通常将它们压缩存储在磁盘上。
- en: 'Let’s use all our stream skills. We’ll start with a GZIP file and load its
    contents with some I/O streams, then break up the uncompressed data into lines.
    We can use `flatMap()` to turn the functional stream of lines into a stream of
    space-separated tokens. With our tokens in hand, we can finally get to the information
    we really want: a count of unique visitor IP addresses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用所有的流处理技能。我们将从一个GZIP文件开始，并使用一些I/O流加载其内容，然后将未压缩的数据分解成行。我们可以使用`flatMap()`将行的函数流转换为以空格分隔的令牌流。有了这些令牌，我们最终可以得到我们真正想要的信息：独特访客IP地址的计数。
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Very nice. Once we have the stream of lines from our decompressed file, we can
    get our count using the functional approach to processing data with a compact,
    efficient, and readable list of steps. Again, you do not *have* to use functional
    streams and lambdas, but more and more programmers are looking into this way of
    solving problems—even in erstwhile object-oriented languages like Java.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好。一旦我们从解压后的文件中获得了行流，我们就可以使用函数式处理数据的方式来获取计数，这种方式紧凑、高效且可读的步骤列表。再次强调，你并不*必须*使用函数式流和lambda表达式来解决问题，但越来越多的程序员正在研究这种解决问题的方式——即使是在像Java这样的面向对象语言中。
- en: Reducing and Collecting
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少和收集
- en: 'We’ve looked at several examples using streams in this chapter. Each example
    has ended the stream with one of three terminal operations: a `forEach()` that
    we typically use to print the elements, a `count()` to know how many elements
    there are, or with `sum()` as a way to add up all of the numerical elements. Counting
    and summing are examples of *reducing* a stream. You “reduce” all the elements
    in your stream to a single answer.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过几个使用流的示例。每个示例都以三种终端操作中的一种结束：使用`forEach()`来打印元素，使用`count()`来知道有多少元素，或者使用`sum()`来将所有数值元素相加。计数和求和都是对流进行*减少*的示例。你将所有流中的元素“减少”为一个单一的答案。
- en: Streams in Java have several built-in reducers, as shown in [Table 11-1](#learnjava6-CHP-11-TABLE-1).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的流有几个内置的减少器，如表 [11-1](#learnjava6-CHP-11-TABLE-1) 所示。
- en: Table 11-1\. Terminal reduction operations
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. 终端减少操作
- en: '| Operation | Description |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `count()` | Returns the number of elements in the stream |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 返回流中元素的数量 |'
- en: '| `findAny()` | Returns an element (if any exist) from the stream |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `findAny()` | 返回流中的任意一个元素（如果存在） |'
- en: '| `findFirst()` | Returns the first element (if it exists) from the stream
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `findFirst()` | 返回流中的第一个元素（如果存在） |'
- en: '| `matchAll()` | Returns `true` if all elements of the stream match the given
    criteria |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `matchAll()` | 如果流中所有元素都符合给定条件，则返回`true` |'
- en: '| `matchAny()` | Returns `true` if at least one element in the stream matches
    the given criteria |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `matchAny()` | 如果流中至少有一个元素符合给定条件，则返回`true` |'
- en: '| `max()` | Using a provided comparator, returns the “largest” element (if
    any) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `max()` | 使用提供的比较器，返回“最大”的元素（如果有的话） |'
- en: '| `min()` | Using a provided comparator, returns the “smallest” element (if
    any) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `min()` | 使用提供的比较器，返回“最小”的元素（如果有的话） |'
- en: 'You might wonder why the `sum()` operation we’ve used a few times isn’t listed.
    It is definitely a reducer, but the built-in version is available only on the
    base-type streams: `IntStream`, `LongStream`, and `DoubleStream`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会想知道我们几次使用的`sum()`操作为什么没有列出来。它确实是一个减少器，但内置版本仅适用于基本类型流：`IntStream`、`LongStream`和`DoubleStream`。
- en: Optional values
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选值
- en: 'Before looking deeper at reducers (including how to create a custom reducer),
    we need to be prepared for a potentially dire outcome: an empty stream.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究减少器（包括如何创建自定义减少器）之前，我们需要准备好可能出现的一种严峻结果：空流。
- en: 'Any time you filter a stream, it’s possible you won’t have anything left on
    the other side of the filter. As a quick example, what if the filter in our `names`
    example earlier had been looking for the letter “a” instead of “o”? None of our
    names contain an “a,” so the filter would end up dropping every name from our
    list. The `count()` operation can handle that situation fine: it simply returns
    an answer of zero. But what if we had used `min()` or `findFirst()`? Those reducers
    expect to give you a matching element from your stream. If there are no elements
    left, what should a reducer return? It might be acceptable in some scenarios to
    return a `null` value, but if your stream ends with base-type elements, like `int`
    values, you can’t use `null`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当过滤流时，可能会在过滤器的另一端没有任何剩余内容。举个快速的例子，如果我们的`names`示例中的过滤器寻找的是字母“a”而不是“o”呢？我们的名字列表中没有一个名字包含字母“a”，所以过滤器最终会将列表中的所有名字都删除掉。`count()`操作可以很好地处理这种情况：它简单地返回零作为答案。但是如果我们使用了`min()`或者`findFirst()`呢？这些减少器期望从流中给出一个匹配的元素。如果没有剩余元素，减少器应该返回什么？在某些情况下，返回`null`值可能是可以接受的，但是如果你的流以基本类型元素结束，比如`int`值，你就不能使用`null`了。
- en: 'Rather than force you to construct some strange rule or throw an exception,
    Java streams support the notion of an *optional* answer. These answers are wrapped
    in a class, appropriately called `Optional`, from the `java.util` package. An
    `Optional` object has two key methods that we’ll work with in this section: `isPresent()`
    tells us whether a value exists or not, and `get()` returns that value. (If you
    call `get()` when no value is present, you’ll “get” a `NoSuchElementException`.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java流支持*可选*答案的概念，而不是强迫你构建一些奇怪的规则或抛出异常。这些答案被包装在一个称为`Optional`的类中，它来自`java.util`包。`Optional`对象有两个关键方法，我们在本节中将使用它们：`isPresent()`告诉我们值是否存在，`get()`返回该值。（如果在没有值的情况下调用`get()`，你将会得到一个`NoSuchElementException`。）
- en: 'We can test this optional idea by revisiting our name filtering example. Rather
    than counting the results, though, we’ll use `findFirst()` to return the first
    matching name. Since there might not be any matches at all, we’ll get the result
    wrapped in an `Optional`. Feel free to reuse the `names` collection if it’s still
    in your *jshell*, but here’s a quick recap:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新访问我们的名称过滤示例来测试这个可选的想法。不过，与其计算结果的数量，我们将使用`findFirst()`来返回第一个匹配的名称。因为可能根本没有匹配项，所以我们会得到一个包装在`Optional`中的结果。如果你的*jshell*中仍然有`names`集合，可以自由地重用它，但这里是一个快速回顾：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let’s run those names through a filter and look for the first match. We’ll
    try our filter with an “o” (which should have an answer) and then with an “a”
    (which should not have an answer). Notice how we use the `Optional` result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这些名称通过过滤器进行过滤，并查找第一个匹配项。我们将使用一个“o”来尝试我们的过滤器（应该有一个答案），然后用一个“a”来尝试（应该没有答案）。注意我们如何使用`Optional`的结果：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While it makes your code a little more verbose to test if your value `isPresent()`,
    `Optional` provides a clear interface for handling both the good and the “bad”
    outcomes of your stream processing. And as with so many other classes and methods
    in this functional arena, you can use the `OptionalInt`, `OptionalLong`, and `Optional`
    `Double` classes to catch potentially missing base-type results.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将你的值`isPresent()`进行测试使得你的代码稍微冗长，但`Optional`提供了一个清晰的接口来处理流处理的良好和“坏”结果。与这个函数领域中的许多其他类和方法一样，你可以使用`OptionalInt`、`OptionalLong`和`Optional`
    `Double`类来捕获可能缺失的基本类型结果。
- en: Creating a custom reducer
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个自定义的Reducer
- en: What if the built-in reducers don’t cover your needs? You may not be surprised
    to learn that you can supply a lambda to create a custom reducer. The `Stream`
    class includes a `reduce()` operation that accepts a lambda with the `BinaryOperator`
    shape from the `java.util.function` package we discussed in [“Functional Interfaces”](#learnjava6-CHP-11-SECT-2.2).
    `BinaryOperator` accepts two arguments of the same type and returns a value (also
    of the same type). Depending on your needs, you can either use `reduce()` with
    just the binary operator lambda, or you can use a second form that also takes
    an initial value of the same type used by the binary operator. Let’s try out this
    second form to create a custom factorial reducer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置的Reducers不能满足你的需求怎么办？你可能不会感到惊讶，你可以提供一个lambda来创建一个自定义的Reducer。`Stream`类包括一个`reduce()`操作，它接受一个lambda，lambda的形式是我们在[“函数接口”](https://example.org/learnjava6-CHP-11-SECT-2.2)讨论过的`java.util.function`包中的`BinaryOperator`。`BinaryOperator`接受两个相同类型的参数并返回一个相同类型的值。根据你的需求，你可以只使用带有二元操作lambda的`reduce()`，或者你可以使用第二种形式，该形式还接受与二元操作符相同类型的初始值。让我们尝试使用第二种形式来创建一个自定义的阶乘Reducer。
- en: '*Factorials* are big numbers—or they can be, anyway. If the term doesn’t sound
    familiar, it’s similar to a summing operation, but instead of adding each number
    in the sequence, you multiply. You typically use the exclamation mark to indicate
    this operation: `5!` (pronounced “five factorial”) will multiply 5 and 4 making
    20, then 20 × 3 makes 60, then 60 × 2 makes 120, and finally 120 × 1 leaves 120\.
    It may look simple enough, but factorial numbers get very big, very quickly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*阶乘*是一个很大的数字——或者可以是的。如果这个术语听起来不熟悉，它类似于一个求和操作，但是不是将序列中的每个数字相加，而是相乘。你通常使用感叹号来表示这个操作：`5!`（读作“五的阶乘”）将5和4相乘得到20，然后20
    × 3得到60，然后60 × 2得到120，最后120 × 1得到120。看起来可能很简单，但是阶乘数很快就变得非常大：'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you look carefully at the result of `12!`, you’ll notice it is just under
    half a billion, so it still fits within the (positive) range of values for the
    `int` type. But `13!` would be roughly 6.5 billion, so we can’t store that answer
    with `int`s. We could calculate it with `long`s, but even that type can’t hold
    anything after `20!`. Fortunately, Java is ready with some fun classes from `java.math`:
    `BigInteger` and `BigDecimal`. These classes can house arbitrarily large values,
    perfect for removing the limits of base types in our factorial work.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察`12!`的结果，你会注意到它只略低于50亿，因此仍然适合`int`类型的（正）值范围。但是`13!`将大约为65亿，因此我们无法用`int`存储该答案。我们可以用`long`计算它，但即使是这种类型也无法在`20!`之后保存任何内容。幸运的是，Java准备了一些有趣的类来自`java.math`：`BigInteger`和`BigDecimal`。这些类可以容纳任意大的值，非常适合在我们的阶乘工作中消除基本类型的限制。
- en: 'We can use a simple iterator as our source, since multiplication doesn’t require
    a particular order of operations. Our factorial reducer will always produce an
    answer similar to `count()` or `sum()`,^([3](ch11.html#id2290)) so we’ll use the
    second form with a starting value of 1\. We can try this out in *jshell*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的迭代器作为我们的源，因为乘法不要求特定的操作顺序。我们的阶乘减少器将始终产生类似于`count()`或`sum()`的答案，^([3](ch11.html#id2290))
    因此我们将使用第二种形式，起始值为1。我们可以在*jshell*中尝试这个：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output of `99!` is so large we had to arbitrarily chop it up to make it
    fit the printed edition of this book.^([4](ch11.html#id2291)) But our custom reducer
    worked!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`99!`的结果非常大，我们不得不任意截取部分内容以适应这本书的印刷版。^([4](ch11.html#id2291)) 但是我们自定义的减少器有效！
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can implement the `BinaryOperator` interface in a class if your reducing
    logic is too complex for the simple, inline lambda. Then you can supply an instance
    of that class to `reduce()` instead of the lambdas we used in our examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的减少逻辑对于简单的内联Lambda来说太复杂，你可以在一个类中实现`BinaryOperator`接口。然后，您可以将该类的实例提供给`reduce()`，而不是我们在示例中使用的Lambda。
- en: Collectors
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集器
- en: The answers that reducers produce are often very useful. How many lines did
    you process? How many times did you see a particular word? What’s the average
    of some column in tabular data? But what if you want more than a single answer?
    When filtering, for example, you might want to keep all of the items from the
    stream that match, rather than counting or summing them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 减少器产生的答案通常非常有用。你处理了多少行？你看到了特定单词多少次？在表格数据中某一列的平均值是多少？但是如果你想要的不只是一个答案呢？例如，在过滤时，您可能希望保留与流匹配的所有项目，而不是计数或总和它们。
- en: What if you want a new list of just the names containing the letter “o”? We
    can use a collector.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个新的只包含字母“o”的名字列表，我们可以使用一个收集器。
- en: 'The `java.util.stream.Collector` interface allows for some impressive flexibility
    in how you collect and organize the results of processing your stream. We won’t
    be tackling custom collectors in this book, but happily, the related `Collectors`
    class includes several common collectors as static methods. For example, we can
    use one of those static methods to get that list of o-having names we were curious
    about:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.Collector`接口允许在处理流时以令人印象深刻的灵活性收集和组织结果。在本书中我们不会涉及自定义收集器，但幸运的是，相关的`Collectors`类包含几种常见的收集器作为静态方法。例如，我们可以使用其中一个静态方法来获取我们感兴趣的包含字母`o`的名字列表：'
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Excellent. Now `onames` is a regular `List<String>` object that we can use anywhere
    else we might need it. There are many, many other collecting methods that we encourage
    you to peek at in the [online documentation for `Collectors`](https://oreil.ly/R3vmF).
    The code exercises at the end of this chapter give you the chance to try out another
    popular collector, `groupingBy()`, but we don’t have time to cover all of the
    other wonderful options available.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在`onames`是一个常规的`List<String>`对象，我们可以在任何需要的地方使用它。在[收集器的在线文档](https://oreil.ly/R3vmF)中还有许多其他收集方法，我们鼓励您去看一看。本章末尾的代码练习让您有机会尝试另一个流行的收集器`groupingBy()`，但我们没有时间覆盖所有其他精彩的选项。
- en: Using Lambdas Directly
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用Lambda
- en: 'We want to highlight one other feature of lambdas in Java: you can use them
    in your own code. While you will probably start by using lambdas in a few tasks
    like sorting collections or filtering long streams of data, eventually you may
    want to write methods that accept a lambda as an argument to be used in the body
    of that method. Since lambda expressions are just instances of some functional
    interface, Java makes accepting lambdas fairly straightforward.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要强调Java中lambda的另一个特性：你可以在自己的代码中使用它们。虽然你可能首先在一些任务中使用lambda，比如对集合进行排序或过滤长数据流，但最终你可能希望编写接受lambda作为参数的方法，在该方法的主体中使用它们。由于lambda表达式只是某个功能接口的实例，Java使得接受lambda相当简单。
- en: 'Consider a digital sensor: perhaps some gadget attached to a USB port. Many
    of these sensors are stable and consistent, but they are consistently off by some
    factor. Maybe a thermometer thinks your home office is always three degrees warmer
    than it is, or maybe a light sensor underestimates ambient light by 10%. You could
    write separate adjustment methods that “add 3” to a reading or that “reduce by
    10%” every value, but you can also use lambdas to create a generic adjustment
    method and let the caller supply the adjusting logic.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个数字传感器：也许是连接到USB端口的某种小装置。许多这些传感器是稳定且一致的，但它们一直存在某种因素的偏差。也许一个温度计认为你的家庭办公室永远比实际温度高三度，或者一个光传感器低估了10%的环境光。你可以编写单独的调整方法来“加3”到一个读数或“减少10%”每个值，但你也可以使用lambda创建一个通用调整方法，并让调用者提供调整逻辑。
- en: 'Let’s see how you might write such a method. To make your method accept a lambda,
    you need to decide what shape it should have. You can always create your own shape,
    of course, but often you can simply use one of the interfaces from the `java.util.function`
    package. For our sensor-reading adjustments, we’ll use the `DoubleUnaryOperator`
    shape. (A *unary operator* operates on one value the same way a binary operator
    works on two.) We’ll accept one `double` argument and return an adjusted `double`
    as the result. We can put our amazingly flexible adjuster in a simple test harness
    to try out:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可能如何编写这样一个方法。要使你的方法接受一个lambda，你需要决定它应该具有什么形状。当然，你总是可以创建自己的形状，但通常你可以简单地使用`java.util.function`包中的接口之一。对于我们的传感器读数调整，我们将使用`DoubleUnaryOperator`形状。（*一元运算符*操作一个值，就像二元运算符操作两个值一样。）我们将接受一个`double`参数，并返回一个调整后的`double`作为结果。我们可以将我们这个非常灵活的调整器放入一个简单的测试框架中来试验：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can see that our `adjust()` method takes two arguments: the value we want
    to adjust, and the lambda that will do the adjusting. (And yes, you could implement
    the `DoubleUnaryOperator` in a class and supply an instance of that implementation
    as an alternative.) When we call `adjust()`, we get to use the same compact syntax
    that we’ve seen with other parts of the official JDK. It feels a bit like using
    forbidden magic, but it is entirely encouraged!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的`adjust()`方法接受两个参数：我们想要调整的值，以及将执行调整的lambda。（是的，你可以在一个类中实现`DoubleUnaryOperator`并提供该实现的实例作为另一种选择。）当我们调用`adjust()`时，我们可以使用与JDK官方其他部分相同的紧凑语法。它感觉有点像使用禁忌的魔法，但完全是受鼓励的！
- en: 'If you compile and run this demo, you should see output similar to this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个演示，你应该看到类似于以下的输出：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exactly what we expected. And we could write other adjustments without having
    to rewrite our actual `adjust()` method. You probably won’t need this type of
    dynamic logic for every problem you tackle in Java, but it’s worth putting this
    trick into your toolbox so you can pull it out when you do.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 恰如我们所预期的。而且我们可以写其他调整，而不必重写我们实际的`adjust()`方法。你可能不会在每个解决的Java问题中都需要这种动态逻辑，但将这个技巧放入你的工具箱中是值得的，这样你在需要时可以拿出来使用。
- en: Next Steps
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步操作
- en: As with so many features of Java, we could write an entire book just on lambda
    expressions or streams. [Others have!](https://oreil.ly/4Eb4c) We hope this introduction
    whets your appetite for learning more about FP topics. If you want more interactive
    practice with these topics, we highly recommend the labs available through O’Reilly’s
    [online platform](https://oreil.ly/gRFDW). Our own Marc Loy has created two series,
    one on [Java lambdas](https://oreil.ly/QNmjK) and another on [Java streams](https://oreil.ly/XquFS),
    both with practical examples of the topics we touched on in this chapter. These
    labs take advantage of O’Reilly’s Interactive Learning Environment, where you
    can edit, compile, and execute Java code right in your browser.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Java 的许多特性一样，我们可以单独撰写一本关于 lambda 表达式或流的书。[其他人已经做到了！](https://oreil.ly/4Eb4c)
    我们希望这篇介绍能激发您对更多函数式编程主题学习的兴趣。如果您希望通过这些主题进行更多交互式练习，我们强烈推荐您使用 O’Reilly 的 [在线平台](https://oreil.ly/gRFDW)
    上提供的实验室。我们的 Marc Loy 创建了两个系列，一个是关于 [Java lambda](https://oreil.ly/QNmjK)，另一个是关于
    [Java streams](https://oreil.ly/XquFS)，两者都有本章节涉及的实际示例。这些实验室利用了 O’Reilly 的交互式学习环境，您可以在浏览器中编辑、编译和执行
    Java 代码。
- en: Review Questions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: Which package contains the majority of functional interfaces introduced in Java
    8?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 8 中引入的大多数函数接口位于哪个包中？
- en: Do you need to use any special flags when compiling or running Java applications
    that use functional features like lambdas?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译或运行使用 lambda 等函数特性的 Java 应用程序时，您需要使用任何特殊标志吗？
- en: How do you create lambda expressions with multiple statements in the body?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建包含多条语句的 lambda 表达式的？
- en: Can lambda expressions be void? Can they return values?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda 表达式可以是 void 吗？它们可以返回值吗？
- en: Can you reuse a stream after you have processed it?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完流之后，您可以重复使用它吗？
- en: How might you take a stream of objects and convert it to a stream of integers?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将对象流转换为整数流？
- en: If you have a stream that filters out empty lines from a file, what operation
    might you use to tell you how many lines had some content?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有一个从文件中过滤掉空行的流，您可能会使用什么操作告诉您有多少行具有一些内容？
- en: Code Exercises
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Our `Adjuster` demonstration allows us to pass any lambda that accepts and returns
    a `double` value. We aren’t restricted to simple changes like adding a fixed amount.
    Add one more line of output that converts the number from a Fahrenheit reading
    to Celsius. (As a quick refresher, C = (F – 32) * 5 / 9\. Our reading of 70.2
    should come out around 21.2.)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Adjuster` 演示允许我们传递任何接受并返回 `double` 值的 lambda。我们并不局限于像添加固定量这样的简单更改。再添加一行输出，将数字从华氏度转换为摄氏度。（作为一个快速复习，C
    = (F – 32) * 5 / 9。我们的读数 70.2 应该大约是 21.2。）
- en: Using the `PaidEmployee` and `Report` classes from [“Mapping object attributes”](#learnjava6-CHP-11-SECT-3.3.1),
    add a simple report similar to `publishBudget()` that displays the average salary
    of all employees.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [“映射对象属性”](#learnjava6-CHP-11-SECT-3.3.1) 中的 `PaidEmployee` 和 `Report` 类，添加一个简单的报告，类似于
    `publishBudget()`，显示所有员工的平均工资。
- en: Advanced Exercises
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: Let’s explore more of the collectors we touched on at the end of the chapter.
    Add a “role” attribute (of type `String`) to the `PaidEmployee` class. Be sure
    to update the `buildEmployeeList()` method in the `Report` class to assign roles
    as well. Feel free to pick whatever roles you like but make sure at least two
    employees share the same role (for testing purposes).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步探讨我们在章节末尾提到的收集器。在 `PaidEmployee` 类中添加一个 `role` 属性（类型为 `String`）。确保在 `Report`
    类的 `buildEmployeeList()` 方法中也更新角色分配。随意选择您喜欢的角色，但确保至少有两个员工共享相同的角色（用于测试目的）。
- en: Now look at the [documentation for the `groupingBy()` collector](https://oreil.ly/miu1t).
    It returns a map of the groups and their members. In our example, the keys of
    this map will be the roles you created. The associated values will be lists of
    all the employees who share that role. You can add one more “report” to the `Report`
    class that creates this map and then prints out the roles and their associated
    employees.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在查看 [`groupingBy()` 收集器的文档](https://oreil.ly/miu1t)。它返回一个分组和其成员的映射。在我们的示例中，该映射的键将是您创建的角色。相关值将是共享该角色的所有员工的列表。您可以在
    `Report` 类中添加一个创建此映射并打印角色及其相关员工的“报告”。
- en: ^([1](ch11.html#id2199-marker)) Indeed, Church’s student and computing pioneer
    Alan Turing proved that the lambda calculus was equivalent to Turing’s own system
    (the foundational Turing machine) for performing computation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#id2199-marker)) 实际上，丘奇的学生和计算机先驱艾伦·图灵证明，λ演算与图灵自己的系统（基础图灵机）在执行计算方面是等效的。
- en: ^([2](ch11.html#id2202-marker)) We mention Clojure rather than the myriad other
    modern functional languages because it runs on the JVM and can integrate with
    Java classes and methods. Neat!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#id2202-marker)) 我们提到 Clojure 而不是其他许多现代函数式语言，因为它可以在 JVM 上运行，并且可以与
    Java 类和方法集成。真不错！
- en: ^([3](ch11.html#id2290-marker)) A quirk of the factorial process is that `0!`
    is defined as “the number of ways to arrange items in an empty set”—which is exactly
    one. Even if our stream has no elements, we can still correctly return the starting
    value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.html#id2290-marker)) 阶乘过程的一个怪癖是 `0!` 被定义为“在空集合中排列项目的方法数”—这正好是一个。即使我们的流没有元素，我们仍然可以正确返回起始值。
- en: ^([4](ch11.html#id2291-marker)) That’s 9.3e+155 if scientific notation is easier
    for you to parse at that size. Popular estimates for the number of atoms in the
    known universe come in around 10e+82, in case you were wondering just how big
    `99!` really is.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.html#id2291-marker)) 如果科学记数法对您在这种大小下更容易解析，那就是 9.3e+155。流行的宇宙中已知原子数量估计约为
    10e+82，以防您想知道 `99!` 究竟有多大。
