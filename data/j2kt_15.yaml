- en: Chapter 15\. Encapsulated Collections to Type Aliases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章。封装集合到类型别名
- en: In Java, we encapsulate collections of objects in classes to control mutation
    and add operations. Controlling mutation is less of a concern in Kotlin, and we
    can use extension functions to add operations. How would our designs be better
    without the encapsulation, and how do we get there?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 中，我们将对象集合封装在类中以控制变异并添加操作。在 Kotlin 中，控制变异的重要性较低，我们可以使用扩展函数来添加操作。如果没有封装，我们的设计会更好，如何做到这一点？
- en: In [Chapter 6](ch06.html#java-to-kotlin-collections) we looked at the differences
    between the grains of Java and Kotlin when it comes to collections. Java’s collection
    interfaces, in keeping with its object-oriented roots, are fundamentally mutable,
    whereas Kotlin treats collections as value types. As we saw, if we mutate shared
    collections, we can run into all sorts of trouble. We *could* avoid that trouble
    by not mutating shared collections ([“Don’t Mutate Shared Collections”](ch06.html#dont-mutate-shared-collections)),
    but in Java that’s hard to do when those `add` and `set` methods are just an autocomplete
    away. Instead of convention and discipline, most Java code sensibly opts for the
    safer approach of simply not sharing raw collections. Instead, collections are
    hidden inside another object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html#java-to-kotlin-collections) 中，我们探讨了 Java 和 Kotlin 在处理集合时的差异。Java
    的集合接口，符合其面向对象的根源，基本上是可变的，而 Kotlin 则将集合视为值类型。正如我们所见，如果我们改变共享集合，就会遇到各种问题。通过不改变共享集合，我们
    *可以* 避免那些麻烦（[“不要改变共享集合”](ch06.html#dont-mutate-shared-collections)），但在 Java 中，当
    `add` 和 `set` 方法仅仅是一个自动完成时，这很难做到。大多数 Java 代码通常选择更安全的方法，即简单地不共享原始集合，而是将集合隐藏在另一个对象中。
- en: 'Here, for example, is a `Route` in Travelator:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Travelator 中，这是一个 `Route`：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 15.1 [encapsulated-collections.0:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.1&show=diff)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.1 [encapsulated-collections.0:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.1&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO23-1)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO23-1)'
- en: A `Route` encapsulates a `List` of `Journey`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 封装了 `Journey` 的 `List`。'
- en: '[![2](assets/2.png)](#co_introduction_CO23-2)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO23-2)'
- en: The raw data is passed in the constructor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据原始数据通过构造函数传递。
- en: '[![3](assets/3.png)](#co_introduction_CO23-3)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_CO23-3)'
- en: Access to the data, for example for displaying in the UI, is provided by `size`
    and `get` methods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据，例如用于 UI 显示，由 `size` 和 `get` 方法提供。
- en: '[![4](assets/4.png)](#co_introduction_CO23-5)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_introduction_CO23-5)'
- en: The `Route` class implements application logic that uses the contents of the
    encapsulated list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 类实现应用逻辑，使用封装列表的内容。'
- en: 'Once we have a `Route` class, it is a convenient namespace to host operations
    on routes, like `getDepartsFrom` and `getDuration`. In this case, all the methods
    shown only use other public methods, and there is no polymorphic behavior, so
    these operations *could* be defined as static methods taking a `Route` parameter.
    We can view `Route` as more of a namespace than a class: the operations don’t
    *have* to be methods; it’s just more convenient that they are, at least in Java,
    where static functions are so much less discoverable than methods. In Kotlin,
    as we saw in [Chapter 10](ch10.html#functions-to-extension-functions), making
    the operations into extension functions would let us find and call them as if
    they were methods. `Route` as a class would then be adding no value to `List`
    of `Journey`, just preventing people from changing it. And in an all-Kotlin codebase,
    that `List` would be effectively immutable anyway.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了 `Route` 类，它就是一个方便的命名空间，用于托管路由操作，比如 `getDepartsFrom` 和 `getDuration`。在这种情况下，所有显示的方法仅使用其他公共方法，并且没有多态行为，因此这些操作
    *可以* 定义为接受 `Route` 参数的静态方法。我们可以将 `Route` 视为更像是一个命名空间而不是一个类：操作不一定 *必须* 是方法；只是在
    Java 中，静态函数不像方法那样易于发现。在 Kotlin 中，正如我们在 [第 10 章](ch10.html#functions-to-extension-functions)
    中看到的，将操作转换为扩展函数会让我们像调用方法一样找到并调用它们。`Route` 作为一个类，然后就不会为 `List` of `Journey` 添加任何值，只是阻止人们更改它。在全部使用
    Kotlin 的代码库中，该 `List` 本质上是不可变的。
- en: 'In fact, `Route` is doing worse than adding no value to `List<Journey>`—it
    is removing value. If we had a `List<Journey>`, our frontend code could use its
    `Iterator` when rendering:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Route` 比 `List<Journey>` 添加了更少的值。如果我们有一个 `List<Journey>`，我们的前端代码可以在渲染时使用它的
    `Iterator`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 15.2 [encapsulated-collections.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.2&show=diff)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.2 [封装集合.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.2&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.2&show=diff)'
- en: 'With a `Route`, we’re back to programming in the 1980s:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Route`，我们回到了上世纪80年代的编程方式：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 15.3 [encapsulated-collections.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.3&show=diff)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.3 [封装集合.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.3&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.3&show=diff)'
- en: If we encapsulate a collection, we *reduce* the operations available for us
    to work with its contents to only those defined by the encapsulating class. When
    we want to process that data in a new way, the path of least resistance is to
    add new methods to the class. The more methods we add to the class, the more the
    class *increases* the coupling between different parts of our application. Before
    we know it, adding an operation to support a new UI function ends up recompiling
    our data-access layer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们封装一个集合，我们*减少*了可以用于处理其内容的操作，仅限于封装类定义的那些操作。当我们想以新的方式处理数据时，最容易的方法是向类中添加新方法。我们添加的方法越多，类*增加*了应用程序不同部分之间的耦合。在我们意识到之前，为了支持新的UI功能而添加一个操作会导致重新编译我们的数据访问层。
- en: Composing Domain Collections
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合领域集合
- en: If we don’t encapsulate the collection—if we make our domain model *be* the
    appropriate data structure, rather than hiding it inside another class boundary—we
    *extend* the operations available for us to work with the data. Then we have our
    application-specific operations *and* all the operations defined for the collection.
    Client code can define the operations it needs in terms of the rich Collections
    API without having to add them to the class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将集合封装起来——如果我们使我们的领域模型*成为*合适的数据结构，而不是将其隐藏在另一个类边界内——我们*扩展*了可用于处理数据的操作。这样，我们就拥有了应用特定的操作*和*集合定义的所有操作。客户端代码可以根据丰富的集合
    API 定义它所需的操作，而无需将它们添加到类中。
- en: Rather than a `Route` class accreting all the route functionality and in turn
    coupling all the parts of our application together, we can view functionality
    as operations to be composed by importing extension functions. The UI can define
    functions that render `List<Journey>`, which in turn import functions that transform
    `Iterable<Journey>`. The persistence layer can transform database responses into
    `List<Journey>` and have no particular concept of “routyness” at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让一个`Route`类吸纳所有的路由功能，从而耦合应用程序的所有部分，我们可以将功能视为通过导入扩展函数来组合的操作。UI 可以定义渲染`List<Journey>`的函数，然后导入转换`Iterable<Journey>`的函数。持久化层可以将数据库响应转换为`List<Journey>`，并且根本不需要特定的“路由”概念。
- en: We can program like this in Java, but the poor discoverability of static functions,
    combined with mutable collections, goes against the grain of the language. Kotlin
    has extension functions to make static functions more discoverable, and immutable
    collections, so that breaking our domain model into collection types and separate
    operations becomes the happy path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Java中这样编程，但是静态函数的可发现性不足，再加上可变集合，与语言的本质相悖。Kotlin 提供了扩展函数以增强静态函数的可发现性，并提供了不可变集合，这样将我们的领域模型拆分为集合类型和单独的操作变得更加顺畅。
- en: If we don’t need to control access to a collection to prevent embarrassing mutation,
    and we don’t need to write a class to host operations on collections of a type,
    then is our `Route` class doing anything for us? Well, it is giving a name to
    `List<Journey>`, and it is also giving a type to this `List<Journey>` that might
    distinguish it from another `List<Journey>`—those in reports about all the journeys
    our travelers have booked this week, for example. Apart from that, though, in
    some ways it actually gets in our way, as we will see in [“Substitute a Type Alias”](#substitute-type-alias).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要控制对集合的访问以防止尴尬的变异，并且我们不需要编写一个类来托管特定类型的集合操作，那么我们的`Route`类对我们来说有什么作用呢？嗯，它为`List<Journey>`提供了一个名称，还为这个`List<Journey>`提供了一个类型，这可能使它与其他`List<Journey>`有所区别——例如关于本周旅行者预订的所有行程的报告。除此之外，在某些方面，它实际上会妨碍我们，正如我们将在[“替代类型别名”](#substitute-type-alias)中看到的那样。
- en: 'Where differentiating between different types of lists of journeys is *not*
    critical, Kotlin allows us to use type aliases to associate the name `Route` with
    `List<Journey>` rather than having to use a class to do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*不*关键区分不同类型的旅程列表时，Kotlin允许我们使用类型别名将名称`Route`与`List<Journey>`关联起来，而不必使用类来实现这一点：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Kotlin, then, the obstacles to using collections as domain types have been
    removed. Encapsulating immutable collections should be the exception rather than
    the rule.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，消除了将集合用作领域类型的障碍。封装不可变集合应该是例外而不是规则。
- en: Collections with Other Properties
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有其他属性的集合
- en: 'Of course, we can’t always just substitute type aliases for classes. Take our
    `Itinerary` class, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不总是可以简单地用类型别名替换类。例如，看看我们的`Itinerary`类：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 15.4 [encapsulated-collections.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.4&show=diff)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.4 [封装集合.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.4&show=diff)'
- en: In addition to the `Journey`s currently hidden in its `route`, `Itinerary` has
    an `Id` that allows us to address it as an entity. In these cases, we can’t just
    replace the class with its collection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其`route`中当前隐藏的`Journey`之外，`Itinerary`还具有一个`Id`，允许我们将其视为实体。在这些情况下，我们不能简单地用其集合替换类。
- en: In these cases, we can gain many of the advantages of unencapsulated collections
    by making `Itinerary` implement `List<Journey>`. That’s hard to do right now,
    because `Route` doesn’t implement that interface itself, but this is a good strategy
    as more of our domain is expressed as complete collections. We’ll get to it in
    [“Refactoring Collections with Other Properties”](#collections-with-properties).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，通过使`Itinerary`实现`List<Journey>`，我们可以获得许多未封装集合的优势。但是现在很难做到这一点，因为`Route`本身并没有实现该接口，但随着更多领域被表达为完整集合，这是一个好策略。我们将在[“具有其他属性的集合重构”](#collections-with-properties)中实现这一点。
- en: Refactoring Encapsulated Collections
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构封装集合
- en: One of the core services of our Travelator application is route planning.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Travelator应用程序的核心服务之一是路线规划。
- en: The `Route` that we saw earlier is a sequence of journeys that can take the
    traveler from one location to another. We’d like to add some functionality that
    will allow us to sell accommodation where a `Route` is split over days, but as
    a key domain abstraction, `Route` is collapsing under the weight of all the operations
    that we have already added to it and coupling disparate parts of the codebase
    together. Let’s see if we can refactor `Route` to make some room before we start
    work on the new feature.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的`Route`是一系列旅程，可以将旅行者从一个地点带到另一个地点。我们希望添加一些功能，使我们能够销售住宿，其中`Route`在几天内分割，但作为关键的领域抽象，`Route`正在因我们已经添加到其中的所有操作而变得笨重，并将代码库中不同的部分耦合在一起。让我们看看是否可以重构`Route`以腾出一些空间，然后再开始新功能的工作。
- en: 'Here again is the Java `Route` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是Java `Route`类：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 15.5 [encapsulated-collections.1:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.5&show=diff)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[   [示例 15.5 [封装集合.1:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.5&show=diff)'
- en: Convert Operations to Extensions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将操作转换为扩展
- en: We’re going to make `Route` less unwieldy (maybe even more wieldy) by moving
    its operations from methods to functions. Extension functions make this a reasonable
    strategy, but only from Kotlin, where they are much more discoverable. So we’re
    only going to attempt this stunt once the majority of our uses of `Route` are
    Kotlin. Luckily, our team really likes converting Java to Kotlin and has been
    beavering away as they work through the chapters of this book, so we’re ready
    to try this refactoring.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其操作从方法转移到函数，我们将使`Route`更加不笨重（甚至更加灵巧）。扩展函数使这成为一个合理的策略，但仅限于Kotlin，因为在那里它们更容易被发现。因此，我们只会在大多数情况下使用Kotlin时尝试这一技巧。幸运的是，我们的团队非常喜欢将Java转换为Kotlin，并且一直在通过本书的章节进行努力，所以我们准备尝试这种重构。
- en: Ultimately, we want to unencapsulate the collection so that our clients work
    in terms of `List<Journey>` rather than using `Route`, and operations are provided
    by extension functions on that `List<Journey>`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望解封装集合，使我们的客户端使用`List<Journey>`而不是`Route`来工作，并且操作由该`List<Journey>`上的扩展函数提供。
- en: 'We’ll start by converting `Route` to Kotlin, which after some tidying yields:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Route`类转换为 Kotlin 后，稍作整理，得到：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 15.6 [encapsulated-collections.2:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.6&show=diff)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.6 [encapsulated-collections.2:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.6&show=diff)'
- en: As usual, you should assume that we are running our tests between refactors
    to make sure that we haven’t broken anything. All is fine at the moment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，假设我们在重构之间运行测试，以确保我们没有破坏任何东西。目前一切正常。
- en: 'Once a class is in Kotlin, IntelliJ can convert methods into extension methods.
    Let’s try out this refactoring on the `departsFrom` property: select it, press
    Alt-Enter, and choose “Convert member to extension”. The method disappears and
    reappears at the top level of the file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类转为 Kotlin，IntelliJ 可以将方法转换为扩展方法。让我们在`departsFrom`属性上尝试这种重构：选择它，按下 Alt-Enter，然后选择“Convert
    member to extension”。方法消失并重新出现在文件的顶层：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 15.7 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.7&show=diff)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.7 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.7&show=diff)'
- en: 'Kotlin code will continue to be able to access `route.departsFrom` as a property,
    but Java code can’t. IntelliJ has helpfully fixed up the one Java usage to see
    the property as a static method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 代码将继续能够作为属性访问`route.departsFrom`，但 Java 代码不能。IntelliJ 已经很好地将唯一的 Java
    使用修复为查看属性作为静态方法：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 15.8 [encapsulated-collections.3:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.8&show=diff)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.8 [encapsulated-collections.3:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.8&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO24-1)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO24-1)'
- en: Call of static method in `Route.kt`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Route.kt`中调用静态方法
- en: '“Convert member to extension” works well for methods that only call `Route`’s
    public API. It will fail if we try it on, for example, `withJourneyAt`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: “Convert member to extension”对只调用`Route`公共 API 的方法效果很好。如果我们尝试对`withJourneyAt`进行转换，它将失败：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 15.9 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.9&show=diff)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.9 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.9&show=diff)'
- en: 'This references the `journeys` property, which is currently private and so
    not visible to an extension function. At this point we can make the property public
    (provided that we don’t abuse it by mutating the `List` from Java code). This
    fixes the extension function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这引用了当前私有的`journeys`属性，因此对扩展函数不可见。在此时，我们可以将该属性公开（前提是我们不会通过 Java 代码滥用对`List`的突变）。这修复了扩展函数：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 15.10 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.10&show=diff)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.10 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.10&show=diff)'
- en: 'We can continue the process of converting members to extensions until there
    are no members left; even `size` and `get` can be moved out, provided we are happy
    to use them statically in any remaining Java clients:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续将成员转换为扩展，直到没有成员剩余；即使`size`和`get`也可以移出，前提是我们愿意在任何剩余的 Java 客户端静态使用它们：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 15.11 [encapsulated-collections.5:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.11&show=diff)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.11 [encapsulated-collections.5:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.11&show=diff)'
- en: (Note that as we have converted the `size` method to a `size` extension property,
    Java sees a `getSize` function.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，由于我们已将`size`方法转换为`size`扩展属性，Java 看到的是`getSize`函数。）
- en: 'Here then is all that is left of the once-bloated `Route` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是曾经臃肿的`Route`类留下的所有内容：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 15.12 [encapsulated-collections.5:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.12&show=diff)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.12 [encapsulated-collections.5:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.12&show=diff)'
- en: All its operations (bar accessing the `journeys`) are now extensions, albeit
    in the same file. But now that they *are* extensions, we can move them from this
    file to others, even in different modules, to better decouple our dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它的所有操作（除了访问`journeys`）都是扩展函数，尽管在同一个文件中。但现在它们 *是* 扩展函数，我们可以将它们从这个文件移到其他文件，甚至是不同的模块，以更好地解耦我们的依赖关系。
- en: Substitute a Type Alias
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换类型别名
- en: 'Now that we’ve achieved our goal of decoupling the `Route` functionality from
    the class, is that class superfluous? Actually, wrapping the `List` is worse than
    superfluous: it prevents us from easily using all the useful extension functions
    in Kotlin’s standard library to construct, transform, and process routes. To quote
    one of Alan Perlis’s [Epigrams of Programming](https://oreil.ly/QDOJz): “It is
    better to have 100 functions operate on one data structure than 10 functions on
    10 data structures.” We don’t want a `Route` to *have* a `List` of `Journey`;
    we want it to *be* a `List` of `Journey`. This is very easy to achieve in Kotlin
    with delegation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了将`Route`功能从类中解耦的目标，那这个类是否多余呢？实际上，包装`List`不仅仅是多余的：它阻止我们轻松地使用 Kotlin
    标准库中所有有用的扩展函数来构造、转换和处理路由。引用 Alan Perlis 的[《编程的箴言》](https://oreil.ly/QDOJz)中的一句话：“与其让10个函数操作10种数据结构，不如让100个函数操作一个数据结构。”我们不希望`Route`
    *拥有*一个`List` of `Journey`；我们希望它 *是* 一个`List` of `Journey`。在 Kotlin 中通过委托这是非常容易实现的：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 15.13 [encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.13&show=diff)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.13 [encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.13&show=diff)'
- en: In fact, though, we may want more than for a `Route` to be a `List` of `Journey`;
    we may want a `List` of `Journey` to be a `Route`. To see why, let’s look at that
    `withJourneyAt` function that we glossed over earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可能不只是希望`Route`是`List` of `Journey`；我们可能希望`List` of `Journey` 是一个`Route`。为了理解为什么，让我们看看之前忽略的`withJourneyAt`函数。
- en: 'When a traveler decides that they would rather not travel by camel, we can’t
    just replace a `Journey`, because `Route` is immutable. Instead, we return a new
    `Route` where `journeys` is a copy with the relevant `Journey` replaced:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当旅行者决定不再乘坐骆驼时，我们不能简单地替换一个`Journey`，因为`Route`是不可变的。相反，我们返回一个新的`Route`，其中`journeys`是一个替换了相关`Journey`的副本：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 15.14 [encapsulated-collections.5:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.14&show=diff)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.14 [encapsulated-collections.5:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.14&show=diff)'
- en: (In passing, note that this test was made more complicated by only having `get`
    to access the components of a `route`. We can fix that now that we can access
    the `journeys` property directly.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，注意，由于只能使用`get`来访问`route`的组件而使得这个测试变得更加复杂。我们现在可以通过直接访问`journeys`属性来修复这个问题。）
- en: 'Here’s the implementation again:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看实现：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 15.15 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.15&show=diff)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.15 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.15&show=diff)'
- en: 'Because `Route` wraps `journeys`, we can’t just operate on `journeys`; we have
    to unwrap, operate, and then wrap back up again. If a `List<Journey>` was a `Route`,
    then we could use a nice generic function like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Route`包装了`journeys`，我们不能简单地操作`journeys`；我们必须解包、操作，然后重新包装。如果`List<Journey>`是一个`Route`，那么我们可以使用一个很好的泛型函数，例如：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 15.16 [encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.16&show=diff)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.16 [encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.16&show=diff)'
- en: 'As it is, even using `withItemAt`, we still have to deal with the wrapper:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现在一样，即使使用`withItemAt`，我们仍然必须处理包装器：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 15.17 [encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.17&show=diff)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.17 [封装集合.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.17&show=diff)'
- en: Any operation that transforms `Route`s will have this problem—a problem that
    wouldn’t exist if we just used a type alias to say that a `Route` and `List<Journey>`
    are the same type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何转换`Route`的操作都会遇到这个问题——这是一个问题，如果我们仅仅使用类型别名来表示`Route`和`List<Journey>`是相同的类型，这个问题就不存在了。
- en: To get there, we will have to remove all the calls to the `Route` constructor
    and the accesses of the `journeys` property, effectively unwrapping our carefully
    crafted encapsulation. There is a trick to do this automagically, but it relies
    on having converted all clients of `Route` to Kotlin. So does using a type alias
    though, so if we have any remaining Java clients, we have to resign ourselves
    to some manual editing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这一点，我们必须删除所有对`Route`构造函数的调用以及对`journeys`属性的访问，实际上是展开我们精心设计的封装。虽然有一个自动化的技巧可以做到这一点，但它依赖于将所有`Route`的客户端转换为Kotlin。使用类型别名也是如此，因此如果还有任何Java客户端，我们不得不接受一些手动编辑。
- en: 'What we’re going to do is replace the class with a type alias and, at the same
    time, add temporary definitions that emulate the API of the class. That API is
    currently:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是用类型别名替换类，并同时添加临时定义来模拟类的API。当前的API是：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 15.18 [encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.18&show=diff)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.18 [封装集合.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.18&show=diff)'
- en: 'We emulate it with:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下方式模拟它：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 15.19 [encapsulated-collections.8:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.19&show=diff)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.19 [封装集合.8:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.19&show=diff)'
- en: 'Because there is no `new` keyword in Kotlin, we can emulate the constructor
    call `Route(...)` with a function of the same name. Similarly, we replace the
    `journeys` property with an extension property that returns the receiver itself.
    The net result is that our Kotlin clients continue to compile against this new
    API:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在Kotlin中没有`new`关键字，我们可以用同名函数来模拟构造函数调用`Route(...)`。类似地，我们用返回接收者本身的扩展属性来替换`journeys`属性。其结果是我们的Kotlin客户端继续针对这个新API编译：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 15.20 [encapsulated-collections.8:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.20&show=diff)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.20 [封装集合.8:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.20&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO25-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO25-1)'
- en: Our new function, not the constructor
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新函数，而不是构造函数
- en: '[![2](assets/2.png)](#co_introduction_CO25-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO25-2)'
- en: Extension property, not the class property
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性，而不是类属性
- en: 'Inlining both function and property completes the refactor. The encapsulated
    collection is now just a collection:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数和属性的完成重构。封装的集合现在只是一个集合：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 15.21 [encapsulated-collections.9:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.21&show=diff)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.21 [封装集合.9:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.21&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO26-1)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO26-1)'
- en: '`Route` was a no-op'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`是一个空操作'
- en: '[![2](assets/2.png)](#co_introduction_CO26-2)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO26-2)'
- en: As was `journeys`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`journeys`
- en: 'Any remaining Java clients will have been broken when we replaced the `Route`
    class with a type alias, because Java doesn’t understand type aliases. We fixed
    those by hand, replacing `Route` with `List<Journey>`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用类型别名替换`Route`类时，任何剩余的Java客户端都会出问题，因为Java不理解类型别名。我们通过手动替换`Route`为`List<Journey>`来修复这些问题：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 15.22 [encapsulated-collections.8:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.22&show=diff)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.22 [封装集合.8:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.22&show=diff)'
- en: 'Our transformation is almost complete. We still have `size` and `get` functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的转换几乎完成。我们仍然有 `size` 和 `get` 函数：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 15.23 [encapsulated-collections.9:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.23&show=diff)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.23 [封装集合.9:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.23&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.23&show=diff)'
- en: Because these have the same signature as their method counterparts on `List`,
    the compiler warns us that they are shadowed; our Kotlin will be calling the methods,
    not the extensions. That means that if we didn’t have any Java client code invoking
    the extensions as statics, we could delete them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些与其方法在 `List` 上的签名相同，编译器警告我们它们被遮蔽；我们的 Kotlin 将调用方法，而不是扩展。这意味着如果没有任何 Java
    客户端代码将扩展调用为静态方法，我们可以删除它们。
- en: 'We do have a Java client, though—that pesky rendering code, which is still
    calling the extensions as `getSize` and `get` in `RouteKt`. Those extensions are
    calling the methods that we want to use, but we can’t inline code from Kotlin
    to Java, so we’ll just delete the extensions anyway. Now the compiler will tell
    us where we need to fix the Java, and we can do that by hand:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们确实有一个 Java 客户端——那个讨厌的渲染代码，它仍然在 `RouteKt` 中调用扩展作为 `getSize` 和 `get`。这些扩展调用了我们想要使用的方法，但我们无法从
    Kotlin 内联到 Java，所以我们将无论如何删除这些扩展。现在编译器将告诉我们需要手动修复 Java 的地方：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 15.24 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.24&show=diff)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.24 [封装集合.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.24&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.24&show=diff)'
- en: 'In reality, of course, we would replace this with:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们会用以下内容替换：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 15.25 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.25&show=diff)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.25 [封装集合.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.25&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.25&show=diff)'
- en: 'The Kotlin clients are unphased by deleting the extensions, because they were
    always calling the methods on `List`, so the transformation is almost complete.
    We can also now inline `withJourneyAt`, because it too is a no-op. This leaves
    us with `Route` like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 客户端对删除扩展并不感到意外，因为它们一直在调用 `List` 上的方法，所以转换几乎完成。现在我们还可以内联 `withJourneyAt`，因为它也是一个无操作。这样，`Route`
    就像这样：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 15.26 [encapsulated-collections.10:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.26&show=diff)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.26 [封装集合.10:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.26&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.26&show=diff)'
- en: 'Our Kotlin usages are just `List` operations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Kotlin 使用只是 `List` 操作：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 15.27 [encapsulated-collections.10:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.27&show=diff)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.27 [封装集合.10:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.27&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.27&show=diff)'
- en: 'Any residual Java is readable, if a little ugly:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何残留的 Java 代码是可读的，尽管有点丑陋：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 15.28 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.28&show=diff)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.28 [封装集合.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.28&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=15.28&show=diff)'
- en: Refactoring Collections with Other Properties
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用其他属性重构集合
- en: 'As we saw previously, we can’t use type aliases when our types have collections
    with other attributes. We looked at `Itinerary`, which combines an `id` with a
    `Route`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，当我们的类型包含其他属性的集合时，我们无法使用类型别名。我们看了一下 `Itinerary`，它将 `id` 与 `Route` 结合在一起：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 15.29 [encapsulated-collections.11:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.29&show=diff)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.29 [封装集合.11:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.29&show=diff)'
- en: 'We can get the advantages of being able to query `Journey`s directly by implementing
    `Route` with delegation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代理实现`Route`，我们可以直接查询`Journey`带来的好处：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 15.30 [encapsulated-collections.12:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.30&show=diff)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.30 [封装集合.12:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.30&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO27-1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO27-1)'
- en: The `by route` clause declares that the `Itinerary` object will delegate all
    methods on the `Route` interface to the `route` parameter passed to its constructor.
    A class can override this behavior by providing its own implementation of methods
    of the delegated interface, but we don’t want to do this for `Itinerary`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`by route`子句声明`Itinerary`对象将所有`Route`接口上的方法委托给其构造函数传递的`route`参数。类可以通过提供委托接口的自己实现来覆盖此行为，但我们不希望对`Itinerary`这样做。'
- en: 'Now that we can treat `Itinerary` as a `Route`, we can move `hasJourneyLongerThan`
    out as an extension and have it available to any `Route`, not just to `Itinerary`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`Itinerary`视为`Route`，我们可以将`hasJourneyLongerThan`作为扩展移出，并使其对任何`Route`都可用，而不仅仅是对`Itinerary`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 15.31 [encapsulated-collections.13:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.31&show=diff)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.31 [封装集合.13:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.31&show=diff)'
- en: 'All those extensions to `Route` (aka `List<Journey>`) that we moved from methods
    to extensions are also now applicable to `Itinerary` as well:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那些我们从方法移动到扩展中的`Route`（又名`List<Journey>`）也同样适用于`Itinerary`：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 15.32 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.32&show=diff)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.32 [封装集合.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.32&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO28-1)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO28-1)'
- en: This is `Route.duration`, aka `List<Journey>.duration`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Route.duration`，也就是`List<Journey>.duration`
- en: 'What we can’t do as easily is create a new `Itinerary` from an existing one.
    This is now easy for `Route`, because standard API operations on `List<Journey>`
    (actually, usually `Iterable<Journey>`, as we saw in [Chapter 6](ch06.html#java-to-kotlin-collections))
    return `List<Journey>`, which is the other name for `Route`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不能如此轻易实现的是从现有的`Itinerary`创建一个新的`Itinerary`。这在`Route`中现在变得很容易，因为在`List<Journey>`（实际上通常是`Iterable<Journey>`，正如我们在[第6章](ch06.html#java-to-kotlin-collections)中看到的）上的标准API操作返回`List<Journey>`，这也是`Route`的另一个名称：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 15.33 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.33&show=diff)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.33 [封装集合.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.33&show=diff)'
- en: 'For `Itinerary`, we have to create a new `Itinerary` to rewrap the result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Itinerary`，我们必须创建一个新的`Itinerary`以重新包装结果：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Example 15.34 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.34&show=diff)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.34 [封装集合.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.34&show=diff)'
- en: 'This is yet another place where data classes come to the rescue:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是另一个数据类发挥作用的地方：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Example 15.35 [encapsulated-collections.14:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.35&show=diff)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.35 [封装集合.14:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.35&show=diff)'
- en: 'Making `Itinerary` a data class means that we can make a copy with just a revised
    route, no matter how many other properties it has:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Itinerary`作为数据类意味着我们可以仅仅通过修改路线来复制它，无论它还有多少其他属性：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 15.36 [encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.36&show=diff)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.36 [封装集合.14:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.36&show=diff)'
- en: 'Better still, we can add a method `withTransformedRoute`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以添加一个方法`withTransformedRoute`：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 15.37 [encapsulated-collections.15:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.37&show=diff)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.37 [封装集合.15:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.37&show=diff)'
- en: 'This allows us to create a transformed `Itinerary` almost as easily as we could
    create a transformed `Route`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够创建一个转换后的`Itinerary`几乎和创建一个转换后的`Route`一样容易：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 15.38 [encapsulated-collections.15:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.38&show=diff)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15.38 [封装集合.15:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.38&show=diff)'
- en: Moving On
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: We started this chapter with a Java class that encapsulated a mutable collection
    to guarantee value semantics. As we translated more of our code to Kotlin, we
    could rely on Kotlin’s type system to prevent the collection from being modified,
    and no longer needed to encapsulate it within the class. That allowed us to convert
    operations from methods to extensions, and move their definitions close to where
    they are used. Because our class encapsulated a single collection, we were able
    to eliminate the class altogether and replace it with a type alias.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个Java类开始，该类封装了可变集合以保证值语义。随着我们将更多代码转换为Kotlin，我们可以依赖Kotlin的类型系统来防止修改集合，不再需要将其封装在类中。这使我们可以将操作从方法转换为扩展，并将它们的定义移动到它们被使用的地方附近。因为我们的类封装了单个集合，所以我们能够完全消除这个类，并用类型别名替换它。
- en: Immutable collections and extensions allow us to organize our code in ways that
    are not available in Java. We can group all the logic required by a particular
    feature of the application in the same module, regardless of the domain classes
    the logic applies to. However, if we wanted methods of those domain classes to
    be polymorphic methods, we would have to define them on those classes and not
    in our feature module. In [Chapter 18, *Open to Sealed Classes*](ch18.html#open-to-sealed-classes),
    we look at sealed classes, an alternative to object-oriented polymorphism that
    is more convenient when we define type hierarchies in one part of the code and
    operations on those types in another.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合和扩展使我们能够以Java不可用的方式组织代码。我们可以将应用程序特定功能所需的所有逻辑组织在同一个模块中，而不考虑逻辑适用的领域类。但是，如果我们希望这些领域类的方法成为多态方法，我们必须在这些类上定义它们，而不是在我们的特性模块中定义。在[第18章，*开放到密封类*](ch18.html#open-to-sealed-classes)，我们将看到密封类，这是一种替代面向对象多态性的方式，当我们在代码的一部分定义类型层次结构并在另一部分上对这些类型进行操作时，这种方式更为方便。
- en: Finally, note that reusing built-in types like `List` rather than defining a
    specific type is not without cost. We might be storing items in a `List` as an
    implementation detail rather than a modeling choice. It’s also a lot easier to
    “Find usages” of a specific wrapper class than a generic specialization. Nevertheless,
    the standard collection types are pervasive because they are such good abstractions—so
    good that we generally shouldn’t hide them. [Chapter 22, *Classes to Functions*](ch22.html#classes-to-functions),
    looks at what happens if we take this idea and run with it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，重用像`List`这样的内置类型而不是定义特定类型并非没有代价。我们可能将项目存储在`List`中作为实现细节而不是建模选择。针对特定包装类查找“使用情况”要比查找通用特化要容易得多。然而，标准集合类型是普遍存在的，因为它们是如此良好的抽象——所以好，以至于我们通常不应该隐藏它们。[第22章，*从类到函数*](ch22.html#classes-to-functions)，探讨了如果我们采纳这个想法会发生什么。
