- en: Chapter 4\. A Kubernetes-Based Software Development Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章\. 基于 Kubernetes 的软件开发平台
- en: In the previous chapter, we outlined our methodology around modernization and
    the steps required to design and develop modern architectures. We described the
    need for a platform like Kubernetes that can help you with requirements to make
    your applications cloud native, ready to scale up proportionally to your business’s
    need.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们概述了我们围绕现代化的方法论以及设计和开发现代架构所需的步骤。我们描述了像 Kubernetes 这样的平台的必要性，它可以帮助您满足将应用程序云原生化的需求，以便根据业务需求比例进行扩展。
- en: We have also demonstrated that a microservices-based architecture is usually
    implemented using container technology, which makes apps portable and consistent.
    Let’s now see in detail how Kubernetes can help us modernize our Java applications
    and what the steps are to achieve that using its declarative approach through
    a rich set of APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了通常使用容器技术实现的微服务架构，这使得应用程序具有可移植性和一致性。现在让我们详细看看 Kubernetes 如何帮助我们现代化我们的 Java
    应用程序，并通过其声明性方法和丰富的 API 集实现这一目标的步骤。
- en: Developers and Kubernetes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员和 Kubernetes
- en: '[Kubernetes](https://kubernetes.io), which in Greek translates to “pilot” or
    “governor,” is an open source project that is currently the de facto target environment
    for modern architectures and the most popular container orchestration platform;
    a simple illustration is presented in [Figure 4-1](#fig4-1). Started from Google’s
    experience in managing distributed complex applications for their software stack
    back in 2015, today it is one of the biggest open source communities; it is managed
    by a foundation, the Cloud Native Computing Foundation (CNCF), and embraced by
    vendors and individual contributors.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes](https://kubernetes.io)，在希腊语中翻译为“领航员”或“统治者”，是当前现代架构的事实标准目标环境和最流行的容器编排平台；简单示意图见[图 4-1](#fig4-1)。始于
    Google 2015 年在管理其软件堆栈的分布式复杂应用程序方面的经验，今天它是最大的开源社区之一；由云原生计算基金会（CNCF）管理，并受到供应商和个人贡献者的欢迎。'
- en: '![A Kubernetes Cluster running apps in Nodes](Images/moej_0401.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![一个运行在节点上的 Kubernetes 集群](Images/moej_0401.png)'
- en: Figure 4-1\. A Kubernetes cluster running apps in Nodes
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 一个运行在节点上的 Kubernetes 集群
- en: 'As a container-orchestration platform, its focus is primarily on ensuring that
    our apps are running correctly, providing out-of-the-box self-healing, recovery,
    and a powerful API to control this mechanism. You may be wondering now: as a developer,
    why should I care about Kubernetes if it is so self-proficient?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个容器编排平台，其主要关注点是确保我们的应用程序正确运行，提供开箱即用的自愈、恢复功能以及强大的 API 来控制这一机制。您现在可能会问：作为开发人员，如果
    Kubernetes 如此自足，我为什么要关心它呢？
- en: 'That’s a good question, and maybe a good answer is an analogy: you have a Formula
    1 car with autopilot, but if you want to win the race, you need to tune and set
    up your car to compete with all other good ones. The same is true for your apps,
    which can benefit from all the capabilities offered by the platform to tune them
    so they run optimally.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题，也许一个好的答案是类比：您有一辆配备自动驾驶的一级方程式赛车，但如果您想赢得比赛，您需要调整和设置您的车辆以与其他优秀车辆竞争。对于您的应用程序而言也是如此，它可以受益于平台提供的所有功能，使其以最佳方式运行。
- en: What Kubernetes Does
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 的功能
- en: 'When you have Kubernetes as a target platform to run your applications, you
    can rely on an ecosystem of APIs and components put in place to make deployments
    easier so developers can focus only on the most important part: coding. Kubernetes
    provides you with [a framework to run distributed systems resiliently](https://oreil.ly/DNRQS).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 Kubernetes 作为目标平台来运行您的应用程序时，您可以依赖于一套 API 和组件生态系统，以使部署更加简单，使开发人员只需关注最重要的部分：编码。Kubernetes
    为您提供了[一个可靠运行分布式系统的框架](https://oreil.ly/DNRQS)。
- en: 'In practice, this means you don’t need to reimplement custom solutions when
    it comes to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中，这意味着当涉及到以下情况时，您无需重新实现定制解决方案：
- en: Service discovery
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现
- en: Kubernetes uses internal DNS resolution to expose your apps; this is automatically
    assigned and can also be used to send the traffic to multiple instances of your
    app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用内部 DNS 解析来公开您的应用程序；这是自动分配的，也可以用于将流量发送到您应用程序的多个实例。
- en: Load balancing
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Kubernetes takes care of managing the load on your apps, balancing the traffic,
    and distributing user requests accordingly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 负责管理应用程序的负载、平衡流量并相应地分发用户请求。
- en: Self-healing
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自愈能力
- en: Kubernetes discovers and replaces failing containers automatically, providing
    a health check and self-healing mechanism out of the box.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 可自动发现并替换失败的容器，自带健康检查和自愈机制。
- en: Rollout and Rollback
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和回滚
- en: Kubernetes ensures your app is always running consistently at the desired state,
    providing control to scale up and scale down workloads. In addition, it offers
    the capability to rollout or rollback to a specific version of your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 确保您的应用程序始终以所需状态一致运行，提供控制以扩展和缩减工作负载。此外，它还提供了滚动部署或回滚到应用程序特定版本的能力。
- en: What Kubernetes Doesn’t Do
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 不做什么
- en: Many headaches that developers usually need to deal with in production are already
    solved and delegated to a platform, whose primary goal is to ensure applications
    are running. But does that provide all you need for modernizing your apps? Probably
    not.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常在生产环境中需要处理的许多头痛问题已经被解决并委托给一个平台，其主要目标是确保应用程序正常运行。但这是否提供了您现代化应用程序所需的一切呢？可能不。
- en: 'As we discussed in the previous chapter, the modernization steps toward a cloud
    native approach are more closely tied to a methodology rather than a specific
    technology. Once you’ve converted your mindset from building monolithic apps to
    creating microservices, we are in a good position to start thinking big. Nowadays,
    many apps run on cloud platforms targeting Kubernetes, and those are the ones
    running global-reach workloads. Here are some things to consider:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章讨论的，朝着云原生方法的现代化步骤更加紧密地与方法论而非特定技术联系在一起。一旦您将思维转变为构建微服务而不是单片应用，我们就可以开始有远大眼光地思考了。如今，许多应用程序在面向
    Kubernetes 的云平台上运行，并且这些应用程序正在运行具有全球覆盖范围的工作负载。以下是一些需要考虑的事项：
- en: Kubernetes doesn’t know how to handle your app. It can restart it if it fails,
    but it cannot understand why that is happening, so we need to ensure we have full
    control of our microservices-based architecture and be able to debug each container.
    This is particularly important in the case of a large-scale deployment.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 不知道如何处理您的应用程序。如果应用程序失败，它可以重新启动，但无法理解失败原因，因此我们需要确保我们完全控制基于微服务的架构，并能够调试每个容器。这在大规模部署的情况下尤为重要。
- en: Kubernetes doesn’t provide any middleware or application-level services. Granular
    discovery services need to be addressed by interacting with Kubernetes API or
    relying on some service on top of Kubernetes, such as a service mesh framework.
    There is no ecosystem for developers out of the box.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 不提供任何中间件或应用程序级服务。需要通过与 Kubernetes API 交互或依赖于 Kubernetes 之上的某些服务（如服务网格框架）来解决细粒度发现服务。它没有开箱即用的开发者生态系统。
- en: Kubernetes doesn’t build your app. You are responsible for providing your app
    compiled and packaged as a container image or relying on additional components
    on top of Kubernetes.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 不会构建您的应用程序。您需要负责将您的应用程序编译打包为容器镜像或依赖于 Kubernetes 之上的其他组件。
- en: With that in mind, let’s start digging into a Kubernetes journey for developers
    in order to make our first step to bringing our app into the next cloud native
    production environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些想法，让我们开始深入探讨开发者在 Kubernetes 旅程中的步骤，以便为将我们的应用程序带入下一个云原生生产环境迈出第一步。
- en: Infrastructure as a Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Kubernetes provides a set of APIs to manage the desired state of our app as
    well as the whole platform. Each component in Kubernetes has an API representation
    that can be consumed. Kubernetes offers a [declarative deployment pattern](https://oreil.ly/cURvG)
    that allows you to to automate the execution of upgrade and rollback processes
    for a group of Pods. The declarative approach is granular, and it is also used
    to extend Kubernetes APIs with the concept of *custom resources*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供一组 API 来管理我们应用程序的期望状态以及整个平台。Kubernetes 中的每个组件都有一个可以使用的 API 表示。Kubernetes
    提供了一种[声明式部署模式](https://oreil.ly/cURvG)，允许您自动化执行一组 Pod 的升级和回滚过程。声明式方法是细粒度的，也用于通过*自定义资源*概念扩展
    Kubernetes API。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Custom resources are extensions of the Kubernetes API. A *custom resource* represents
    a customization of a particular Kubernetes installation, bringing additional objects
    to extend cluster capabilities. You can get more info about it from the official
    Kubernetes [documentation](https://oreil.ly/cVBnl).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源是 Kubernetes API 的扩展。*自定义资源*代表对特定 Kubernetes 安装的定制化，引入了额外的对象以扩展集群功能。您可以从官方
    Kubernetes [文档](https://oreil.ly/cVBnl)获取更多信息。
- en: 'Some of the core objects you have to manage an application in Kubernetes are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在 Kubernetes 中管理的一些核心对象包括：
- en: Pod
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Pod
- en: A group of one or more containers deployed into a Kubernetes cluster. This is
    the entity that Kubernetes manages and orchestrates, so any application packaged
    as a container needs to be declared as a Pod.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一组一个或多个容器部署到 Kubernetes 集群中。这是 Kubernetes 管理和编排的实体，因此任何打包为容器的应用程序都需要声明为 Pod。
- en: Service
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Service
- en: The resource responsible for service discovery and load balancing. For any Pod
    to be discoverable and consumable, it needs to be mapped to a Service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 负责服务发现和负载均衡的资源。为了使任何 Pod 可被发现和使用，它需要映射到一个 Service。
- en: Deployment
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 部署
- en: This allows describing an application’s life cycle, driving the creation of
    Pods in terms of which images to use for the app, the number of Pods there should
    be, and how they should be updated. Furthermore, it helps to define health checks
    and constraint resources for your application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许描述应用程序的生命周期，驱动 Pod 的创建，确定使用哪些镜像来构建应用程序，应该有多少个 Pod，以及它们应该如何更新。此外，它还有助于定义健康检查和约束应用程序的资源。
- en: Each of these objects, along with all other resources in the cluster, can be
    defined and controlled with a YAML representation, or by Kubernetes API. There
    are also other useful API objects such as those related to storage (PersistentVolume)
    or used specifically to manage stateful apps (StatefulSet). In this chapter, we
    will focus on the fundamental ones needed to bring your app up and running inside
    a Kubernetes platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些对象以及集群中的所有其他资源，可以通过 YAML 表示或通过 Kubernetes API 定义和控制。还有其他有用的 API 对象，如与存储相关的（PersistentVolume）或专门用于管理有状态应用程序的对象（StatefulSet）。在本章中，我们将重点关注在
    Kubernetes 平台上使您的应用程序启动和运行所需的基本对象。
- en: Container Images
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器映像
- en: The first step for you in this journey is to containerize your microservices
    so they can be deployed into Kubernetes as a Pod, which is controlled by using
    a YAML file, invoking the API, or using a Kubernetes Java client.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段旅程中，您的第一步是将您的微服务容器化，以便它们可以作为 Pod 部署到 Kubernetes 中，这由使用 YAML 文件，调用 API 或使用
    Kubernetes Java 客户端控制。
- en: 'You can use the Inventory Quarkus microservice from Coolstore as an example
    to create your first container image. Containers are defined by a manifest called
    Dockerfile or Containerfile, where you will define your software stack as a layer,
    from the operating system layer to your application binary layer. The benefits
    of this approach are multiple: it is easy to track versions, inherit from existing
    layers, add layers, and expand the container. A diagram of layers is shown in
    [Figure 4-2](#fig4-2).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Coolstore 的 Inventory Quarkus 微服务作为示例来创建您的第一个容器映像。容器由一个称为 Dockerfile 或
    Containerfile 的清单定义，您将在其中定义您的软件堆栈作为一个层，从操作系统层到应用程序二进制层。这种方法的好处是多方面的：易于跟踪版本，继承现有层，添加层和扩展容器。图层的图示如
    [图 4-2](#fig4-2) 所示。
- en: '![Container Image Layers](Images/moej_0402.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![容器映像图层](Images/moej_0402.png)'
- en: Figure 4-2\. Container image layers
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 容器映像图层
- en: Dockerfile
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Writing a Dockerfile to package our app as a container is pretty straightforward
    for simple use cases. There are some basic directives called *Instructions* to
    use, such as the ones listed in [Table 4-1](#dockerfile_instructions).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的用例来说，编写 Dockerfile 来将我们的应用程序打包为容器非常简单。有一些基本指令称为 *Instructions*，如在 [表 4-1](#dockerfile_instructions)
    中列出的那些。
- en: Table 4-1\. Dockerfile Instructions
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. Dockerfile 指令
- en: '| Instruction | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FROM` | Used to inherit from a base image. For example, it can be a Linux
    distribution like `fedora`, `centos`, `rhel`, `ubuntu`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | 用于继承基础镜像。例如，可以是像`fedora`、`centos`、`rhel`、`ubuntu`这样的 Linux 发行版。
    |'
- en: '| `ENV` | Use environment variable for the container. These variables will
    be visible to the application and can be set at runtime. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `ENV` | 为容器使用环境变量。这些变量对应用程序可见，并且可以在运行时设置。 |'
- en: '| `RUN` | Execute a command in the current layer, like installing a package
    or executing an application. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `RUN` | 在当前层中执行命令，如安装软件包或执行应用程序。 |'
- en: '| `ADD` | Copy files from your workstation to the container layer, like a JAR
    file or a configuration file. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` | 将文件从工作站复制到容器层，如 JAR 文件或配置文件。 |'
- en: '| `EXPOSE` | If your application is listening to some port, you can expose
    it to the container network so Kubernetes can map it to a Pod and a Service. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | 如果你的应用程序监听某个端口，可以将其暴露给容器网络，以便 Kubernetes 将其映射到一个 Pod 和一个 Service。
    |'
- en: '| `CMD` | The command you use to start your application: the final step of
    the container image building process where you have all your dependencies in the
    layers, and you can run your app safely. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `CMD` | 启动应用程序的命令：容器镜像构建过程的最后一步，其中您在各层中拥有所有依赖项，可以安全运行应用程序。'
- en: The process for creating your container from your Dockerfile is also described
    in [Figure 4-3](#fig4-3).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的 Dockerfile 创建容器的过程也在[图 4-3](#fig4-3)中描述。
- en: '![Building a Container Image](Images/moej_0403.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![构建容器镜像](Images/moej_0403.png)'
- en: Figure 4-3\. Building a container image
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 构建容器镜像
- en: 'An example of a Dockerfile for the Inventory Quarkus Java microservice that
    we created in [Chapter 2](ch02.xhtml#changing_technologies) is listed next, and
    you can find it in this [book’s GitHub repository](https://oreil.ly/D9u1k):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml#changing_technologies)中创建的库存 Quarkus Java 微服务的 Dockerfile
    示例如下，并且您可以在本[书的 GitHub 仓库](https://oreil.ly/D9u1k)中找到它：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO1-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO1-1)'
- en: We start from OpenJDK 11 layer to build our container image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 OpenJDK 11 层开始构建我们的容器镜像。
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO1-2)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO1-2)'
- en: Set an environment variable that can be consumed within the app for differentiating
    profiles or configurations to load.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个环境变量，在应用程序内部可以使用它来区分不同的配置文件或配置项。
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO1-3)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO1-3)'
- en: Copy the JAR artifact built during compilation into the container image. This
    supposes you have compiled a “fat-jar” or “uber-jar” that contains all dependencies
    in the same JAR file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 复制在编译过程中构建的 JAR 工件到容器镜像中。 这假设您已经编译了一个包含所有依赖项的“fat-jar”或“uber-jar”，它们在同一个 JAR
    文件中。
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO1-4)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO1-4)'
- en: Expose port 8080 to the container network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将端口 8080 映射到容器网络。
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO1-5)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO1-5)'
- en: Run the application invoking the artifact we copied into the layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序以调用我们复制到层中的工件。
- en: In this section, we defined a Dockerfile with the minimum instructions set to
    build up a container image. Let’s see now how to create container images from
    a Dockerfile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了一个 Dockerfile，其中包含用于构建容器镜像的最小指令集。 现在让我们看看如何从 Dockerfile 创建容器镜像。
- en: Building Container Images
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Now you need to create the container image. [Docker](https://www.docker.com)
    is a popular open source project to create containers; you can download it for
    your operating system and start using it to build and run your containers. [Podman](https://podman.io)
    is another open source alternative to do this, and it can also generate Kubernetes
    objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要创建容器镜像。 [Docker](https://www.docker.com) 是一个流行的开源项目，用于创建容器；您可以下载适用于您操作系统的版本，并开始使用它来构建和运行容器。
    [Podman](https://podman.io) 是另一个开源替代方案，也可以生成 Kubernetes 对象。
- en: 'When you have Docker or Podman on your workstation, you can start building
    your container from the Dockerfile with this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的工作站上安装了 Docker 或 Podman 后，您可以使用以下命令从 Dockerfile 开始构建您的容器：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will generate your container image by reading the instructions from the
    Dockerfile. Then it will tag your container image in the form `<repository>/<name>:<tag>`,
    in this case, `docker.io/modernizingjavaappsbook/inventory-quarkus:latest`. You
    will see an output similar to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过读取 Dockerfile 中的指令来生成您的容器镜像。 然后，它将标记您的容器镜像为 `<repository>/<name>:<tag>`
    的形式，例如 `docker.io/modernizingjavaappsbook/inventory-quarkus:latest`。 您将看到类似于此的输出：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your container image is now stored in Docker’s or Podman’s local storage called
    *Docker cache* or *Container cache*, and it is ready to be used locally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您的容器镜像现在存储在 Docker 或 Podman 的本地存储中，称为*Docker 缓存*或*容器缓存*，已准备好在本地使用。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can create an Uber-Jar for production for the Inventory service with this
    command: `./mvnw package -Dquarkus.profile=prod`. You can let Docker or Podman
    compile your software and create the container using a particular kind of container
    images build called [Multi-stage](https://oreil.ly/HzhDj). See [this Dockerfile](https://oreil.ly/UK3c2)
    as an example.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此命令为库存服务创建一个生产用的 Uber-Jar：`./mvnw package -Dquarkus.profile=prod`。 您可以让
    Docker 或 Podman 编译您的软件，并使用称为[多阶段](https://oreil.ly/HzhDj)的特定类型容器镜像构建来创建容器。 查看[此
    Dockerfile](https://oreil.ly/UK3c2) 作为示例。
- en: Run Containers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行容器
- en: '*Running containers* refers to pulling the container images from the container
    cache to run applications. This process will be isolated by the container runtime
    (such as Docker or Podman) from the other ones in our workstation, providing a
    portable application with all dependencies managed inside a container and not
    in our workstation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行容器* 指的是从容器缓存中拉取容器镜像以运行应用程序。这个过程将由容器运行时（如 Docker 或 Podman）从我们工作站中的其他进程隔离开来，提供了一个便携式的应用程序，所有依赖项都在容器内管理，而不是在我们的工作站上。'
- en: 'To start testing the Inventory microservice packaged now as a container image,
    you can run the command below:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试打包为容器镜像的 Inventory 微服务，您可以运行以下命令：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You see that the Quarkus microservice is up and running in a container, listening
    to the port 8080\. Docker or Podman takes care of mapping container networking
    into your workstation; open your browser at [*http://localhost:8080*](http://localhost:8080),
    and you will see the Quarkus welcome page (as in [Figure 2-4](ch02.xhtml#fig2-4)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 微服务已在容器中启动并运行，监听 8080 端口。Docker 或 Podman 负责将容器网络映射到您的工作站；在[*http://localhost:8080*](http://localhost:8080)
    打开浏览器，您将看到 Quarkus 欢迎页面（如[图 2-4](ch02.xhtml#fig2-4)所示）。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Docker Network documentation](https://oreil.ly/ja9Iu) contains more info on
    how to map ports and networks within containers and hosts running Docker.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[Docker 网络文档](https://oreil.ly/ja9Iu) 包含了关于如何在运行 Docker 的容器和主机内映射端口和网络的更多信息。'
- en: Registry
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册表
- en: As we described in the previous section, container images are stored in a local
    cache. However, if you want to make them available outside your workstation, you
    need to send them over in some convenient way. A container image’s size is generally
    hundreds of megabytes. That’s why you need a container image registry.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所描述的，容器镜像存储在本地缓存中。然而，如果您想要将它们在工作站外部提供，您需要以某种便捷的方式发送它们。容器镜像的大小通常为几百兆字节。这就是为什么您需要一个容器镜像注册表。
- en: The registry essentially acts as a place to store container images and share
    them via a process of uploading to (pushing) and downloading from (pulling). Once
    the image is on another system, the original application contained within it can
    be run on that system as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表基本上充当存储容器镜像并通过上传（推送）和下载（拉取）分享它们的地方。一旦镜像位于另一个系统上，其中包含的原始应用程序也可以在该系统上运行。
- en: Registries can be public or private. Popular public registries include [Docker
    Hub](https://hub.docker.com) and [Quay.io](https://quay.io). They are offered
    as a SaaS on the internet and allow images to be available publicly with or without
    authentication. Private registries are usually dedicated to specific users and
    are not accessible for public usage. However, you may make them available to private
    environments, such as private Kubernetes clusters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表可以是公共的或私有的。流行的公共注册表包括[Docker Hub](https://hub.docker.com)和[Quay.io](https://quay.io)。它们作为互联网上的
    SaaS 提供，并允许以公开或不需要身份验证的方式提供镜像。私有注册表通常专为特定用户而设，并且不能公开使用。然而，您可以将它们提供给私有环境，例如私有 Kubernetes
    集群。
- en: In this example, we created an organization at DockerHub for the book, called
    `modernizingjavaappsbook`, that maps into a repository of this public registry
    where we want to push our container image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 DockerHub 上为这本书创建了一个名为 `modernizingjavaappsbook` 的组织，它映射到这个公共注册表的一个仓库，我们希望将我们的容器镜像推送到这里。
- en: 'First, you need to log in to the registry. You need to authenticate against
    it in order to be able to push new content, then you will leave the container
    image publicly available:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要登录到注册表。您需要进行身份验证以能够推送新内容，然后您将使得容器镜像公开可用：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you log in successfully, you can start uploading the Inventory container
    image to the registry:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您可以开始将 Inventory 容器镜像上传到注册表：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command pushes the images to the registry, and you should get output similar
    to the following as confirmation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将镜像推送到注册表，并且您应该得到类似以下内容的输出作为确认：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Quarkus microservice, packaged as a container image, is now ready to be
    deployed everywhere!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 已打包为容器镜像的 Quarkus 微服务现已准备好在任何地方部署！
- en: Deploying to Kubernetes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: Deploying applications to Kubernetes is done by interacting with Kubernetes
    API to create the objects representing the desired state of the app in a Kubernetes
    cluster. As we discussed, Pods, Services, and Deployments are the minimum objects
    created to let Kubernetes manage the entire application life cycle and connectivity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与 Kubernetes API 交互来部署应用程序，以创建代表应用程序所需状态的对象，这是在 Kubernetes 集群中完成的。正如我们讨论的那样，Pod、Service
    和 Deployment 是在 Kubernetes 管理整个应用程序生命周期和连接性所创建的最小对象。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t have a Kubernetes cluster yet, you can download and use [minikube](https://oreil.ly/n2Kgx),
    a standalone Kubernetes cluster designed for local development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未拥有 Kubernetes 集群，可以下载并使用 [minikube](https://oreil.ly/n2Kgx)，这是一个专为本地开发设计的独立
    Kubernetes 集群。
- en: 'Every object in Kubernetes contains the following values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的每个对象都包含以下值：
- en: apiVersion
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion
- en: Kubernetes API version used to create this object
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建此对象的 Kubernetes API 版本
- en: kind
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: kind
- en: The object type (e.g. Pod, Service)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型（例如 Pod、Service）
- en: metadata
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: metadata
- en: Pieces of information that help uniquely identify the object, such as a name
    or UID
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于唯一标识对象的信息片段，如名称或 UID
- en: spec
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: spec
- en: The desired state for the object
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的期望状态
- en: In this section, we defined the basic structure of any Kubernetes objects. Now,
    let’s explore the fundamental objects needed to run applications on top of Kubernetes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了任何 Kubernetes 对象的基本结构。现在，让我们探讨在 Kubernetes 上运行应用程序所需的基本对象。
- en: Pod
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod
- en: A [Pod](https://oreil.ly/KQk2T) is a group of one or more containers with shared
    storage and network resources and a specification for how to run the containers.
    In [Figure 4-4](#fig4-4), you can see a representation of two Pods in a Kubernetes
    cluster, with an example IP address assigned by Kubernetes to each of them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pod](https://oreil.ly/KQk2T) 是一个或多个容器的组合，共享存储和网络资源，并具有运行容器的规范。在 [图 4-4](#fig4-4)
    中，您可以看到 Kubernetes 集群中两个 Pod 的表示，每个 Pod 都分配了 Kubernetes 分配的示例 IP 地址。'
- en: '![Pods and containers](Images/moej_0404.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Pod 和容器](Images/moej_0404.png)'
- en: Figure 4-4\. Pods and containers
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. Pod 和容器
- en: 'Kubernetes doesn’t work directly with containers; it relies on the Pod concept
    to orchestrate containers. As such, you need to provide a Pod definition that
    matches your container:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不直接与容器一起工作；它依赖 Pod 概念来编排容器。因此，您需要提供与您的容器匹配的 Pod 定义：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO2-1)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO2-1)'
- en: Name for the Pod object, unique per Namespace
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 对象的名称，在每个命名空间中唯一
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO2-2)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO2-2)'
- en: A list of key/value pairs to apply to this object
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一组要应用于此对象的键/值对
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO2-3)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO2-3)'
- en: A list of containers used in this Pod
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此 Pod 中的容器列表
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO2-4)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO2-4)'
- en: The container image URI, in this case a repository publicly available in Docker
    Hub
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像 URI，在本例中是 Docker Hub 上公开可用的存储库
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO2-5)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO2-5)'
- en: The port exposed by this container, to be mapped into a Pod
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由此容器公开的端口，要映射到 Pod 中
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Generally, one Pod contains one container, thus the mapping is 1 Pod : 1 application.
    Although you could have multiple containers in one Pod for some use cases (e.g.,
    sidecars), the best practice is to map 1 Pod to 1 app, because this ensures scalability
    and maintainability.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个 Pod 包含一个容器，因此映射为 1 Pod：1 应用程序。尽管对于某些用例（例如边车），您可以在一个 Pod 中有多个容器，但最佳实践是将
    1 Pod 映射到 1 个应用程序，因为这确保了可扩展性和可维护性。
- en: 'You can create any of the Kubernetes objects described previously as a YAML
    file with the Kubernetes CLI `kubectl`. Run the command as shown next to deploy
    your first microservice as a single Pod. You can find it in this [book’s GitHub
    repository](https://oreil.ly/YF8bT):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面描述的任何 Kubernetes 对象作为 YAML 文件使用 Kubernetes CLI `kubectl` 创建。运行下面显示的命令，部署您的第一个微服务作为单个
    Pod。您可以在本书的 [GitHub 代码库](https://oreil.ly/YF8bT) 中找到它。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To check that it is running on Kubernetes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查它是否在 Kubernetes 上运行：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get an output similar to:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下输出：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you look at the `STATUS` column, it shows the Pod is running correctly and
    all default health checks are correctly satisfied.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看 `STATUS` 列，它显示 Pod 正确运行，并且所有默认健康检查都正确满足。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you want further details on how to make more granular health checks, please
    refer to the official Kubernetes documentation for [liveness and readiness probes](https://oreil.ly/sOdnL).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步了解如何进行更精细的健康检查，请参考官方 Kubernetes 文档中的 [活跃检测和准备检测](https://oreil.ly/sOdnL)。
- en: Service
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: '[Kubernetes Services](https://oreil.ly/fOfpN) are used to expose an application
    running on a set of Pods. This is useful because a Pod gets a random IP address
    from the Kubernetes network, which may change if it is restarted or moved to another
    node within a Kubernetes cluster. Services offers a more consistent way to communicate
    with Pods, acting as a DNS server and load balancer.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes 服务](https://oreil.ly/fOfpN)用于暴露运行在一组 Pod 上的应用程序。这很有用，因为 Pod 从 Kubernetes
    网络中获得随机 IP 地址，如果重新启动或移动到 Kubernetes 集群中的另一个节点，该地址可能会更改。服务提供了一种更一致的方式与 Pod 进行通信，充当
    DNS 服务器和负载均衡器。'
- en: A Service is mapped to one or more Pods; it uses the internal DNS to resolve
    to an internal IP from a mnemonic short hostname (e.g., `inventory-quarkus`),
    and balances the traffic to the Pods as shown in [Figure 4-5](#fig4-5). Each Service
    get its own IP address from a dedicated IP address range, which is different from
    a Pod’s IP address range.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务映射到一个或多个 Pod；它使用内部 DNS 解析到一个来自助记短主机名（例如 `inventory-quarkus`）的内部 IP，并根据 [图 4-5](#fig4-5)
    中显示的方式平衡流量。每个服务从专用 IP 地址范围中获得自己的 IP 地址，这与 Pod 的 IP 地址范围不同。
- en: '![Kubernetes Service](Images/moej_0405.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes 服务](Images/moej_0405.png)'
- en: Figure 4-5\. A Kubernetes Service
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. Kubernetes 服务
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The balancing method offered by Kubernetes Services is Layer 4 (TCP/UDP). The
    only two strategies usable are round-robin and source IP. For application layer
    balancing (e.g., HTTP), there are other objects like `Ingress` not covered in
    this book, but you can find the documentation for them [here](https://oreil.ly/VBvOu).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务提供的负载均衡方法是第 4 层（TCP/UDP）。唯一可用的两种策略是轮询和源 IP。对于应用层负载均衡（例如 HTTP），还有其他对象如
    `Ingress`，本书未涵盖，但你可以在这里找到它们的文档 [here](https://oreil.ly/VBvOu)。
- en: 'Let’s have a look at a Service that could map our Pod:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下可能映射我们 Pod 的服务：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO3-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO3-1)'
- en: Name for the Service object
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象的名称
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO3-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO3-2)'
- en: The label exposed by the Pod to match the Service
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 暴露的标签，用于匹配服务
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO3-3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO3-3)'
- en: The L4 protocol used, TCP or UDP
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的 L4 协议，TCP 或 UDP
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO3-4)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO3-4)'
- en: The port used by this Service
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务使用的端口
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO3-5)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO3-5)'
- en: The port used by the Pod and mapped into the Service
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 使用的端口，并映射到服务中
- en: 'To create your Service, run the command as shown below. You can also find it
    in this [book’s GitHub repository](https://oreil.ly/e13Dd):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的服务，请按照下面显示的命令运行。你也可以在这本书的 [GitHub 仓库](https://oreil.ly/e13Dd) 中找到它。
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To check that it is running on Kubernetes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上检查它是否在运行：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get output similar to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似如下的输出：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You just defined a Service, mapped to a Pod. This is only accessible from the
    internal Kubernetes network, unless you expose it with an object that can accept
    the traffic from outside the cluster, like Ingress.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚定义了一个服务，映射到一个 Pod。这只能从内部 Kubernetes 网络访问，除非你使用像 Ingress 这样的对象来接受来自集群外部的流量，使其暴露出去。
- en: Deployment
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Deployments are Kubernetes objects created for managing an application life
    cycle. A deployment describes a desired state, and Kubernetes will implement it
    using either a *rolling* or *re-create* deployment strategy. The rollout life
    cycle consists of progressing, complete, and failed states. A deployment is progressing
    while it is performing update tasks, such as updating or scaling Pods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是用于管理应用程序生命周期的 Kubernetes 对象。部署描述了一个期望的状态，Kubernetes 将使用“滚动”或“重新创建”部署策略来实现它。部署的部署生命周期包括进行中、完成和失败状态。当部署正在执行更新任务（例如更新或扩展
    Pod）时，部署处于进行中状态。
- en: 'Kubernetes deployments offer a set of capabilities on top of the basic Pod
    and Service concepts as listed next and in [Figure 4-6](#fig4-6):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 部署在基本 Pod 和服务概念之上提供了一组功能，如下列出的内容和 [图 4-6](#fig4-6) 中显示的内容：
- en: Deploy a ReplicaSet or Pod
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 ReplicaSet 或 Pod
- en: Update Pods and ReplicaSets
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 Pods 和 ReplicaSets
- en: Rollback to previous deployment versions
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚到先前的部署版本
- en: Scale a deployment
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展一个部署
- en: Pause or continue a deployment
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停或继续一个部署
- en: Define health checks
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义健康检查
- en: Define resources constraints
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义资源约束
- en: '![Deployments manage applications life-cycle and updates](Images/moej_0406.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![部署管理应用程序的生命周期和更新](Images/moej_0406.png)'
- en: Figure 4-6\. Deployments manage an application’s life cycle and updates
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 部署管理应用程序的生命周期和更新
- en: 'Managing applications with a Kubernetes deployment includes the way in which
    an application should be updated. A major benefit of a deployment is the ability
    to start and stop a set of Pods predictably. There are two strategies for deploying
    apps in Kubernetes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 部署管理应用程序包括应用程序应该如何更新的方式。部署的一个主要优势是能够可预测地启动和停止一组 Pods。在 Kubernetes
    中部署应用程序有两种策略：
- en: Rolling update
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新
- en: It provides a controlled, phased replacement of the application’s Pods, ensuring
    that there are always a minimum number available. This is useful for the business
    continuity of an application, where the traffic is not routed into a new version
    of the application until the health checks (probes) on the desired number of Pods
    deployed are satisfied.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了对应用程序的 Pod 的可控、分阶段的替换，确保始终有一定数量的 Pod 可用。这对于应用程序的业务连续性非常有用，直到部署的所需数量的 Pod
    的健康检查（探针）得到满足，流量才会被路由到应用程序的新版本中。
- en: Re-create
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重新创建
- en: It removes all existing pods before new ones are created. Kubernetes first terminates
    all containers from the current version and then starts all new containers simultaneously
    when the old containers are gone. This provides downtime for the app, but it ensures
    there aren’t multiple versions running at the same time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它会在创建新的 Pods 之前移除所有现有的 Pods。Kubernetes 首先终止当前版本的所有容器，然后在旧容器消失时同时启动所有新容器。这会为应用程序带来停机时间，但它确保没有多个版本同时运行。
- en: 'A `Deployment` object driving Pods deployment on Kubernetes is listed in the
    following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中列出了在 Kubernetes 上驱动 Pods 部署的`Deployment`对象：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO4-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO4-1)'
- en: Name for the Deployment object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 部署对象的名称。
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO4-2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO4-2)'
- en: The label for this object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象的标签。
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO4-3)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO4-3)'
- en: The desired number of Pod replicas.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 副本的期望数量。
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO4-4)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO4-4)'
- en: The selector to find which Pods to manage using labels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签找到要管理的 Pods 的选择器。
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO4-5)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO4-5)'
- en: The Pod template to use, including labels to inherit or containers to create.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的 Pod 模板，包括要继承的标签或要创建的容器。
- en: '[![6](Images/6.png)](#co_a_kubernetes_based_software_development_platform_CO4-6)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_a_kubernetes_based_software_development_platform_CO4-6)'
- en: The container image to use.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的容器镜像。
- en: '[![7](Images/7.png)](#co_a_kubernetes_based_software_development_platform_CO4-7)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_a_kubernetes_based_software_development_platform_CO4-7)'
- en: Kubernetes uses readiness probes to know when a container is ready to start
    accepting traffic, and a Pod is considered ready when all of its containers are
    ready. Here we define an HTTP health check on the root path as a readiness probe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用就绪探针来知道何时容器已准备好开始接受流量，当其所有容器都准备好时，Pod 被视为已准备好。在这里，我们将根路径上的 HTTP
    健康检查定义为就绪探针。
- en: '[![8](Images/8.png)](#co_a_kubernetes_based_software_development_platform_CO4-8)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_a_kubernetes_based_software_development_platform_CO4-8)'
- en: Kubernetes uses liveness probes to know when to restart a container. Here we
    define an HTTP health check on the root path as a liveness probe.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用存活探针来知道何时重新启动容器。在这里，我们将根路径上的 HTTP 健康检查定义为存活探针。
- en: 'Run the following command to create your Deployment. You can also find it in
    this [book’s GitHub repository](https://oreil.ly/PWucG):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来创建您的 Deployment。您也可以在本书的 [GitHub 存储库](https://oreil.ly/PWucG) 中找到它：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following command to verify that the Deployment has been created, and
    to get the status:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来验证已创建 Deployment，并获取其状态：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get output similar to:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到类似于以下输出：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Looking at the `READY` column, you have your desired state correctly matched,
    having requested one replica for the Inventory microservice running on Kubernetes.
    You can cross-check that a Pod has been created:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `READY` 列，您的期望状态已正确匹配，请求在 Kubernetes 上运行的 Inventory 微服务的一个副本。您可以交叉检查是否已创建
    Pod：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should get similar output to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似的输出：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now a new Pod has been created using a randomly generated name, starting from
    the `inventory-quarkus-deploy` Deployment name. If the app crashes or if we kill
    the Pod managed by the Deployment, Kubernetes will re-create it automatically
    for us. This is not true for the Pod generated without a Deployment:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用随机生成的名称创建了一个新的 Pod，从 `inventory-quarkus-deploy` 部署名称开始。如果应用程序崩溃或我们杀死由部署管理的
    Pod，则 Kubernetes 将自动重新创建它。这对没有部署的 Pod 并不适用：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see that the desired state is always met:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到始终满足期望状态：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should get output similar to:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下的输出：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Kubernetes and Java
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 Java
- en: Kubernetes has a tremendous amount of potential for managing applications’ life
    cycles, and there are a number of studies on how developers and architects could
    best fit in its architecture, like patterns. Kubernetes patterns are reusable
    design patterns for container-based applications and services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 具有管理应用程序生命周期的巨大潜力，有许多研究关于开发人员和架构师如何最好地适应其架构，例如模式。Kubernetes 模式是针对基于容器的应用程序和服务的可重用设计模式。
- en: 'From a Java developer perspective, the first step is to migrate from the monolithic
    approach to a microservice-based approach. Once that is complete, the next step
    is to get into the Kubernetes context and maximize the benefits this platform
    offers: API extendibility, a declarative model, and a standarized process where
    the IT industry is converging.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 开发者的角度来看，第一步是从单块应用程序方法迁移到基于微服务的方法。完成后，下一步是进入 Kubernetes 环境，并最大化该平台提供的优势：API
    可扩展性，声明式模型以及 IT 行业正在收敛的标准化流程。
- en: There are Java frameworks that help developers connect to Kubernetes and convert
    their apps to containers. You already containerized the `Inventory` Quarkus microservice
    with a Dockerfile. Now let’s drive this containerization from Java, generating
    a container image for the `Catalog` Spring Boot microservice using Maven and Gradle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 Java 框架可以帮助开发人员连接到 Kubernetes 并将其应用程序转换为容器。您已经使用 Dockerfile 对 `Inventory`
    Quarkus 微服务进行了容器化。现在让我们从 Java 驱动这种容器化过程，使用 Maven 和 Gradle 为 `Catalog` Spring Boot
    微服务生成一个容器镜像。
- en: Jib
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jib
- en: '[Jib](https://oreil.ly/N2jRr) is an open source framework made by Google to
    build container images compliant to the Open Container Initiative (OCI) image
    format, without the need of Docker or any container runtime. You can create containers
    even from your Java codebase because it offers a Maven and Gradle plug-in for
    that. This means Java developers can containerize their app without writing and/or
    maintaining any Dockerfiles, delegating this complexity to Jib.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jib](https://oreil.ly/N2jRr) 是由 Google 开发的开源框架，用于构建符合开放容器倡议（OCI）镜像格式的容器镜像，无需
    Docker 或任何容器运行时。您甚至可以从您的 Java 代码库中创建容器，因为它为此提供了 Maven 和 Gradle 插件。这意味着 Java 开发人员可以在不编写和/或维护任何
    Dockerfile 的情况下容器化其应用程序，将这种复杂性委托给 Jib。'
- en: 'We see the [benefits from this approach](https://oreil.ly/2y92D) as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到从这种方法中获得的[好处](https://oreil.ly/2y92D)如下：
- en: Pure Java
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 Java
- en: No Docker or Dockerfile knowledge is required; simply add Jib as a plug-in,
    and it will generate the container image for you. The resulting image is commonly
    referred to as “distroless,” since it doesn’t inherit from any base image.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 无需 Docker 或 Dockerfile 知识；只需将 Jib 添加为插件，它将为您生成容器镜像。由此产生的镜像通常被称为“distroless”，因为它不继承任何基础镜像。
- en: Speed
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: The application is divided into multiple layers, splitting dependencies from
    classes. There’s no need to rebuild the container image as is necessary for Dockerfiles;
    Jib takes care of deploying the layers that changed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序被分成多个层，从类中分离依赖项。无需像 Dockerfile 那样重新构建容器镜像；Jib 负责部署更改的层。
- en: Reproducibility
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可复现性
- en: Unnecessary updates are not triggered, as the same contents always generate
    the same image.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不会触发不必要的更新，因为相同的内容始终生成相同的镜像。
- en: 'The easiest way to kick-start a container image build with Jib, on existing
    Maven, is by adding the plug-in via command line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行添加插件，以现有 Maven 快速启动使用 Jib 构建容器镜像的最简单方法是：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, you can do so by adding Jib as a plug-in into *pom.xml*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过将 Jib 添加为 *pom.xml* 中的插件来完成：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this way you can also manage other settings such as authentication or parameters
    for the build. Run the command below if you want to build the Catalog service
    and push it directly to Docker Hub:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你也可以管理其他设置，比如身份验证或构建的参数。如果你想要构建 Catalog 服务并直接推送到 Docker Hub，请运行下面的命令：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The authentication here is managed as command line options, but Jib is able
    to manage existing authentication with Docker CLI or read credentials from your
    *settings.xml*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的身份验证是通过命令行选项管理的，但 Jib 能够使用 Docker CLI 管理现有的身份验证，或者从你的 *settings.xml* 读取凭据。
- en: 'The build takes a few moments, and the result is a distroless container image
    built locally and pushed directly to a registry, in this case Docker Hub:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 构建需要一些时间，结果是一个本地构建并直接推送到仓库的 distroless 容器镜像，在这种情况下是 Docker Hub：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Your container image is not present in your local cache, as you don’t need any
    container runtime to build images with Jib. You won’t see it with the `docker
    images` command, but you pull it from Docker Hub afterward and it will be stored
    in your cache. In case you also want to store it locally from the beginning, Jib
    also connects to Docker hosts and can do it for you.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不需要任何容器运行时来使用 Jib 构建镜像，因此你的容器镜像不会出现在本地缓存中。你不会在 `docker images` 命令中看到它，但之后你可以从
    Docker Hub 拉取它并存储在你的缓存中。如果你也想从一开始就将其存储在本地，Jib 也可以连接到 Docker 主机并为你执行此操作。
- en: JKube
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JKube
- en: '[Eclipse JKube](https://oreil.ly/Km2ci), a community project supported by the
    Eclipse Foundation and Red Hat, is another open source Java framework to help
    with interacting with Kubernetes from a Java developer perspective. It supports
    building container images using Docker/Podman, Jib, and Source-to-Image (S2I).
    Eclipse JKube also provides a set of tools to deploy automatically to Kubernetes
    and manage the application with helpers for debugging and logging. It comes from
    Fabric8 Maven Plug-in, rebranded and enhanced as a project to target Kubernetes.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eclipse JKube](https://oreil.ly/Km2ci) 是由 Eclipse 基金会和红帽支持的社区项目，是另一个帮助 Java
    开发人员与 Kubernetes 交互的开源 Java 框架。它支持使用 Docker/Podman、Jib 和 Source-to-Image (S2I)
    构建容器镜像。Eclipse JKube 还提供了一组工具，可自动部署到 Kubernetes 并管理应用程序，其中包括调试和日志记录的助手。它来自 Fabric8
    Maven 插件，经过重新品牌和增强，以目标 Kubernetes 的项目形式发布。'
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: JKube supports Kubernetes and OpenShift. OpenShift brings [Source-to-Image](https://oreil.ly/4z2Zn)
    on top of Kubernetes, a mechanism to automatically compile a container image from
    source code. In this way the build is made on Kubernetes, so developers can test
    and deploy their apps directly on the target platform.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: JKube 支持 Kubernetes 和 OpenShift。OpenShift 在 Kubernetes 之上提供 [Source-to-Image](https://oreil.ly/4z2Zn)
    ，这是一种从源代码自动编译容器镜像的机制。这样一来，构建就在 Kubernetes 上进行，因此开发人员可以直接在目标平台上测试和部署他们的应用。
- en: As with Jib, JKube provides Zero Configuration mode for a quick ramp-up where
    opinionated defaults will be preselected. It provides Inline Configuration within
    the plug-in configuration using an XML syntax. Furthermore, it provides External
    Configuration templates of real deployment descriptors, which are enriched by
    the plug-in.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Jib 一样，JKube 提供了零配置模式，用于快速上手，其中会预先选择有见地的默认值。它提供内联配置，在插件配置中使用 XML 语法。此外，它提供了真实部署描述符的外部配置模板，这些模板会由插件增强。
- en: 'JKube is offered in three forms:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: JKube 提供三种形式：
- en: Kubernetes Plug-in
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 插件
- en: It works in any Kubernetes cluster, providing either distroless or Dockerfile-driven
    builds.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在任何 Kubernetes 集群中使用，提供 distroless 或 Dockerfile 驱动的构建。
- en: OpenShift Plug-in
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 插件
- en: It works in any Kubernetes or OpenShift cluster, providing either distroless,
    Dockerfile-driven builds, or Source-to-Image (S2I) builds.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在任何 Kubernetes 或 OpenShift 集群中使用，提供 distroless、Dockerfile 驱动的构建，或者 Source-to-Image
    (S2I) 构建。
- en: JKube Kit
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: JKube 工具包
- en: A toolkit and a CLI to interact with JKube Core, it also acts as a Kubernetes
    Client and provides an Enricher API to extend Kubernetes manifests.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与 JKube Core 交互的工具包和命令行工具，它也作为一个 Kubernetes 客户端，并提供了一个扩展 Kubernetes manifests
    的 Enricher API。
- en: JKube offers more functionality than Jib; in fact, it can be considered a superset.
    You can do distroless Jib builds, but you can also work with Dockerfile and deploy
    Kubernetes manifests from Java. In this case, we don’t need to write a Deployment
    or Service; JKube will take care of building the container and deploy it to Kubernetes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JKube 提供了比 Jib 更多的功能；事实上，它可以被视为一个超集。你可以进行 distroless Jib 构建，但也可以使用 Dockerfile
    并从 Java 部署 Kubernetes manifests。在这种情况下，我们不需要编写 Deployment 或 Service；JKube 将负责构建容器并将其部署到
    Kubernetes。
- en: Let’s include JKube in our Catalog POM file and configure it to do a Jib build
    and a deploy to Kubernetes. Doing so will make the plug-in persistent. You can
    also find the source code in this [book’s GitHub repository](https://oreil.ly/Ba4Ro).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的目录 POM 文件中包含 JKube，并配置它进行 Jib 构建和部署到 Kubernetes。这样做将使插件持久化。你也可以在这本[书的
    GitHub 存储库](https://oreil.ly/Ba4Ro)中找到源代码。
- en: 'First, we need to add JKube as a plug-in:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 JKube 添加为插件：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, you can drive the container image build with properties. In this
    case, you may want to use Jib for building the image and pushing it to Docker
    Hub. Afterward, you will deploy it to Kubernetes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以使用属性驱动容器镜像构建。在这种情况下，你可能想要使用 Jib 来构建镜像并将其推送到 Docker Hub。然后，你将部署到 Kubernetes：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s build the image:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建镜像：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get output similar to:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的输出：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'JKube using Jib created the container image locally, and it is now ready to
    be pushed to Docker Hub. You can specify credentials in one of three ways:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JKube 使用 Jib 在本地创建了容器镜像，现在已准备好推送到 Docker Hub。你可以通过以下三种方式之一指定凭据：
- en: Docker login
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 登录
- en: You can log in to your registry, in this case Docker Hub, and JKube will read
    the *~/.docker/config.json* file to get authentication details.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以登录到你的注册表，这里是 Docker Hub，JKube 将读取 *~/.docker/config.json* 文件以获取认证详细信息。
- en: Provide credentials inside POM
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POM 中提供凭据
- en: Provide registry credentials as part of XML configuration.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将注册表凭据作为 XML 配置的一部分提供。
- en: Provide credentials inside Maven Settings
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 设置中提供凭据
- en: You can provide registry credentials in your *~/.m2/settings.xml* file and the
    plug-in will read it from there.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的 *~/.m2/settings.xml* 文件中提供注册表凭据，插件将从中读取。
- en: 'In this case, you use the third option and set up credentials into Maven Settings,
    so you can copy this file using your credentials. You can also find the source
    code in this [book’s GitHub repository](https://oreil.ly/uxAxW):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你使用第三个选项，并将凭据设置到 Maven 设置中，这样你就可以使用你的凭据复制这个文件。你也可以在这本[书的 GitHub 存储库](https://oreil.ly/uxAxW)中找到源代码：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To push it to Docker Hub, you just run this Maven goal:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其推送到 Docker Hub，只需运行此 Maven 目标：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should see output similar to:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now it’s time to deploy the Catalog on Kubernetes. JKube will connect to your
    Kubernetes cluster reading the `~/.kube/config` file on your workstation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在 Kubernetes 上部署目录了。JKube 将连接到你的 Kubernetes 集群，读取你工作站上的 `~/.kube/config`
    文件：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should get output similar to:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的输出：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The app has been deployed successfully to Kubernetes, using generated manifests:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已成功部署到 Kubernetes，使用生成的清单：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To test it, let’s have a look at the Service:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，让我们看一下 Service：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: By default, Kubernetes exposes the application only internally to the cluster,
    using `ClusterIP` Service type. You can expose it externally using a Service type
    `NodePort` or using an Ingress. In this example, you will use `kubectl port-forward`
    to map the Kubernetes exposed port to our workstation’s port.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 仅在集群内部公开应用程序，使用 `ClusterIP` 服务类型。你可以使用 `Service` 类型 `NodePort`
    或使用 Ingress 在外部公开它。在这个例子中，你将使用 `kubectl port-forward` 将 Kubernetes 公开的端口映射到我们工作站的端口。
- en: 'Let’s try our app using the `kubectl port-forward` command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubectl port-forward` 命令尝试我们的应用程序：
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you open your browser now at [*http://localhost:8080/api/catalog*](http://localhost:8080/api/catalog),
    you will see the Coolstore’s Catalog JSON output.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在浏览器中打开 [*http://localhost:8080/api/catalog*](http://localhost:8080/api/catalog)，你将看到
    Coolstore 的目录 JSON 输出。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how Java developers can benefit from Kubernetes
    capabilities to modernize and enhance their apps, showing a developer’s inner
    loop with Kubernetes environments. We have demonstrated how to create container
    images and how to deploy them to Kubernetes. We also walked through steps to drive
    container creation and deploy directly from Java with Maven thanks to Jib and
    JKube.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Java 开发人员如何从 Kubernetes 的能力中受益，以使其应用程序现代化并增强其功能，展示了开发人员在 Kubernetes
    环境中的内部循环。我们演示了如何创建容器镜像以及如何将其部署到 Kubernetes。我们还介绍了如何通过 Maven 直接从 Java 驱动容器创建和部署，感谢
    Jib 和 JKube 的支持。
- en: Modernization is important for developers in order to make apps cloud native
    and portable, ready for serving highly available productions and services. In
    the next chapter, we will look deeper into the modernization of existing Java
    applications and what steps are needed to achieve it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化对于开发人员非常重要，以使应用程序云原生且可移植，为提供高可用性的生产和服务做好准备。在下一章中，我们将更深入地研究现有 Java 应用程序的现代化以及实现它所需的步骤。
