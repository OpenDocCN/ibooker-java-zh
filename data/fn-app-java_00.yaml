- en: Preface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序言
- en: A mind that is stretched by a new experience can never go back to its old dimensions.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个通过新经验扩展的思想，永远无法回到它的旧维度。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oliver Wendell Holmes Jr.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 奥利弗·温德尔·霍尔姆斯 Jr.
- en: Developing software is quite a complex endeavor. As Java developers, we usually
    try to tame this complexity with object-oriented programming (OOP) as a metaphor
    to represent the things we are developing, such as data structures, and use a
    primarily imperative-focused coding style to handle our program’s state. Although
    OOP is a well-known and battle-tested approach to developing sensible software,
    not every problem is a good match for it. We might introduce a certain amount
    of unnecessary complexity by forcing OOP principles on every problem instead of
    using more appropriate tools and paradigms also available to us. The functional
    programming (FP) paradigm offers an alternative approach to solving problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件是一个相当复杂的工作。作为Java开发者，我们通常试图用面向对象编程（OOP）来驾驭这种复杂性，将其作为一种比喻来表示我们正在开发的事物，比如数据结构，并且使用主要以命令式为主的编码风格来处理程序的状态。虽然OOP是一种广为人知且经过实战验证的开发合理软件的方法，但并不是每个问题都适合它。如果我们在每个问题上都强行采用OOP原则，而不是使用更适当的工具和范式，可能会引入一定量不必要的复杂性。函数式编程（FP）范式提供了解决问题的另一种替代方法。
- en: Functional programming isn’t a new idea. In fact, it’s even older than object-oriented
    programming! It first appeared in the early years of computing, in the 1950s,
    in the *Lisp*⁠^([1](preface01.xhtml#idm45115267496480)) programming language and
    has been used quite commonly in academia and niche fields. In recent years, however,
    there has been an increasing interest in functional paradigms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不是一个新概念。事实上，它甚至比面向对象编程还要古老！它最早出现在计算机发展的早期，1950年代，最早在*Lisp*⁠^([1](preface01.xhtml#idm45115267496480))编程语言中出现，并且在学术界和小众领域中被广泛使用。然而，近年来，函数式范式越来越受到关注。
- en: Many new functional languages emerged, and non-functional languages are including
    functional features to various degrees. The ideas and concepts behind FP are now
    adopted in almost every mainstream multi-paradigm and general-purpose language,
    allowing us to use some form of functional programming regardless of the context
    and chosen language. Nothing stops us from taking the best parts of FP and augmenting
    our existing way of programming and software development tools — and that’s what
    this book is about!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新的函数式语言出现了，非函数式语言也在各种程度上包含函数式特性。FP背后的思想和概念现在几乎在每一种主流多范式和通用编程语言中被采纳，无论上下文和选择的语言如何，都允许我们使用某种形式的函数式编程。没有什么能阻止我们从函数式编程中摘取最好的部分，并增强我们现有的编程方式和软件开发工具，这也是本书的主旨！
- en: In this book, you’ll learn the fundamentals of functional programming and how
    to apply this knowledge to your daily work using Java.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习函数式编程的基础知识，并学习如何将这些知识应用到日常工作中使用Java。
- en: New Hardware Needs a New Way of Thinking
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新硬件需要新的思维方式
- en: Hardware is evolving in a new direction. For quite some time, single-core performance
    improvements haven’t been as significant as with each previous processor generation.
    *Moore’s law*⁠^([2](preface01.xhtml#idm45115253372352)) seems to slow down, but
    such a slowdown doesn’t mean that hardware isn’t improving anymore. But instead
    of primarily focussing on single-core performance and even higher GHz numbers,
    the manufacturers favor more and more cores.^([3](preface01.xhtml#idm45115268991152))
    So, for modern workloads to reap all the benefits of new hardware that favors
    more cores rather than faster ones, we need to adopt techniques that can use more
    cores to its advantage without compromising productivity or introducing additional
    complexity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件正在朝着新方向发展。相当长一段时间以来，单核性能的改进不如以往的处理器世代那样显著。*摩尔定律*⁠^([2](preface01.xhtml#idm45115253372352))似乎放缓，但这种放缓并不意味着硬件停止改进。而制造商们不再主要关注单核性能甚至更高的GHz数，而是更青睐越来越多的核心数目。^([3](preface01.xhtml#idm45115268991152))因此，为了让现代工作负载能够充分利用偏向更多核心而非更快处理器的新硬件带来的所有好处，我们需要采用能够有效利用更多核心的技术，而不会降低生产力或引入额外复杂性。
- en: Scaling your software *horizontally* through parallelism isn’t an easy task
    in OOP. Not every problem is a good fit for parallelism. More painters might paint
    a room faster, but you can’t speed up pregnancy by involving more people. If the
    problem consists of serial or interdependent tasks, concurrency is preferable
    to parallelism. But parallelism really shines if a problem breaks down into smaller,
    non-related sub-problems. That’s where functional programming comes in. The stateless
    and immutable nature of idiomatic FP provides all the tools necessary to build
    small, reliable, reusable, and higher-quality tasks that elegantly fit into parallel
    and concurrent environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 横向扩展你的软件通过并行处理在面向对象编程中并不是一项容易的任务。并非所有问题都适合并行处理。更多的画家可能会更快地涂完一个房间，但是你不能通过让更多的人参与来加快怀孕的速度。如果问题由串行或相互依赖的任务组成，那么并发比并行更可取。但是，如果一个问题可以分解为更小、不相关的子问题，那么并行处理就会大放异彩。这正是函数式编程发挥作用的地方。惯用的函数式编程的无状态和不可变性质提供了构建小型、可靠、可重复使用和高质量任务所需的所有工具，这些任务优雅地适应并行和并发环境。
- en: Adopting a functional mindset adds another set of tools to your toolbelt that
    will allow you to tackle your daily development problems in a new way and scale
    your code easier and safer than before.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 采用函数式思维方式为你的工具箱增加了另一组工具，使你能够以一种新的方式解决日常开发中的问题，并比以往更轻松、更安全地扩展你的代码。
- en: Next, let’s look at why Java can be a good choice for functional programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Java为什么可以成为函数式编程的好选择。
- en: Java can be Functional, too
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java也可以是函数式的
- en: There are many programming languages out there that are great for functional
    programming. [*Haskell*](https://www.haskell.org) is a favorite if you prefer
    a *pure* functional language with almost no support for an imperative coding style.
    [*Elixir*](https://elixir-lang.org/) is another exciting option that leverages
    the [*Erlang VM*](https://www.erlang.org/)^([4](preface01.xhtml#idm45115261275136)).
    However, you don’t have to leave the vast JVM ecosystem behind to find FP-capable
    languages. [*Scala*](https://www.scala-lang.org/) shines in combining OOP and
    FP paradigms into a concise, high-level language. Another popular choice, [*Clojure*](https://clojure.org/),
    was designed from the ground up as a functional language with a dynamic type system
    at heart.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编程语言非常适合函数式编程。[*Haskell*](https://www.haskell.org) 是一个喜欢的选择，如果你喜欢几乎不支持命令式编程风格的纯函数式语言。[*Elixir*](https://elixir-lang.org/)
    是另一个令人兴奋的选择，它利用了[*Erlang VM*](https://www.erlang.org/)^([4](preface01.xhtml#idm45115261275136))。然而，你并不需要抛弃广阔的JVM生态系统来找到支持函数式编程的语言。[*Scala*](https://www.scala-lang.org/)
    在将面向对象和函数式编程范式结合成一种简洁、高级别语言方面表现出色。另一个受欢迎的选择，[*Clojure*](https://clojure.org/)，从一开始就被设计为具有动态类型系统的函数式语言。
- en: In a perfect world, you’d have the luxury of choosing the perfect functional
    language for your next project. In reality, you might not have a choice at all
    about what language to use, and you’ll have to play the cards you’re dealt.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，你可以选择对下一个项目最适合的函数式语言。然而，在现实中，你可能根本没有选择语言的余地，你必须使用手头现有的工具。
- en: As a Java developer, you’d use Java, which was historically seen as not ideal
    for functional programming. Before we continue, though, I need to stress that
    you can implement most functional principles in Java, regardless of deeply integrated
    language level support^([5](preface01.xhtml#idm45115272990288)). Still, the resulting
    code won’t be as concise and easy to reason with as it would in other languages
    that allow a functional approach in the first place. This caveat scares many developers
    away from even trying to apply functional principles to Java, despite the fact
    that it might have provided a more productive approach or better overall solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，你可以使用Java，尽管它在历史上被认为不太适合函数式编程。在我们继续之前，我需要强调的是，你可以在Java中实现大多数函数式原则，而不论语言级别是否深度集成支持^([5](preface01.xhtml#idm45115272990288))。然而，最终的代码不会像在允许在首次使用函数式方法的其他语言中那样简洁且易于推理。这一限制使许多开发者不敢尝试将函数式原则应用于Java，尽管这可能会提供更高效的方法或更好的整体解决方案。
- en: 'In the past, many people thought of Java as a slow-moving behemoth, a “too
    big to become extinct” enterprise language, like a more modern version of COBOL
    or [Fortran](https://fortran-lang.org/). And in my opinion, that’s partially true,
    at least in the past. The pace didn’t pick up until Java 9 and the shortened release
    timeframes^([6](preface01.xhtml#idm45115273019824)). It took Java five years to
    go from version 6 to 7 (2006-2011). And even though there were significant new
    features, like [`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml),
    none of them were “ground-breaking.” The few and slow changes in the past led
    to projects and developers not adopting the “latest and greatest” Java Development
    Kit (JDK) and missing out on many language improvements. Three years later, in
    2014, the next version, Java 8, was released. This time, it introduced one of
    the most significant changes to Java’s future: *lambda expressions*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，许多人认为Java是一个行动缓慢的庞然大物，一种“太大以至于无法灭绝”的企业语言，就像COBOL或[Fortran](https://fortran-lang.org/)的更现代版本一样。在我看来，至少在过去是部分正确的。直到Java
    9和缩短的发布时间框架^([6](preface01.xhtml#idm45115273019824))才加快了步伐。Java从版本6到7花了五年的时间（2006-2011）。即使有显著的新特性，比如[`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml)，但都不是“突破性”的。过去的少量且缓慢的变化导致项目和开发者未采用“最新最好”的Java开发工具包（JDK），错失了许多语言改进。三年后的2014年，下一个版本Java
    8发布了。这一次，它引入了Java未来最重要的变化之一：*lambda表达式*。
- en: 'A better foundation for functional programming had finally arrived in arguably
    the most prominent object-oriented programming language of the world, changing
    the language and its idioms significantly:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于世界上最显著的面向对象编程语言之一，函数式编程终于提供了一个更好的基础，显著改变了语言及其习语：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The addition of lambda expressions was monumental in making it possible to finally
    use functional programming in Java as an integrated language and runtime feature.
    Not only that, but a whole new world of ideas and concepts was made available
    to Java developers. Many of the JDK’s new features, like Streams, the `Optional`
    type, or `CompletableFuture`, are only possible in such a concise and straightforward
    way thanks to language-level lambda expressions and Java’s other functional additions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在Java中的整合语言和运行时特性上引入了**lambda表达式**，这是一个里程碑式的改进，使得最终能够在Java中使用函数式编程成为可能。不仅如此，Java开发者们也因此获得了一个全新的思想和概念世界。像Streams、`Optional`类型或`CompletableFuture`等JDK的许多新特性，都得益于语言级别的lambda表达式和Java的其他函数式增强。
- en: These new idioms and new ways of doing things with FP in Java may seem strange
    and might not come naturally, especially if you’re primarily accustomed to OOP.
    Throughout this book, I’ll show you how to develop a mindset that’ll help you
    apply FP principles to your code and how to make it better without needing to
    go “fully functional.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中使用FP的这些新习惯和新方式可能看起来很奇怪，特别是如果你主要习惯于面向对象编程。在本书中，我将向你展示如何培养一种思维模式，帮助你将FP原则应用于你的代码，并使其变得更好，而无需完全转向函数式编程。
- en: Why I Wrote This Book
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么写这本书
- en: 'After using another multi-purpose language with excellent functional programming
    support — [*Swift*](https://www.swift.org/) — and seeing the benefits first-hand,
    I gradually introduced more and more functional principles in my Java-based projects,
    too. Thanks to lambda expressions and all the other features introduced in Java
    8 and later, all the tools necessary were readily available. But after using these
    tools more frequently and discussing them with my colleagues, I realized something:
    *How* to use lambdas, Streams, and all the other functional goodies provided by
    Java is easy to grasp. But without a deeper understanding of *why* and *when*
    you should use them — and when not to — you won’t unlock their full potential,
    and it will just be “new wine in old wineskins.”'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用另一种多用途语言[*Swift*](https://www.swift.org/)并亲身体验其优势之后，我逐渐在基于Java的项目中引入了更多的函数式原则。多亏了Java
    8及以后版本引入的lambda表达式和所有其他特性，所有必要的工具都随时可用。但在更频繁地使用这些工具并与同事讨论后，我意识到一点：学会如何使用lambda表达式、Streams和Java提供的所有其他函数式好处是容易理解的。但如果不深入了解何时以及为何使用它们，以及何时不使用，就无法充分发挥它们的潜力，它们只会是“新酒装旧皮囊”。
- en: So I decided to write this book to highlight the different concepts that make
    a language *functional*, and how you can incorporate them into your Java code,
    either with the tools provided by the JDK or by creating them yourself. A functional
    approach to your Java code will most likely challenge the status quo and go against
    *best practices* you were using before. But by embracing a more functional way
    of doing things, like *immutability* and *pure functions*, you will be able to
    write more concise, more reasonable, and future-proof code that is less prone
    to bugs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我决定写这本书来突出显示构成语言*功能性*的不同概念，以及如何将它们与你的Java代码结合起来，无论是使用JDK提供的工具还是自己创建。功能性地处理你的Java代码很可能会挑战现状，并违背你以前使用的*最佳实践*。但是，通过接受更功能性的做事方式，比如*不可变性*和*纯函数*，你将能够编写更简洁、更合理和更具未来性的代码，减少错误的可能性。
- en: Who Should Read This Book
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁应该读这本书
- en: This book is for you if you are curious about functional programming and want
    to know what all the fuss is about and apply it to your Java code. You might already
    be using some functional Java types but desire a more profound knowledge of why
    and how to apply them more effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对功能性编程感兴趣，并想知道这一切是怎么回事，并将其应用到你的Java代码中，那么这本书适合你。你可能已经在使用一些功能性Java类型，但希望更深入地了解为什么以及如何更有效地应用它们。
- en: There is no need to be an expert on OOP, but the book is not a beginner’s guide
    to Java or OOP. You should already be familiar with the Java standard library.
    No prior knowledge of functional programming is required. Every concept is introduced
    with an explanation and examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需成为面向对象编程(OOP)的专家，但这本书也不是Java或OOP的初学者指南。你应该已经熟悉Java标准库。不需要先前的功能性编程知识。每个概念都会有解释和示例介绍。
- en: The book covers Java 17 as the latest Long-Term-Support (LTS) version available
    at publication. Knowing that many developers need to support projects with earlier
    versions, the general baseline will be the previous LTS, Java 11. But even if
    you’re stuck on Java 8, many of the discussed topics are relevant, too. Although,
    some chapters will rely on newer features, like *Records*, which were introduced
    in Java 14.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖的Java 17是最新的长期支持(LTS)版本。考虑到许多开发人员需要支持较早版本的项目，一般基准线将是上一个LTS版本Java 11。但即使你被困在Java
    8上，讨论的许多主题也是相关的。尽管如此，一些章节将依赖于较新的功能，比如在Java 14中引入的*Records*。
- en: This book might not be for you if you are looking for a compartmentalized, recipe-style
    book presenting “ready-to-implement” solutions. Its main intention is to introduce
    functional concepts and idioms and teach you how to incorporate them into your
    Java code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个分隔式、食谱风格的“即用即实施”解决方案的书籍，那么这本书可能不适合你。它的主要目的是介绍功能性概念和习语，并教你如何将它们融入到你的Java代码中。
- en: What You Will Learn
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你将学到什么
- en: By the end of this book, you will have a fundamental knowledge of functional
    programming and its underlying concepts and how to apply this knowledge to your
    daily work. Every Java functional type will be at your disposal, and you will
    be able to build anything missing from the JDK by yourself, if necessary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书结束时，你将对功能性编程及其基础概念有基础的了解，并学会如何将这些知识应用到日常工作中。每种Java功能性类型都将为你所用，必要时你也能够自己构建JDK中缺少的部分。
- en: 'You will learn about the concepts and importance of:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解以下概念及其重要性：
- en: '*Composition*: Build modular and easy composable blocks.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合*：构建模块化和易于组合的块。'
- en: '*Expressiveness*: Write more concise code that clearly expresses its intent.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表达力*：编写更简洁的代码，清晰表达其意图。'
- en: '*Safer code*: Safer data structures without side effects that don’t need to
    deal with race conditions or locks, which are hard to use without introducing
    bugs.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更安全的代码*：更安全的数据结构，无副作用，无需处理竞态条件或锁，这些很难使用而不引入错误。'
- en: '*Modularity*: Break down larger projects into more easily manageable modules.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化*：将较大的项目拆分为更易于管理的模块。'
- en: '*Maintainability*: Smaller functional blocks with less interconnection make
    changes and refactoring safer without breaking other parts of your code.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*：较小的功能块，少互连，使得更改和重构更安全，不会破坏代码的其他部分。'
- en: '*Data manipulation*: Build efficient data manipulation pipelines with less
    complexity.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据操作*：构建高效的数据操作流水线，减少复杂性。'
- en: '*Performance*: Immutability and predictability allow scaling horizontally with
    parallelism without much thought about it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*：不可变性和可预测性允许在水平方向上通过并行扩展，几乎不需要考虑。'
- en: Even without going *fully functional*, your code will benefit from the concepts
    and idioms presented in this book. And not only your Java code. You will tackle
    development challenges with a functional mindset, improving your programming regardless
    of the used language or paradigm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有完全采用*全功能*的方式，你的代码也会受益于本书中提出的概念和习语。而且不仅仅是你的 Java 代码。你将以功能思维解决开发挑战，无论使用的语言或范式如何，都能提升你的编程能力。
- en: What About Android?
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 是怎么样的？
- en: It’s hard to talk about Java without bringing up Android as well. Even though
    you can write Android applications in Java, the underlying API and runtime aren’t
    the same. So, what does this mean for adopting a functional approach to Java for
    Android apps? To better understand that, we first need to look at what makes Java
    for Android different from “normal” Java.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提到 Android 就很难谈论 Java。即使你可以用 Java 编写 Android 应用程序，底层的 API 和运行时也不同。那么，对于在 Android
    应用程序中采用功能方法编写 Java，这意味着什么呢？为了更好地理解这一点，我们首先需要看看是什么使得 Android 上的 Java 与“正常”的 Java
    不同。
- en: 'Android doesn’t run Java bytecode directly on a minimalistic JVM optimized
    for smaller devices, like [Java Platform Micro Edition](https://www.oracle.com/java/technologies/javameoverview.xhtml).
    Instead, the bytecode gets recompiled. The *Dex-compiler* creates *Dalvik bytecode*,
    which is then run on a specialized runtime: the *Android Runtime* (ART), and previously
    on the *Dalvik virtual machine*⁠^([7](preface01.xhtml#idm45115254361520)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Android 并不直接在面向较小设备的*Java 平台微版*（[Java 平台微版概述](https://www.oracle.com/java/technologies/javameoverview.xhtml)）上运行
    Java 字节码。而是对字节码进行重新编译。*Dex-编译器*创建*Dalvik 字节码*，然后在专门的运行时上运行：*Android 运行时*（ART），之前是在
    *Dalvik 虚拟机*⁠^([7](preface01.xhtml#idm45115254361520))。
- en: Recompiling Java bytecode to *Dalvik bytecode* allows the devices to run highly
    optimized code, getting the most out of their hardware constraints. For you as
    a developer, however, that means that even though your code looks and feels like
    Java on the surface — most of the public API is identical --⁠, there isn’t a feature
    parity between the JDK and Android SDK you can rely on. For example, the cornerstones
    of this book — *lambda expressions* and *Streams* — were among the missing features
    in Android for a long time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 字节码重新编译为*Dalvik 字节码*使设备能够运行高度优化的代码，充分利用其硬件限制。然而对于开发者来说，尽管你的代码在表面上看起来和感觉像
    Java —— 大部分公共 API 是相同的 --⁠，JDK 和 Android SDK 之间并没有功能对等性可依赖。例如，本书的基石 —— *lambda
    表达式* 和 *Streams* —— 在 Android 上长时间缺失了这些特性。
- en: 'The Android Gradle plugin started supporting some of the missing functional
    features (lambda expressions, method references, default and static interface
    methods) with version 3.0.0 by using so-called *desugaring*: the compiler uses
    bytecode transformations to replicate a feature *behind the scenes* without supporting
    the new syntax or providing an implementation in the runtime itself. The next
    major version, 4.0.0, added even more functional features: Streams, Optionals,
    and the `java.util.function` package. That allows you to benefit from the functional
    paradigms and tools discussed in this book, even as an Android developer.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Android Gradle 插件从 3.0.0 版本开始支持一些缺失的功能特性（lambda 表达式、方法引用、默认和静态接口方法），通过所谓的*解糖*使用字节码转换来复制特性*在幕后*，而不支持新语法或在运行时本身提供实现。下一个主要版本
    4.0.0，增加了更多的功能特性：Streams、Optionals 和 `java.util.function` 包。这使得你作为 Android 开发者能够受益于本书讨论的功能范式和工具。
- en: Warning
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Even though most of the JDK’s functional features are available on Android too,
    they are not verbatim copies^([8](preface01.xhtml#idm45115253306592)) and might
    have different performance characteristics and edge-cases. The available features
    are listed in the [official documentation on the Java 8+ support](https://developer.android.com/studio/write/java8-support).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数 JDK 的功能特性在 Android 上也是可用的，它们并不是逐字复制^([8](preface01.xhtml#idm45115253306592))，可能具有不同的性能特征和边缘情况。可用功能列在[Java
    8+ 支持的官方文档](https://developer.android.com/studio/write/java8-support)中。
- en: A Functional Approach to Android
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种面向 Android 的功能方法
- en: 'In 2019, [Kotlin](https://kotlinlang.org) replaced Java as the preferred language
    for Android developers. It’s a multi-platform language that mainly targets the
    JVM but also compiles to JavaScript and multiple native platforms, too^([9](preface01.xhtml#idm45115253702896)).
    It aims to be a “modern and more concise” Java, fixing many of Java’s debatable
    shortcomings and cruft accumulated over the years due to backward compatibility,
    without forgoing all the frameworks and libraries available to Java. And it’s
    100% interoperable: you can easily mix Java and Kotlin in the same project.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年，[Kotlin](https://kotlinlang.org)取代Java成为Android开发者首选的语言。它是一种多平台语言，主要面向JVM，但也可以编译为JavaScript和多个本地平台。它旨在成为一个“现代和更简洁”的Java，修复了Java多年来由于向后兼容性而积累的一些争议性缺陷和不必要的复杂性，同时保留了Java可用的所有框架和库。并且它是100%可互操作的：你可以轻松地在同一个项目中混合使用Java和Kotlin。
- en: One obvious advantage of Kotlin over Java is that many functional concepts and
    idioms are integral to the language itself. Still, as a different language, Kotlin
    has its own idioms and best practices that differ from Java’s. The generated bytecode
    might differ, too, like how to generate lambdas^([10](preface01.xhtml#idm45115253442784)).
    The most significant advantage of Kotlin is its attempt to create a more concise
    and predictable language compared to Java. And just like you can be more functional
    in Java without going *fully functional*, you can use Kotlin-only features without
    going *full Kotlin* in your Android projects, too. By mixing Java and Kotlin,
    you can pick the best features from both languages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin相对于Java的一个明显优势是，许多函数概念和习语已经融入到语言本身。但作为一种不同的语言，Kotlin有其自己的习惯用法和最佳实践，这些与Java的不同。生成的字节码也可能不同，例如如何生成lambda表达式^([10](preface01.xhtml#idm45115253442784))。Kotlin最显著的优势是试图创建一个比Java更简洁和可预测的语言。就像你可以在Java中更加函数式而不是*完全函数式*一样，你也可以在Android项目中仅使用Kotlin特有的功能，而不必*全面使用*
    Kotlin。通过混合Java和Kotlin，你可以从两种语言中选择最佳的功能。
- en: Keep in mind that this book’s primary focus is the Java language and the JDK.
    Still, most of the ideas behind what you will learn are transferrable to Android,
    even if you use Kotlin. But there won’t be any special considerations for Android
    or Kotlin throughout the book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本书的主要焦点是Java语言和JDK。尽管如此，你所学到的大部分思想都可以转移到Android上，即使你使用Kotlin。但本书中没有专门考虑Android或Kotlin的特别情况。
- en: Navigating This Book
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览本书
- en: 'This book consists of two different parts:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包括两个不同的部分：
- en: '[Part I](part01.xhtml#_01-part-1), *Functional Basics*, introduces the history
    and core concepts of functional programming, how Java implements these concepts,
    and what types are already available to us as developers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一部分](part01.xhtml#_01-part-1)，*功能基础*，介绍了函数式编程的历史和核心概念，Java如何实现这些概念以及作为开发人员已经可用的各种类型。'
- en: '[Part II](part02.xhtml#_02-part-2), *A Functional Approach*, is a topic-based
    deep-dive through the more generalized programming concepts and how to augment
    them with functional principles and the newly available tools. Certain features,
    like *Records* and *Streams*, are highlighted with extended examples and use cases.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二部分](part02.xhtml#_02-part-2)，*功能方法*，是一个基于主题的深入探讨，涵盖了更广义的编程概念以及如何通过函数式原则和新提供的工具来增强它们。某些特性，如*Records*和*Streams*，通过扩展示例和用例进行了突出。'
- en: Reading the chapters in their respective order will let you get the most out
    of them because they usually build on each other. But feel free to skim for the
    bits that might interest you and jump around. Any necessary connections are cross-referenced
    to fill in any blanks if needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照各章节的顺序阅读将能让你最大程度地从中受益，因为它们通常是相互构建的。但是随时可以略读可能感兴趣的部分，并随意跳跃。如有需要，任何必要的联系都会进行交叉引用，以填补任何空白。
- en: Conventions Used in This Book
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书使用的约定
- en: 'The following typographical conventions are used in this book:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用以下排版约定：
- en: '*Italic*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜体*'
- en: Indicates new terms, URLs, email addresses, filenames, and file extensions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 指示新术语、URL、电子邮件地址、文件名和文件扩展名。
- en: '`Constant width`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`常量宽度`'
- en: Used for program listings, as well as within paragraphs, to refer to program
    elements such as variable or function names, databases, data types, environment
    variables, statements, and keywords.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用于程序清单以及段落内，用于引用诸如变量或函数名称、数据库、数据类型、环境变量、语句和关键字等程序元素。
- en: '**`Constant width bold`**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`常量宽度粗体`**'
- en: Shows commands or other text that should be typed literally by the user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显示用户应该按照字面意义输入的命令或其他文本。
- en: '*`Constant width italic`*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*`常量宽度斜体`*'
- en: Shows text that should be replaced with user-supplied values or by values determined
    by context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 显示应替换为用户提供的值或根据上下文确定的值的文本。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This element signifies a tip or suggestion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素表示提示或建议。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This element signifies a general note.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素表示一般性的备注。
- en: Warning
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This element indicates a warning or caution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素指示警告或注意事项。
- en: Using Code Examples
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码示例
- en: 'The source code for the book is available on GitHub: [*https://github.com/benweidig/a-functional-approach-to-java*](https://github.com/benweidig/a-functional-approach-to-java).
    Besides compilable Java code, there are also *JShell* scripts available to run
    the code more easily. See the [README.md](https://github.com/benweidig/a-functional-approach-to-java/README.md)
    for instructions on how to use them.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的源代码在GitHub上可用：[*https://github.com/benweidig/a-functional-approach-to-java*](https://github.com/benweidig/a-functional-approach-to-java)。除了可编译的Java代码外，还有*JShell*脚本可用于更轻松地运行代码。请查看[README.md](https://github.com/benweidig/a-functional-approach-to-java/README.md)以获取有关如何使用它们的说明。
- en: If you have a technical question or a problem using the code examples, please
    send email to [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有技术问题或在使用代码示例时遇到问题，请发送电子邮件至[*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com)。
- en: This book is here to help you get your job done. In general, if example code
    is offered with this book, you may use it in your programs and documentation.
    You do not need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several chunks of
    code from this book does not require permission. Selling or distributing examples
    from O’Reilly books does require permission. Answering a question by citing this
    book and quoting example code does not require permission. Incorporating a significant
    amount of example code from this book into your product’s documentation does require
    permission.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在帮助您完成工作。一般来说，如果本书提供了示例代码，您可以在您的程序和文档中使用它。除非您复制了代码的大部分，否则无需征得我们的许可。例如，编写一个使用本书多个代码片段的程序不需要许可。销售或分发O’Reilly书籍中的示例代码需要许可。引用本书并引用示例代码来回答问题不需要许可。将本书大量示例代码整合到产品文档中需要许可。
- en: 'We appreciate, but generally do not require, attribution. An attribution usually
    includes the title, author, publisher, and ISBN. For example: “*A Functional Approach
    to Java* by Ben Weidig (O’Reilly). Copyright 2023 Ben Weidig, 978-1-098-10992-9.”'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感谢但通常不要求署名。署名通常包括标题、作者、出版商和ISBN。例如：“*Java函数式方法* 由本·韦迪格（O’Reilly）著作权2023 Ben
    Weidig，978-1-098-10992-9。”
- en: If you feel your use of code examples falls outside fair use or the permission
    given above, feel free to contact us at [*permissions@oreilly.com*](mailto:permissions@oreilly.com).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得您使用的代码示例超出了公平使用范围或以上给出的许可，请随时通过[*permissions@oreilly.com*](mailto:permissions@oreilly.com)与我们联系。
- en: O’Reilly Online Learning
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O’Reilly Online Learning
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For more than 40 years, [*O’Reilly Media*](https://oreilly.com) has provided
    technology and business training, knowledge, and insight to help companies succeed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 超过40年来，[*O’Reilly Media*](https://oreilly.com)为公司成功提供技术和商业培训、知识和见解。
- en: Our unique network of experts and innovators share their knowledge and expertise
    through books, articles, and our online learning platform. O’Reilly’s online learning
    platform gives you on-demand access to live training courses, in-depth learning
    paths, interactive coding environments, and a vast collection of text and video
    from O’Reilly and 200+ other publishers. For more information, visit [*https://oreilly.com*](https://oreilly.com).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们独特的专家和创新者网络通过书籍、文章和我们的在线学习平台分享他们的知识和专长。O’Reilly的在线学习平台为您提供按需访问实时培训课程、深度学习路径、交互式编码环境以及O’Reilly和其他200多个出版商的大量文本和视频。更多信息，请访问[*https://oreilly.com*](https://oreilly.com)。
- en: 'Please address comments and questions concerning this book to the publisher:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请向出版商发送有关本书的评论和问题：
- en: O’Reilly Media, Inc.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O’Reilly Media, Inc.
- en: 1005 Gravenstein Highway North
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1005 Gravenstein Highway North
- en: Sebastopol, CA 95472
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sebastopol, CA 95472
- en: 800-998-9938 (in the United States or Canada)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 800-998-9938（美国或加拿大）
- en: 707-829-0515 (international or local)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 707-829-0515（国际或本地）
- en: 707-829-0104 (fax)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 707-829-0104（传真）
- en: We have a web page for this book, where we list errata, examples, and any additional
    information. You can access this page at [*https://oreil.ly/functional-approach-to-java-1e*](https://oreil.ly/functional-approach-to-java-1e).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一本关于这本书的网页，在那里我们列出勘误、示例和任何其他信息。您可以访问[*https://oreil.ly/functional-approach-to-java-1e*](https://oreil.ly/functional-approach-to-java-1e)。
- en: Email [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com) to comment
    or ask technical questions about this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件至[*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com)以评论或提出有关本书的技术问题。
- en: For news and information about our books and courses, visit [*https://oreilly.com*](https://oreilly.com).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于我们的图书和课程的新闻和信息，请访问[*https://oreilly.com*](https://oreilly.com)。
- en: 'Find us on LinkedIn: [*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在LinkedIn上找到我们：[*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)
- en: 'Follow us on Twitter: [*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关注我们的Twitter：[*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)
- en: 'Watch us on YouTube: [*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 观看我们的YouTube频道：[*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)
- en: Acknowledgments
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 致谢
- en: This book is for Alexander Neumer, the best mentor I could’ve wished for in
    my early career. Without him, I wouldn’t be the developer I am today.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为Alexander Neumer准备的，他是我在职业早期最好的导师。没有他，我今天不会成为这样的开发者。
- en: I want especially like to thank Zan McQuade for her encouragement and for proposing
    to aggregate my ramblings about functional Java into a book in the first place.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别要感谢Zan McQuade，感谢她的鼓励，并首先建议将我关于Java函数式编程的碎碎念聚合成一本书。
- en: 'The technical reviewers deserve special thanks, too: Dean Wampler, Venkat Subramaniam,
    Thiago H. de Paula Figueiredo, and A.N.M. Bazlur Rahman. Their support, suggestions,
    and sometimes harsh critique throughout the different stages of the book made
    it better than I could have done it all by myself.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还要特别感谢技术审查者：Dean Wampler、Venkat Subramaniam、Thiago H. de Paula Figueiredo和A.N.M.
    Bazlur Rahman。他们在书籍不同阶段的支持、建议和有时候的严厉批评，使这本书比我独自完成要好得多。
- en: I would also like to thank Felix Gonschorek and Benjamin Quenzer, the two friends
    and colleagues that “suffered” with me from the beginning and provided invaluable
    feedback up to the end.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要感谢Felix Gonschorek和Benjamin Quenzer，这两位朋友和同事从一开始就与我“同舟共济”，并提供了宝贵的反馈，直到最后。
- en: Last but not least, I want to thank my Acquisitions Editor Brian Guerin and
    everyone at O’Reilly. My Editor Rita Fernando, who always found a way to polish
    a few rough edges and get the best out of what I wrote. Ashley Stussy, the Production
    Editor that made all my layout requests possible. Nick and Theresa from the O’Reilly
    Tools Team, who patiently helped me through any Asciidoc issues that arose. And
    all the other ones involved behind the scenes. Thank you!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我要感谢我的采购编辑Brian Guerin以及O’Reilly的所有人。我的编辑Rita Fernando总是找到办法去打磨一些粗糙的地方，并让我所写的东西发挥到极致。Ashley
    Stussy，这位制作编辑使我所有的布局请求都成为可能。O’Reilly工具团队的Nick和Theresa，他们耐心地帮助我解决了任何Asciidoc问题。还有所有在幕后参与其中的人。谢谢你们！
- en: ^([1](preface01.xhtml#idm45115267496480-marker)) Originally specified in 1958,
    *Lisp* is the second-oldest high-level programming language still in common use.
    It also builds the foundation of a variety of programming languages, like [*Emacs
    Lisp*](https://www.gnu.org/software/emacs/manual/html_node/elisp/index.xhtml),
    or the functional JVM language [*Clojure*](https://clojure.org/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](preface01.xhtml#idm45115267496480-marker)) Lisp最初于1958年规定，是仍在常用的第二古老的高级编程语言。它还构建了各种编程语言的基础，如[*Emacs
    Lisp*](https://www.gnu.org/software/emacs/manual/html_node/elisp/index.xhtml)，或功能JVM语言[*Clojure*](https://clojure.org/)。
- en: '^([2](preface01.xhtml#idm45115253372352-marker)) *Moore’s law* was coined in
    1965 as the observation of transistor counts doubling every two years and, therefore,
    the performance per core available to us. Edwards, Chris. 2021\. “Moore’s Law:
    What Comes Next?” [Communications of the ACM, February 2021, Vol. 64 No. 2, 12–14](https://doi.org/10.1145/3440992)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](preface01.xhtml#idm45115253372352-marker)) *摩尔定律*（Moore’s law）是在1965年提出的，观察到晶体管数量每两年翻倍，因此，我们可以获得每核心的性能。Edwards,
    Chris. 2021. “摩尔定律：下一步是什么？”[《ACM通讯》，2021年2月，第64卷第2期，12–14页](https://doi.org/10.1145/3440992)
- en: ^([3](preface01.xhtml#idm45115268991152-marker)) Thompson, N. C., and Svenja
    Spanuth. 2021\. “The decline of computers as a general-purpose technology.” [*Communications
    of the ACM*, Vol. 64, No. 3, 64-72](https://doi.org/10.1145/3430936).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](preface01.xhtml#idm45115268991152-marker)) Thompson, N. C. 和 Svenja Spanuth
    在 2021 年发表了“计算机作为通用技术的衰落”[*《ACM 通讯》*，Vol. 64, No. 3, 64-72](https://doi.org/10.1145/3430936)。
- en: ^([4](preface01.xhtml#idm45115261275136-marker)) [*Erlang*](https://www.erlang.org/)
    is a functional and concurrency-oriented programming language that is known for
    building low-latency, distributed, and fault-tolerant systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](preface01.xhtml#idm45115261275136-marker)) [*Erlang*](https://www.erlang.org/)是一种功能丰富且面向并发的编程语言，以构建低延迟、分布式和容错系统而闻名。
- en: ^([5](preface01.xhtml#idm45115272990288-marker)) Dean Wampler shows in his book
    [“Functional Programming for Java Developers”](http://oreilly.com/catalog/9781449311032/)
    quite detailed how to implement and facilitate the missing functional programming
    features in Java all by yourself. He showed many techniques that weren’t easily
    feasible before version 8\. But now, many of the shortcomings and gaps in the
    JDK are closed up, and it provides many of the tools necessary to incorporate
    FP concisely and more straightforwardly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](preface01.xhtml#idm45115272990288-marker)) Dean Wampler 在他的书籍[“Java 开发者的函数式编程”](http://oreilly.com/catalog/9781449311032/)中详细展示了如何在
    Java 中实现和促进缺失的函数式编程特性。他展示了在版本 8 之前很难实现的许多技术。但现在，JDK 中的许多缺陷和间隙都已被填补，提供了许多工具，可以更简洁、更直接地整合
    FP。
- en: ^([6](preface01.xhtml#idm45115273019824-marker)) Oracle introduced a faster
    [release schedule](https://www.oracle.com/java/technologies/java-se-support-roadmap.xhtml)
    for Java with the release of version 9\. Instead of releasing infrequently, there’s
    now a fixed release cadence of six months. To meet such a tight schedule, not
    every release is considered “long-term-support”, in favor of releasing features
    faster than before.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](preface01.xhtml#idm45115273019824-marker)) Oracle 在 Java 9 版本发布时推出了更快的[发布计划](https://www.oracle.com/java/technologies/java-se-support-roadmap.xhtml)，不再像以前那样发布频率较低，而是固定为每六个月发布一次。为了符合如此紧张的时间表，并非每个版本都被视为“长期支持”，而是更倾向于比以往更快地发布功能。
- en: ^([7](preface01.xhtml#idm45115254361520-marker)) The Android Open Source project
    provides [a good overview](https://source.android.com/devices/tech/dalvik) of
    the features and the reasoning behind Android’s runtime.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](preface01.xhtml#idm45115254361520-marker)) [Android 开源项目](https://source.android.com/devices/tech/dalvik)提供了对
    Android 运行时特性及其背后原理的很好概述。
- en: ^([8](preface01.xhtml#idm45115253306592-marker)) Jack Wharton, a well-known
    Android developer, provides a [detailed insight](https://jakewharton.com/androids-java-8-support/)
    on how Android desugars modern Java code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](preface01.xhtml#idm45115253306592-marker)) 著名的 Android 开发者 Jack Wharton
    在他的[详细解析](https://jakewharton.com/androids-java-8-support/)中展示了 Android 如何处理现代
    Java 代码。
- en: ^([9](preface01.xhtml#idm45115253702896-marker)) See the official Kotlin documentation
    for [an overview of supported platforms](https://kotlinlang.org/docs/multiplatform-dsl-reference.xhtml).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](preface01.xhtml#idm45115253702896-marker)) 请参阅官方 Kotlin 文档，了解[支持平台的概述](https://kotlinlang.org/docs/multiplatform-dsl-reference.xhtml)。
- en: ^([10](preface01.xhtml#idm45115253442784-marker)) Each lambda compiles to an
    anonymous class extending `kotlin.jvm.internal.FunctionImpl`, as explained in
    the [function type specs](https://github.com/JetBrains/kotlin/blob/aabc00f53faa72f7c070c2512e655abffad37597/spec-docs/function-types.md).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](preface01.xhtml#idm45115253442784-marker)) 每个 Lambda 都会编译为一个匿名类，该类扩展了`kotlin.jvm.internal.FunctionImpl`，详见[函数类型规范](https://github.com/JetBrains/kotlin/blob/aabc00f53faa72f7c070c2512e655abffad37597/spec-docs/function-types.md)。
