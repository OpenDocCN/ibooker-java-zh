- en: 'Chapter 12\. Lambdas and Streams: What, Not How: Lambdas and Streams'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chapter 12\. Lambda 和 Stream：什么是，而不是如何：Lambda 和 Stream
- en: '![image](Images/f0369-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0369-01.png)'
- en: '**What if...you didn’t need to tell the computer HOW to do something?** Programming
    involves a lot of telling the computer how to do something: **while** this is
    true **do** this thing; **for** all these items **if** it looks like this **then**
    do this; and so on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果……你不需要告诉计算机如何做某事呢？** 编程涉及很多告诉计算机如何做某事的事情：**当** 这是真的 **时** 做这件事；**对于** 所有这些项目
    **如果** 它看起来像这样 **然后** 做这个；等等。'
- en: We’ve also seen that we don’t have to do everything ourselves. The JDK contains
    library code, like the Collections API we saw in the previous chapter, that we
    can use instead of writing everything from scratch. This library code isn’t just
    limited to collections to put data into; there are methods that will do common
    tasks for us, so we just need to tell them **what** we want and not **how** to
    do it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，我们不必完全依赖自己来完成所有事情。JDK 包含库代码，例如我们在上一章中看到的 Collections API，我们可以使用它来代替从头开始编写所有内容。这个库代码不仅仅局限于将数据放入集合中；还有一些方法可以为我们做一些常见的任务，因此我们只需告诉它们
    **我们想要什么**，而不是 **如何** 做到这一点。
- en: In this chapter we’ll look at the Streams API. You’ll see how helpful lambda
    expressions can be when you’re using streams, and you’ll learn how to use the
    Streams API to query and transform the data in a collection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下流 API。您将看到当您使用流时，Lambda 表达式可以帮助您，您将学习如何使用流 API 来查询和转换集合中的数据。
- en: Tell the computer WHAT you want
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉计算机你想要什么
- en: Imagine you have a list of colors, and you wanted to print out all the colors.
    You could use a for loop to do this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有一个颜色列表，你想打印出所有的颜色。你可以使用 for 循环来做到这一点。
- en: '![image](Images/f0370-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0370-01.png)'
- en: But doing something to every item in a list is a really common thing to want
    to do. So instead of creating a for loop every time we want to do something “for
    each” item in the list, we can call the **`forEach`** method from the Iterable
    interface—remember, List implements Iterable so it has all the methods from the
    Iterable interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在列表中对每个项目执行某些操作是一种非常普遍的需求。因此，我们可以从 Iterable 接口中调用 **`forEach`** 方法，而不是每次都创建一个
    for 循环来执行“对于”列表中的每个项目的操作。请记住，List 实现了 Iterable 接口，因此它具有来自 Iterable 接口的所有方法。
- en: '![image](Images/f0370-02.png)![image](Images/f0370-03.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0370-02.png)![image](Images/f0370-03.png)'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The forEach method of a list takes a lambda expression, which we saw for
    the first time in the previous chapter. This is a way for you to pass behavior
    (“follow these instructions”) into a method, instead of passing an object containing
    data (“here is an object for you to use”).**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表的 forEach 方法采用了 Lambda 表达式，我们在前一章中第一次看到它。这是一种方法，让您将行为（“按照这些说明执行”）传递给方法，而不是传递包含数据的对象（“这里有一个对象供您使用”）。**'
- en: Fireside Chats
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fireside Chats
- en: '![image](Images/f0304-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0304-01.png)'
- en: 'Tonight’s Talk: **The for loop and forEach method battle over the question,
    “Which is better?”**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今晚的讲话：**for 循环和 forEach 方法在“哪个更好？”的问题上进行了激烈的辩论。**
- en: '| forEach() | for loop |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| forEach() | for loop |'
- en: '| --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| I am the default! The for loop is so important that loads of programming
    languages have me. It’s one of the first things a programmer learns! If someone
    needs to loop a set number of times to do something, they’re going to reach for
    their trusty for loop. |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 我是默认的！for 循环如此重要，以至于许多编程语言都有我。这是程序员学习的第一件事之一！如果有人需要循环一定次数来做某事，他们会拿出他们信赖的
    for 循环。 |  |'
- en: '|  | Pff. Please. You are *so old*; that’s why you’re in all the programming
    languages. But things change, languages evolve. There’s a better way. A more modern
    way. Me. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  | Pff。拜托。你太老了；这就是为什么你出现在所有的编程语言中。但事物在变化，语言在进化。有一种更好的方式。一种更现代的方式。我。 |'
- en: '| Sure, fashions change. But sometimes it’s just a fad; things fall out of
    fashion too. A classic like me will be easy to read and write forever, even for
    non-Java programmers. |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 当然，时尚在变化。但有时它只是一时的风尚；事物也会过时。像我这样的经典将永远易于阅读和编写，即使是非 Java 程序员也是如此。 |  |'
- en: '|  | But look how much work developers need to do to write you! They have to
    control when to start, increment, and stop the loop, as well as writing the code
    that needs to be run inside the loop. All sorts of things could go wrong! If they
    use me, they just have to think about what needs to happen to each item, they
    don’t have to worry about how to loop to find each item. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | 但看看开发者为了编写你需要做多少工作！他们必须控制何时开始、递增和停止循环，以及编写需要在循环内运行的代码。各种问题都可能出现！如果他们使用我，他们只需要考虑每个项目需要发生什么，不必担心如何循环来找到每个项目。
    |'
- en: '| So much work?! Ha! A developer isn’t scared of a little syntax to clearly
    specify what to do and how to do it. At least with me, someone reading my code
    can clearly see what’s going on. |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 太多工作了？哈！开发者不怕一点点语法来清楚地指定要做什么和如何做。至少通过我的代码，读者可以清楚地看到发生了什么。 |  |'
- en: '|  | Dude, they shouldn’t *have* to see what’s going on. It says very clearly
    in my method name exactly what I do—“for each” element I will apply the logic
    they specify. Job done. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | 伙计，他们不应该*必须*看到发生了什么。我的方法名清楚地告诉他们我做了什么——“对于每个”元素，我将应用他们指定的逻辑。任务完成。 |'
- en: '| Well I’m faster. Everyone knows that. |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 嗯，我更快。众所周知的。 |  |'
- en: '|  | Well actually, under the covers I’m using a for loop myself, but if something
    is invented later that’s even faster, I can use that, and developers don’t have
    to change a single thing to get faster code. In fact we’re out of time now so....
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | 实际上，在底层我也在使用自己的 for 循环，但如果以后有更快的方法被发明出来，我可以使用那个，开发者不必改动一行代码就可以获得更快的代码。事实上，我们现在已经没时间了，所以...
    |'
- en: '| I said you would disappear soon. |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 我说过你很快就会消失的。 |  |'
- en: When for loops go wrong
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当 for 循环出现问题时
- en: Using **`forEach`** instead of a for loop means a bit less typing, and it’s
    also nice to focus on telling the compiler *what* you want to do and not *how*
    to do it. There’s another advantage to letting the libraries take care of routine
    code like this—it can mean fewer accidental errors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **`forEach`** 而不是 for 循环意味着少打一点字，专注于告诉编译器*你想要做什么*，而不是*如何做*。让库来处理这样的常规代码还有另一个好处——可以减少意外错误。
- en: Mixed Messages
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合信息
- en: '![image](Images/f0372-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0372-01.png)'
- en: A short Java program is listed below. One block of the program is missing. We
    expect the output of the program should be “1 2 3 4 5” but sometimes it’s difficult
    to get a for loop just right.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一个简短的 Java 程序。程序中缺少一个代码块。我们期望程序的输出应该是“1 2 3 4 5”，但有时候要正确编写一个 for 循环并不容易。
- en: Your challenge is to **match the candidate block of code** (on the left) **with
    the output** that you’d see if the block were inserted. Not all the lines of output
    will be used, and some of the lines of output might be used more than once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是**将候选代码块**（在左侧）**与插入后看到的输出进行匹配**。不是所有的输出行都会被使用，有些输出行可能会被多次使用。
- en: '![image](Images/f0372-02.png)![image](Images/f0372-03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0372-02.png)![image](Images/f0372-03.png)'
- en: '![Images](Images/arr1.png) **Answers in [“Mixed Messages”](#mixed_messages_left_parenthesisf-id00001).**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr1.png) **答案在 [“混合信息”](#mixed_messages_left_parenthesisf-id00001)
    中。**'
- en: Small errors in common code can be hard to spot
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见代码中的小错误可能很难发现
- en: The for loops from the previous exercise all look quite similar, and at first
    glance they all look like they would print out all the values in the List in order.
    Compiler errors can be easiest to spot, because your IDE or compiler will tell
    you the code is wrong, and Exceptions (which we’ll see in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*) can also point to a problem in the code. But it can be trickier
    to spot code that produces incorrect output just by looking at the code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面练习中的 for 循环看起来都很相似，乍一看它们似乎都会按顺序打印出 List 中的所有值。编译器错误可能最容易发现，因为你的 IDE 或编译器会告诉你代码有问题，异常（我们将在[第13章](ch13.xhtml#risky_behavior_exception_handling)
    *风险行为* 中看到）也可能指向代码中的问题。但通过查看代码来发现输出不正确的代码可能更加棘手。
- en: Using a method like **`forEach`** takes care of the “boilerplate,” the repetitive
    and common code like the for loop. Using forEach, passing in only the thing we
    want to do, can reduce accidental errors in our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 **`forEach`** 这样的方法可以处理“样板代码”，即像 for 循环这样的重复且常见的代码。使用 forEach，只需传入我们想要执行的内容，可以减少代码中的意外错误。
- en: '![image](Images/f0373-01.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0373-01.png)'
- en: '**Yes absolutely, in fact Java 8 introduced a whole API just for this.**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的，绝对是的，事实上，Java 8 版本专门为此引入了整个 API。**'
- en: Java 8 introduced the *Streams API*, a new set of methods that can be used on
    many classes, including the Collections classes we looked at in the previous chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了*流API*，这是一组新的方法，可以用于许多类，包括我们在上一章中看过的Collections类。
- en: The Streams API isn’t just a bunch of helpful methods, but also a slightly different
    way of working. It lets us build up a whole set of requirements, a recipe if you
    like, of what we want to know about our data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 流API不仅仅是一堆有用的方法，而且是一种稍微不同的工作方式。它让我们建立起一整套需求，如果你喜欢的话，可以把它看作是我们想要了解我们数据的一种配方。
- en: Building blocks of common operations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见操作的构建块
- en: The ways we search our collections, and the types of information we want to
    output from those collections, can be quite similar even on different types of
    collections containing different types of Objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们搜索集合的方式，以及我们想要从这些集合中输出的信息类型，即使在包含不同类型对象的不同类型集合上，也可能非常相似。
- en: 'Imagine what you might want do to with a Collection: “give me just the items
    that meet some criteria,” “change all the items using these steps,” “remove all
    duplicates,” and the example we worked through in the previous chapter: “sort
    the elements in this way.”'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你可能想要对一个集合做的事情：“给我只满足某些条件的项目”，“使用这些步骤更改所有项目”，“删除所有重复项”，以及我们在上一章中讨论的示例：“以这种方式对元素进行排序。”
- en: It’s not too hard to go one step further and assume each of these collection
    operations could be given a name that tells us what will happen to our collection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推测每个集合操作都可以有一个告诉我们将会发生什么的名称并不是太难。
- en: Introducing the Streams API
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入流API
- en: The Streams API is a set of operations we can perform on a collection, so when
    we read these operations in our code, we can understand what we’re trying to do
    with the collection data. If you were successful in the “Who Does What?” exercise
    on the previous page (the complete answers are at the end of this chapter), you
    should have seen that the names of the operations describe what they do.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 流API是一组我们可以在集合上执行的操作，因此当我们在代码中阅读这些操作时，我们可以理解我们试图对集合数据做什么。如果你在前一页的“谁做什么？”练习中取得了成功（完整答案在本章末尾），你应该已经看到操作的名称描述了它们的功能。
- en: '![image](Images/f0375-01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0375-01.png)'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Streams, and lambda expressions, were introduced in Java 8.**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**流和Lambda表达式是在Java 8中引入的。**'
- en: Getting started with Streams
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用流
- en: Before we start going into detail about what the Streams API is, what it does,
    and how to use it, we’re going to give you some very basic tools to start experimenting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讨论流API是什么，它做什么以及如何使用它之前，我们将为您提供一些非常基本的工具来开始实验。
- en: To use the Streams methods, we need a Stream object (obviously). If we have
    a collection like a List, this doesn’t implement Stream. However, the Collection
    interface has a method, **`stream`**, which returns a Stream object for the Collection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用流方法，我们需要一个流对象（显然）。如果我们有一个像List这样的集合，它不实现Stream。然而，Collection接口有一个名为**`stream`**的方法，它为Collection返回一个流对象。
- en: '![image](Images/f0376-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0376-01.png)'
- en: Now we can call the methods of the Streams API. For example, we could use **limit**
    to say we want a maximum of four elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用流API的方法了。例如，我们可以使用**limit**来指定我们希望最多有四个元素。
- en: '![image](Images/f0376-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0376-02.png)'
- en: What happens if we try to print out the result of calling limit()?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试打印调用limit()的结果会发生什么？
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![image](Images/f0376-03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0376-03.png)'
- en: Like everything in Java, the stream variables in the example are Objects. But
    a stream does ***not*** contain the elements in the collection. It’s more like
    the set of instructions for the operations to perform on the Collection data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像Java中的每样东西一样，例子中的流变量是对象。但流***不***包含集合中的元素。它更像是执行集合数据操作的一组指令。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Stream methods that return another Stream are called Intermediate Operations.
    These are instructions of things to do, but they don’t actually perform the operation
    on their own.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回另一个流的流方法称为中间操作。这些是要做的事情的指令，但它们本身并不执行操作。
- en: '![image](Images/f0377-01.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0377-01.png)'
- en: 'Streams are like recipes: nothing’s going to happen until someone actually
    cooks them'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流就像菜谱：直到有人真正开始烹饪它们之前，什么也不会发生。
- en: A recipe in a book only tells someone *how* to cook or bake something. Opening
    the recipe doesn’t automatically present you with a freshly baked chocolate cake.
    You need to gather the ingredients according to the recipe and follow the instructions
    exactly to come up with the result you want.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书中的食谱只告诉某人*如何*烹饪或烘焙某物。打开食谱并不会自动呈现给您一块新鲜出炉的巧克力蛋糕。您需要根据食谱收集配料，并且严格按照指示来达到您想要的结果。
- en: '![image](Images/f0377-02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0377-02.png)'
- en: Collections are not ingredients, and a list limited to four entries is not a
    chocolate cake (sadly). But you do need to call one of the Stream’s “do it” methods
    in order to get the result you want. These “do it” methods are called **Terminal
    Operations**, and these are the methods that will actually return something to
    you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不是配料，而且限于四个条目的列表不是巧克力蛋糕（遗憾的是）。但是，为了获得您想要的结果，您确实需要调用流的“执行”方法之一。这些“执行”方法称为**终端操作**，这些方法将实际返回给您某些东西。
- en: '![image](Images/f0377-03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0377-03.png)'
- en: Getting a result from a Stream
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从流中获取结果
- en: 'Yes, we’ve thrown a **lot** of new words at you: *streams*; *intermediate operations*;
    *terminal operations*... And we still haven’t told you what streams can do!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们向你介绍了很多新词：*流*；*中间操作*；*终端操作*...而且我们还没有告诉你流能做什么！
- en: To start to get a feel for what we can do with streams, we going to show code
    for a simple use of the Streams API. After that, we’ll step back and learn more
    about what we’re seeing here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始感受一下我们可以用流做什么，我们将展示一个简单使用流API的代码。之后，我们会退后一步，更多地了解我们在这里看到的内容。
- en: '![image](Images/f0378-01.png)![image](Images/f0378-02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0378-01.png)![image](Images/f0378-02.png)'
- en: 'This works, but it’s not very useful. One of the most common things to do with
    Streams is put the results into another type of collection. The API documentation
    for this method might seem intimidating with all the generic types, but the simplest
    case is straightforward:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但并不是很有用。流最常见的用途之一是将结果放入另一种类型的集合中。这个方法的API文档可能会因为所有泛型类型而显得令人生畏，但最简单的情况是直接的：
- en: '![image](Images/f0378-03.png)![image](Images/f0378-04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0378-03.png)![image](Images/f0378-04.png)'
- en: 'Finally, we have a result that looks like something we would have expected:
    we had a List of Strings, and we asked to **limit** that list to the first four
    items and then **collect** those four items into a new List.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一个看起来像我们预期的结果：我们有一个字符串列表，并要求将该列表限制为前四个项目，然后将这四个项目收集到一个新列表中。
- en: Stream operations are building blocks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流操作是建造块
- en: 'We wrote a lot of code just to output the first four elements in the list.
    We also introduced a lot of new terminology: streams, intermediate operations,
    and terminal operations. Let’s put all this together: you create a **stream p****i****peline**
    from three different types of building blocks.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了大量代码，仅仅是为了输出列表中的前四个元素。我们还引入了许多新术语：流、中间操作和终端操作。让我们把这一切整合起来：你从三种不同类型的建造块创建一个**流**
    **管道**。
- en: '![Images](Images/1.png) Get the Stream from a **source** collection.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) 从**源**集合获取流。'
- en: '![image](Images/f0379-01.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0379-01.png)'
- en: '![Images](Images/2.png) Call zero or more **intermediate operations** on the
    Stream.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) 在流上调用零个或多个**中间操作**。'
- en: '![image](Images/f0379-02.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0379-02.png)'
- en: '![Images](Images/3.png) Output the results with a **terminal operation**.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3.png) 使用**终端操作**输出结果。'
- en: '![image](Images/f0379-03.png)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0379-03.png)'
- en: You need at least the ***first*** and ***last*** pieces of the puzzle to use
    the Streams API. However, you don’t need to assign each step to its own variable
    (which we were doing on the last page). In fact, the operations are designed to
    be **chained**, so you can call one stage straight after the previous one, without
    putting each stage in its own variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用流API，您至少需要***第一个***和***最后一个***拼图块。然而，您无需将每个步骤分配给自己的变量（就像我们在上一页所做的那样）。事实上，这些操作是设计为**链式调用**的，因此您可以在前一阶段之后立即调用下一阶段，而不必将每个阶段放在自己的变量中。
- en: 'On the last page, all the building blocks for the stream were highlighted (stream,
    limit, count, collect). We can take these building blocks and rewrite the limit-and-collect
    operation in this way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一页，流的所有建造块都被突出显示（流、限制、计数、收集）。我们可以拿这些建造块并以这种方式重写限制和收集操作：
- en: '![image](Images/f0379-04.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0379-04.png)'
- en: Building blocks can be stacked and combined
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造块可以堆叠和组合
- en: Every intermediate operation acts on a Stream and returns a Stream. That means
    you can stack together as many of these operations as you want, before calling
    a terminal operation to output the results.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间操作作用于一个流并返回一个流。这意味着在调用终端操作输出结果之前，可以堆叠任意数量的这些操作。
- en: '![image](Images/f0380-01.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0380-01.png)'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The source, the intermediate operation(s), and the terminal operation all
    combine to form a Stream Pipeline. This pipeline represents a query on the original
    collection.**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**源、中间操作和终端操作共同形成一个流管道。这个管道代表对原始集合的查询。**'
- en: This is where the Streams API becomes really useful. In the earlier example,
    we needed three building blocks (stream, limit, collect) to create a shorter version
    of the original List, which may seem like a lot of work for a simple operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Streams API 真正有用的地方。在前面的例子中，我们需要三个构建块（流、限制、收集）来创建原始列表的较短版本，这可能对于一个简单的操作来说显得有些繁琐。
- en: But to do something more complicated, we can stack together multiple operations
    in a single **stream pipeline**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了执行更复杂的操作，我们可以将多个操作堆叠在一个单独的**流管道**中。
- en: 'For example, we can sort the elements in the stream before we apply the limit:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在应用限制之前对流中的元素进行排序：
- en: '![image](Images/f0380-02.png)![image](Images/f0380-03.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0380-02.png)![图片](Images/f0380-03.png)'
- en: Customizing the building blocks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制构建块
- en: We can stack together operations to create a more advanced query on our collection.
    We can also customize what the blocks do too. For example, we customized the **`limit`**
    method by passing in the maximum number of items to return (four).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以堆叠操作以在集合上创建更高级的查询。我们也可以定制这些块的功能。例如，我们通过传入要返回的最大项目数（四个）来定制了**`limit`**方法。
- en: If we didn’t want to use the natural ordering to sort our Strings, we could
    define a specific way to sort them. It’s possible to set the sort criteria for
    the **`sorted`** method (remember, we did something similar in the previous chapter
    when we sorted Lou’s song list).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用自然顺序来对字符串进行排序，我们可以定义一种特定的排序方式。可以为**`sorted`**方法设置排序标准（记住，在前一章中我们对Lou的歌曲列表进行了类似的操作）。
- en: '![image](Images/f0381-01.png)![image](Images/f0381-02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0381-01.png)![图片](Images/f0381-02.png)'
- en: Create complex pipelines block by block
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步创建复杂的管道
- en: Each new operation you add to the pipeline changes the output from the pipeline.
    Each operations tell the Streams API *what* it is you want to do.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你向管道中添加新操作，都会改变管道的输出。每个操作告诉 Streams API *你想要做什么*。
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![image](Images/f0381-04.png)![image](Images/f0382-01.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0381-04.png)![图片](Images/f0382-01.png)'
- en: Yes, because Streams are lazy
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是的，因为 Streams 是惰性的
- en: That doesn’t mean they’re slow or useless! It means that each intermediate operation
    is just the instruction about what to do; it doesn’t perform the instruction itself.
    Intermediate operations are *lazily evaluated*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它们慢或没用！这意味着每个中间操作只是关于如何操作的指令；它本身不执行指令。中间操作是*惰性评估*的。
- en: The terminal operation is responsible for looking at the whole list of instructions,
    all those intermediate operations in the pipeline, and then running the whole
    set together in one go. Terminal operations are *eager*; they are run as soon
    as they’re called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作负责查看整个指令列表，管道中所有中间操作，然后一次性运行整个集合。终端操作是*急切*的；它们在调用时立即运行。
- en: This means that in theory it’s possible to run the combination of instructions
    in the most efficient way. Instead of having to iterate over the original collection
    for each and every intermediate operation, it may be possible to do all the operations
    while only going through the data once.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着理论上可以以最高效的方式运行组合的指令。不必为每个中间操作逐个迭代原始集合，可能只需一次通过数据即可完成所有操作。
- en: '![image](Images/f0382-02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0382-02.png)'
- en: Terminal operations do all the work
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端操作完成所有工作
- en: Since intermediate operations are *lazy*, it’s up to the terminal operation
    to do everything.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中间操作是*惰性*的，完全取决于终端操作来执行所有工作。
- en: '![Images](Images/1circlea.png) Perform all the intermediate operations as efficiently
    as possible. Ideally, just going through the original data once.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circlea.png) 尽可能高效地执行所有中间操作。理想情况下，只需一次通过原始数据。'
- en: '![Images](Images/1circleb.png) Work out the result of the operation, which
    is defined by the terminal operation itself. For example, this could be a list
    of values, a single value, or a boolean (true/false).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circleb.png) 计算由终端操作定义的结果。例如，这可以是一组值、单个值或布尔值（true/false）。'
- en: '![Images](Images/1circlec.png) Return the result.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlec.png) 返回结果。'
- en: Collecting to a List
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集到列表
- en: Now that we know more about what’s going on in a terminal operation, let’s take
    a closer look at the “magic incantation” that returns a list of results.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更了解终端操作中发生的事情，让我们更仔细地看一下“魔法咒语”，它返回一系列结果的列表。
- en: '![image](Images/f0383-01.png)![image](Images/f0383-02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0383-01.png)![image](Images/f0383-02.png)'
- en: Guidelines for working with streams
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流的指南
- en: Like any puzzle or game, there are rules for getting the stream building blocks
    to work properly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何拼图或游戏一样，获取流构建块正常工作的规则很重要。
- en: '![Images](Images/1.png) **You need at least the first and last pieces to create
    a stream pipeline.**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **至少需要第一个和最后一个片段才能创建流水线。**'
- en: Without the **`stream`****`()`** piece, you don’t get a Stream at all, and without
    the terminal operation, you’re not going to get any results.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有**`stream`****`()`**部分，你根本得不到流，没有终端操作，你也得不到任何结果。
- en: '![image](Images/f0384-01.png)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0384-01.png)'
- en: '![Images](Images/2.png) **You can’t reuse Streams.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **你不能重复使用流（Streams）。**'
- en: It might seem useful to store a Stream representing a query, and reuse it in
    multiple places, either because the query itself is useful or because you want
    to build on it and add to it. But once a terminal operation has been called on
    a stream, you can’t reuse any parts of that stream; you have to create a new one.
    Once a pipeline has executed, that stream is closed and can’t be used in another
    pipeline, even if you stored part of it in a variable for reusing elsewhere. If
    you try to reuse a stream in any way, you’ll get an Exception.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储表示查询的流可能看起来很有用，并且可以在多个位置重复使用它，不论是因为查询本身有用还是因为您想在其上构建并添加到它。但是一旦在流上调用了终端操作，您就不能重用流的任何部分；您必须创建一个新的流。一旦流水线执行完毕，该流将关闭，无法在另一个流水线中使用，即使您在变量中存储了其部分以便在其他地方重用。如果尝试以任何方式重用流，将会引发异常。
- en: '[PRE2]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](Images/f0384-04.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0384-04.png)'
- en: '![Images](Images/3.png) **You can’t change the underlying collection while
    the stream is operating.**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3.png) **在流操作期间无法更改基础集合。**'
- en: If you do this, you’ll see strange results, or exceptions. Think about it—if
    someone asked you a question about what was in a shopping list and then someone
    else was scribbling on that shopping list at the same time, you’d give confusing
    answers too.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你这样做，你会看到奇怪的结果或异常。想想看——如果有人问你购物清单上有什么，同时另一个人正在上面乱涂乱画，你也会给出令人困惑的答案。
- en: '![image](Images/f0384-05.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0384-05.png)'
- en: '![image](Images/f0385-01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0385-01.png)'
- en: Correct! Stream operations don’t change the original collection.
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确！流操作不会改变原始集合。
- en: The Streams API is a way to query a collection, but it **doesn’t make changes**
    to the collection itself. You can use the Streams API to look through that collection
    and return results based on the contents of the collection, but your original
    collection will remain the same as it was.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 流API是查询集合的一种方式，但它**不会改变**集合本身。您可以使用流API查看集合中的内容并根据内容返回结果，但原始集合将保持不变。
- en: This is actually very helpful. It means you can query collections and output
    the results from anywhere in your program and know that the data in your original
    collection is safe; it will not be changed (“mutated”) by any of these queries.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这非常有帮助。这意味着您可以查询集合并从程序的任何位置输出结果，并且确保原始集合中的数据是安全的；它不会被任何这些查询“变异”。
- en: You can see this in action by printing out the contents of the original collection
    after using the Streams API to query it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打印原始集合内容来看到此操作的效果，此前使用流API查询过该集合。
- en: '![image](Images/f0385-02.png)![image](Images/f0385-03.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0385-02.png)![image](Images/f0385-03.png)'
- en: Exercise
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Code Magnets
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Code Magnets
- en: '![image](Images/f0386-02.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0386-02.png)'
- en: A Java program is all scrambled up on the fridge. Can you reconstruct the code
    snippets to make a working Java program that produces the output listed below?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java程序在冰箱上弄乱了。你能把这些代码片段重新排列，以使其成为一个能够产生下面列出的输出的工作Java程序吗？
- en: '![image](Images/f0386-03.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0386-03.png)'
- en: '![Images](Images/arr1.png) **Answers in [“Code Magnets”](#code_magnets_left_parenthesisfrom_page_3).**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案见[“代码磁铁”](#code_magnets_left_parenthesisfrom_page_3)**。'
- en: Hello Lambda, my (not so) old friend
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，Lambda，我的（不那么）老朋友
- en: Lambda expressions have cropped up in the streams examples so far, and you can
    bet your bottom dollar (or euro, or currency of your choice) that you’re going
    to see more of them before this chapter is done.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Lambda表达式已经在流示例中频繁出现，可以肯定在本章结束之前，你会看到更多的Lambda表达式。
- en: Having a better understanding of what lambda expressions are will make it easier
    to work with the Streams API, so let’s take a closer look at lambdas.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解lambda表达式将使您更容易使用Streams API，因此让我们更仔细地看一下lambda表达式。
- en: Passing behavior around
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递行为
- en: 'If you wrote a **`forEach`** method, it might look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写了一个**`forEach`**方法，它可能看起来像这样：
- en: '![image](Images/f0388-01.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0388-01.png)'
- en: What would you put in the place where “?????” is? It would need to somehow **be**
    the block of code that’s going to go into that nice, blank square.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在“?????”的位置上，你会放什么？它需要以某种方式**成为**将要放入那个漂亮的空白方块中的代码块。
- en: 'Then you want someone calling the method to be able to say:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你希望调用该方法的人能够说：
- en: '![image](Images/f0388-02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0388-02.png)'
- en: Now, we need to replace the *do this* with some sort of symbol to represent
    that this code isn’t to be run straightaway, but instead needs to be passed into
    the method. We could use, oh, let’s see... “**`->`**” as this symbol.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要用某种符号替换*做这个*，以表示此代码不是直接运行，而是需要传递到方法中。我们可以使用，噢，让我们看看... “**`->`**”作为这个符号。
- en: Then we need a way to say “look, this code is going to need to work on values
    from elsewhere.” We could put the things the code needs on the left side of the
    “do this” symbol....
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要一种方式来表示“看，这段代码需要在其他地方的值上运行”。我们可以将代码需要的东西放在“做这个”符号的左侧....
- en: '![image](Images/f0388-03.png)![image](Images/f0388-04.png)![image](Images/f0389-01.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0388-03.png)![图片](Images/f0388-04.png)![图片](Images/f0389-01.png)'
- en: Lambda expressions are objects, and you run them by calling their Single Abstract
    Method
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式是对象，通过调用它们的Single Abstract Method来运行它们
- en: Remember, everything in Java is an Object (well, except for the primitive types),
    and lambdas are no exception.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Java中的所有东西都是对象（嗯，除了原始类型），Lambda也不例外。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**A lambda expression implements a Functional Interface.**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**lambda表达式实现了Functional Interface。**'
- en: This means the reference to the lambda expression is going to be a Functional
    Interface. So, if you want your method to accept a lambda expression, you need
    to have a parameter whose type is a functional interface. That functional interface
    needs to be the right “shape” for your lambda.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对lambda表达式的引用将是一个Functional Interface。因此，如果您希望您的方法接受lambda表达式，您需要有一个参数，其类型是Functional
    Interface。该Functional Interface需要是您的lambda正确“形状”的。
- en: Back to our imaginary **`forEach`** example; our parameter needs to implement
    a Functional Interface. We also need to call that lambda expression somehow, passing
    in the list element.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们想象中的**`forEach`**示例；我们的参数需要实现一个Functional Interface。我们还需要以某种方式调用那个lambda表达式，将列表元素传递进去。
- en: Remember, Functional Interfaces have a Single Abstract Method (SAM). It’s this
    method, whatever its name is, that gets called when we want to run the lambda
    code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Functional Interface具有一个Single Abstract Method（SAM）。当我们想要运行lambda代码时，就会调用这个方法，无论它的名称是什么。
- en: '![image](Images/f0389-02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0389-02.png)'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Lambdas aren’t magic; they’re just classes like everything else.**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda并非魔法；它们只是像其他所有东西一样的类。**'
- en: The shape of lambda expressions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式的形状
- en: 'We’ve seen two lambda expressions that implement the Comparator interface:
    the example for sorting Lou’s songs in the previous chapter, and the lambda expression
    we passed into the **`sorted`****`()`** stream operation in [“Customizing the
    building blocks”](#customizing_the_building_blocks). Look at this last example
    side by side with the Comparator Functional Interface.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两个实现Comparator接口的lambda表达式：在前一章节中用于对Lou的歌曲进行排序的示例，以及我们传递给**`sorted`****`()`**流操作中的lambda表达式，见[“定制构建块”](#customizing_the_building_blocks)。将此最后一个示例与Comparator功能接口并排查看。
- en: '![image](Images/f0390-01.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0390-01.png)'
- en: 'You might be wondering where the **return** keyword is in the lambda expression.
    The short version is: you don’t need it. The longer version is, if the lambda
    expression is a single line, and if the functional interface’s method signature
    requires a returned value, the compiler just assumes that your one line of code
    will generate the value that is to be returned.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 lambda 表达式中的 **return** 关键字在哪里。简短的答案是：你不需要它。更长的答案是，如果 lambda 表达式是单行的，并且函数接口的方法签名需要返回一个值，编译器会假设你的一行代码将生成要返回的值。
- en: 'The lambda expression can also be written like this, if you want to add all
    the parts a lambda expression can have:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要添加 lambda 表达式可以拥有的所有部分，lambda 表达式也可以这样写：
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Anatomy of a lambda expression
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lambda 表达式的解剖
- en: If you take a closer look at this expanded version of the lambda expression
    that implements `Comparator<String>`, you’ll see it’s not so different from a
    standard Java method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察实现 `Comparator<String>` 的 lambda 表达式的扩展版本，你会发现它与标准 Java 方法并没有太大的区别。
- en: '![image](Images/f0391-01.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0391-01.png)'
- en: The shape of the lambda (its parameters, return type, and what it can reasonably
    be expected to do) is dictated by the Functional Interface it implements.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的形状（其参数、返回类型以及可以合理预期的操作）由它实现的函数接口决定。
- en: Variety is the spice of life
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多样化是生活的调味品
- en: '![image](Images/f0392-01.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0392-01.png)'
- en: Lambda expressions can come in all shapes and sizes, and still conform to the
    same basic rules that we’ve seen.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式可以有各种形状和大小，并且仍然符合我们看到的相同基本规则。
- en: A lambda might have more than one line
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 lambda 可能有多行。
- en: A lambda expression is effectively a method, and can have as many lines as any
    other method. Multiline lambda expressions ***must*** be inside curly braces.
    Then, like any other method code, every line ***must*** end in a semicolon, and
    if the method is supposed to return something, the lambda body ***must*** include
    the word “return” like any normal method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式实际上是一个方法，可以像任何其他方法一样有多行。多行 lambda 表达式必须放在花括号内。然后，就像任何其他方法代码一样，每行必须以分号结尾，如果方法应返回某些内容，则
    lambda 主体必须包含像任何普通方法一样的“return”关键字。
- en: '![image](Images/f0392-02.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0392-02.png)'
- en: Single-line lambdas don’t need ceremony
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单行 lambda 不需要仪式
- en: 'If your lambda expression is a single line, it makes it much easier for the
    compiler to guess what’s going on. Therefore, we can leave out a lot of the “boilerplate”
    syntax. If we shrink the lambda expression from the last example into a single
    line, it looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 lambda 表达式只有一行，编译器更容易猜出发生了什么。因此，我们可以省略许多“样板”语法。如果我们将最后一个示例中的 lambda 表达式缩减为一行，它看起来像这样：
- en: '![image](Images/f0392-03.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0392-03.png)'
- en: This is the same Functional Interface (Comparator) and performs the same operation.
    Whether you use multiline lambdas or single-line lambdas is completely up to you.
    It will probably depend upon how complicated the logic in the lambda expression
    is, and how easy you think it is to read—sometimes longer code can be more descriptive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的函数接口（Comparator）执行相同的操作。无论你使用多行 lambda 还是单行 lambda 完全取决于你。这可能取决于 lambda
    表达式中的逻辑有多复杂，以及你认为它有多容易阅读——有时更长的代码可以更具描述性。
- en: Later, we’ll see another approach for handling long lambda expressions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 后面，我们将看到处理长的 lambda 表达式的另一种方法。
- en: A lambda might not return anything
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 lambda 可能不返回任何内容
- en: The Functional Interface’s method might be declared void; i.e., it doesn’t return
    anything. In these cases, the code inside the lambda is simply run, and you don’t
    need to return any values from the lambda body.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接口的方法可能声明为 void；即，它不返回任何内容。在这些情况下，lambda 内部的代码会被简单地执行，你不需要从 lambda 主体返回任何值。
- en: This is the case for lambda expressions in a **`forEach`** method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于 **`forEach`** 方法中的 lambda 表达式。
- en: '![image](Images/f0393-01.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0393-01.png)'
- en: A lambda might have zero, one, or many parameters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 lambda 可能有零个、一个或多个参数。
- en: The number of parameters the lambda expression needs is dependent upon the number
    of parameters the Functional Interface’s method takes. The parameter types (e.g.,
    the name “String”) are not usually required, but you can add them if you think
    it makes it easier to understand the code. You may need to add the types if the
    compiler can’t automatically work out which Functional Interface your lambda implements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式需要的参数数量取决于功能接口方法所需的参数数量。参数类型（例如，“String”这个名字）通常不是必需的，但如果您认为这样做可以更容易理解代码，可以添加它们。如果编译器无法自动确定您的
    lambda 实现哪个功能接口，可能需要添加类型。
- en: '![image](Images/f0393-02.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0393-02.png)'
- en: How can I tell if a method takes a lambda?
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何判断方法是否接受 lambda 表达式？
- en: By now you’ve seen that lambda expressions are implementations of a functional
    interface—that is, an Interface with a Single Abstract Method. That means the
    **type** of a lambda expression is this interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到 lambda 表达式是功能接口的实现——即，一个具有单个抽象方法的接口。这意味着 lambda 表达式的类型就是这个接口。
- en: Go ahead and create a lambda expression. Instead of passing this into some method,
    as we have been doing so far, assign it to a variable. You’ll see it can be treated
    just like any other Object in Java, because everything in Java is an Object. The
    variable’s type is the Functional Interface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并创建一个 lambda 表达式。不像我们迄今为止一直做的那样将其传递给某些方法，而是将其分配给一个变量。您会发现它可以像 Java 中的任何其他对象一样处理，因为
    Java 中的一切都是对象。变量的类型就是功能接口。
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'How does this help us see if a method takes a lambda expression? Well, the
    method’s parameter type will be a Functional Interface. Take a look at some examples
    from the Streams API:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助我们看到方法是否接受 lambda 表达式？嗯，方法的参数类型将是一个功能接口。看一些来自 Streams API 的例子：
- en: '![image](Images/f0394-01.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0394-01.png)'
- en: Exercise
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/exercise.png)'
- en: BE the Compiler, advanced
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the Compiler, advanced
- en: '![image](Images/f0395-01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0395-01.png)'
- en: '**Your job is to play compiler and determine which of these statements would
    compile. But some of this code wasn’t covered in the chapter, so you need to work
    out the answers based on what you DID learn, applying the “rules” to these new
    situations.**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**您的任务是扮演编译器，确定这些语句中哪些会编译通过。但本章节未涵盖其中的一些代码，因此您需要根据所学内容找出答案，将“规则”应用到这些新情况中。**'
- en: '**The signatures of the functional interfaces are on the right, for your convenience.**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能接口的签名在右边，方便您查看。**'
- en: '![image](Images/f0395-02.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0395-02.png)'
- en: '**Check the box if the statement would compile.**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果语句能够编译，请勾选复选框。**'
- en: '| ![Images](Images/box.png) | `**Runnable r = () -> System.out.println("Hi!");**`
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Runnable r = () -> System.out.println("Hi!");**`
    |'
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = s -> System.out.println(s);**`
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Consumer<String> c = s -> System.out.println(s);**`
    |'
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = () -> System.out.println("Some
    string");**` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Supplier<String> s = () -> System.out.println("Some
    string");**` |'
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = (s1, s2) -> System.out.println(s1
    + s2);**` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Consumer<String> c = (s1, s2) -> System.out.println(s1
    + s2);**` |'
- en: '| ![Images](Images/box.png) | `**Runnable r = (String str) -> System.out.println(str);**`
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Runnable r = (String str) -> System.out.println(str);**`
    |'
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = s -> s.length();**`
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Function<String, Integer> f = s -> s.length();**`
    |'
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = () -> "Some string";**`
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Supplier<String> s = () -> "Some string";**` |'
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = s -> "String" + s;**`
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Consumer<String> c = s -> "String" + s;**` |'
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = (int i) -> "i
    = " + i;**` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Function<String, Integer> f = (int i) -> "i =
    " + i;**` |'
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = s -> "Some string: "
    + s;**` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Supplier<String> s = s -> "Some string: " + s;**`
    |'
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = (String s) ->
    s.length();**` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/box.png) | `**Function<String, Integer> f = (String s) -> s.length();**`
    |'
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler”](#be_the_compiler_left_parenthesis-id00001).**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在 [“BE the Compiler”](#be_the_compiler_left_parenthesis-id00001)
    中。**'
- en: Spotting Functional Interfaces
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现功能接口
- en: So far we’ve seen Functional Interfaces that are marked with a **`@FunctionalInterface`**
    *annotation* (we’ll cover annotations in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d)),
    which conveniently tells us this interface has a Single Abstract Method and can
    be implemented with a lambda expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了标有**`@FunctionalInterface`** *注解*的功能接口（我们将在[附录B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d)中讨论注解），这方便地告诉我们这个接口有一个单一抽象方法，并且可以用
    lambda 表达式实现。
- en: Not all functional interfaces are tagged this way, particularly in older code,
    so it’s useful to understand how to spot a functional interface for yourself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的功能接口都以这种方式标记，特别是在旧代码中，因此学会如何自行识别功能接口是很有用的。
- en: '![image](Images/f0396-01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0396-01.png)'
- en: '**Not so fast!**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要那么快！**'
- en: Originally, the only kind of methods allowed in interfaces were **abstract**
    methods, methods that need to be *overridden* by any class that *implements* this
    interface. But as of Java 8, interfaces can also contain **`default`** and **`static`**
    methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，接口中允许的方法只有**抽象**方法，需要任何实现这个接口的类来*重写*。但是自 Java 8 起，接口还可以包含**`default`**和**`static`**方法。
- en: You saw static methods in [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics),
    *Numbers Matter*, and you’ll see them later in this chapter too. These are methods
    that don’t need to belong to an instance, and are often used as helper methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第10章](ch10.xhtml#numbers_matter_numbers_and_statics)——*数字至关重要*中看到了静态方法，后面这章节也会再次看到它们。这些方法不需要属于一个实例，并且通常被用作辅助方法。
- en: Default methods are slightly different. Remember abstract classes from [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*? They had abstract methods that need to be overridden,
    and standard methods with a body. On an interface, a default method works a bit
    like a standard method in an abstract class—they have a body, and will be inherited
    by subclasses.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法略有不同。还记得第8章[*严肃的多态性——接口和抽象*](ch08.xhtml#serious_polymorphism_interfaces_and_abst)中的抽象类吗？它们有需要被重写的抽象方法，并且有带有方法体的标准方法。在接口上，默认方法的工作方式有点像抽象类中的标准方法——它们有一个方法体，并且会被子类继承。
- en: Both default and static methods have a method body, with defined behavior. With
    interfaces, any method that is not defined as **`default`** or **`static`** is
    an abstract method that *must* be overridden.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法和静态方法都有一个方法体，有定义的行为。在接口中，任何不定义为**`default`**或**`static`**的方法都是必须被重写的抽象方法。
- en: Functional interfaces in the wild
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 野生的功能接口
- en: Now that we know interfaces can have **non**-abstract methods, we can see there’s
    a bit more of a trick to identifying interfaces with just one abstract method.
    Take a look at our old friend, Comparator. It has a **lot** of methods! And yet
    it’s still a SAM-type; it has only one Single Abstract Method. It’s a Functional
    Interface we can implement as a lambda expression.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道接口可以有**非**抽象方法，我们可以看到识别只有一个抽象方法的接口有点技巧。看看我们的老朋友 Comparator。它有**很多**方法！但是它仍然是一个
    SAM 类型；它只有一个单一抽象方法。它是一个我们可以用 lambda 表达式实现的功能接口。
- en: '![image](Images/f0397-01.png)![image](Images/f0398-01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0397-01.png)![image](Images/f0398-01.png)'
- en: Lou’s back!
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lou 回来了！
- en: Lou’s been running his new jukebox management software from the last chapter
    for some time now, and he wants to learn so much more about the songs played on
    the diner’s jukebox. Now that he has the data, he wants to slice-and-dice it and
    put it together in a new shape, just as he does with the ingredients of his famous
    Special Omelette!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Lou 已经在他上一章的新点唱机管理软件上运行了一段时间，并且他希望更多地了解餐馆点唱机上播放的歌曲。现在他有了数据，他想要切割和重新整合它，就像他处理他著名的特色煎蛋卷的配料一样！
- en: 'He’s thinking there are all kinds of information he could learn about the songs
    that are played, like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 他在思考有各种关于播放的歌曲可以学到的信息，比如：
- en: What are the top five most-played songs?
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪五首歌曲播放次数最多？
- en: What sort of genres are played?
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放的是哪些类型的流派？
- en: Are there any songs with the same name by different artists?
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有不同艺术家演唱的同名歌曲？
- en: We *could* find these things out writing a for loop to look at our song data,
    performing checks using if statements, and perhaps putting songs, titles, or artists
    into different collections to find the answers to these questions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个 for 循环来查看我们的歌曲数据，使用 if 语句进行检查，并且可能将歌曲、标题或艺术家放入不同的集合中，以找到这些问题的答案。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**But now that we know about the Streams API, we know there’s an easier way....**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是现在我们知道了 Streams API，我们知道有一个更简单的方法....**'
- en: The code on the next page is your **mock** code; calling **`Songs.getSongs()`**
    will give you a List of Song objects that you can assume looks just like the real
    data from Lou’s jukebox.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页的代码是您的**模拟**代码；调用**`Songs.getSongs()`**将给您一个 Song 对象的 List，您可以假设它看起来与 Lou
    的点唱机上的真实数据一样。
- en: Exercise
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Type in the Ready-Bake Code on the next page, including filling out the rest
    of the Song class. When you’ve done that, create a main method that prints out
    all the songs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页上键入 Ready-Bake Code，包括填写 Song 类的其余部分。完成后，创建一个主方法，打印出所有的歌曲。
- en: What do you expect the output to look like?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望输出看起来像什么？
- en: Ready-Bake Code
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ready-Bake Code
- en: '![image](Images/f0399-01.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0399-01.png)'
- en: Here’s an updated “mock” method. It will return some test data that we can use
    on to try out some of the reports Lou wants to create for the jukebox system.
    There’s also an updated Song class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更新的“模拟”方法。它将返回一些测试数据，我们可以用来尝试 Lou 想要为点唱机系统创建的一些报告。还有一个更新的 Song 类。
- en: '[PRE5]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lou’s Challenge #1: Find all the “rock” songs'
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Lou 的挑战 #1：找到所有的“摇滚”歌曲'
- en: The data in the updated song list contains the *genre* of the song. Lou’s noticed
    that the diner’s clientele seem to prefer variations on rock music, and he wants
    to see a list of all the songs that fall under some genre of “rock.”
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的歌曲列表中包含歌曲的*流派*。Lou 注意到餐馆的客户似乎更喜欢摇滚音乐的变体，他想看到所有属于“摇滚”某种流派的歌曲的列表。
- en: This is the Streams chapter, so clearly the solution is going to involve the
    Streams API. Remember, there are three types of pieces we can put together to
    form a solution.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Streams 章节，所以解决方案显然涉及 Streams API。记住，我们可以组合三种类型的片段来形成解决方案。
- en: '![image](Images/f0400-01.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0400-01.png)'
- en: 'Fortunately, there are hints about how to create a Streams API call based on
    the requirements Lou gave us: he wants to **`filter`** for just the Songs with
    a particular genre, and he wants to **`collect`** them into a new List`.`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有关如何基于 Lou 给我们的要求创建 Streams API 调用的提示：他希望**`filter`**仅保留特定流派的歌曲，并将它们**`collect`**到一个新的
    List 中。
- en: '![image](Images/f0400-02.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0400-02.png)'
- en: Filter a stream to keep certain elements
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤流以保留某些元素
- en: Let’s see how a filter operation might work on the list of songs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如何在歌曲列表上进行过滤操作。
- en: '![image](Images/f0401-01.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0401-01.png)'
- en: Let’s Rock!
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们摇滚吧！
- en: So adding a **`filter`** operation filters out elements that we don’t want,
    and the stream continues with just the elements that meet our criteria. It should
    come as no surprise to find that you can use a lambda expression to state which
    elements we want to keep in the stream.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加一个**`filter`**操作会过滤掉我们不想要的元素，并且流会继续保留满足我们条件的元素。使用 lambda 表达式来指定我们希望在流中保留哪些元素并不奇怪。
- en: The filter method takes a **`Predicate`**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: filter 方法接受一个**`Predicate`**。
- en: Given what we know about the shapes of lambda expressions, we should be able
    to work out how to write a lambda expression that implements Predicate.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 lambda 表达式的形状，我们应该能够找出如何编写一个实现 Predicate 的 lambda 表达式。
- en: '![image](Images/f0402-01.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0402-01.png)'
- en: We’ll know what the type of the single parameter is when we plug it into the
    Stream operation, since the input type to the lambda will be determined by the
    types in the stream.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将其插入到流操作中时，我们将知道单参数的类型，因为 lambda 的输入类型将由流中的类型决定。
- en: '![image](Images/f0402-02.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0402-02.png)'
- en: Getting clever with filters
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在过滤器上聪明应用
- en: 'The **`filter`** method, with its “simple” true or false return value, can
    contain sophisticated logic to filter elements in, or out, of the stream. Let’s
    take our filter one step further and actually do what Lou asked:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**`filter`**方法具有简单的真或假返回值，可以包含复杂的逻辑来过滤流中的元素。让我们将我们的过滤器进一步扩展，并实际执行 Lou 要求的操作：'
- en: '*He wants to see a list of all the songs that fall under* ***some genre***
    *of “rock.**”*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*他想看到所有属于* ***某种摇滚流派*** *的歌曲列表。*'
- en: He doesn’t want to see just the songs that are classed as “Rock,” but any genre
    that is kinda Rock-like. We should search for any genre that has the word “Rock”
    in it somewhere.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 他不仅想看到被分类为“摇滚”的歌曲，还想看到任何类似摇滚的流派。我们应该搜索任何流派中含有“Rock”这个词的流派。
- en: There’s a method in String that can help us with this, it’s called **`contains`**.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 String 中的方法可以帮助我们，它叫做**`contains`**。
- en: '![image](Images/f0403-01.png)![image](Images/f0403-02.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0403-01.png)![image](Images/f0403-02.png)'
- en: 'Lou’s Challenge #2: List all the genres'
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Lou 的挑战 #2：列出所有的流派'
- en: Lou now senses that the genres of music that the diners are listening to are
    more complicated than he thought. He wants a list of all the genres of the songs
    that have been played.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Lou 察觉到餐馆里的顾客们听的音乐流派比他想象的要复杂。他想要一个已播放歌曲流派的列表。
- en: So far, all of our streams have returned the same types that they started with.
    The earlier examples were Streams of Strings, and returned Lists of Strings. Lou’s
    previous challenge started with a List of Songs and ended up with a (smaller)
    List of Songs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有流都返回了它们开始的相同类型。前面的示例是 Strings 流，并返回了 Strings 列表。Lou 之前的挑战是从歌曲列表开始，最终得到了一个（较小的）歌曲列表。
- en: Lou now wants a list of genres, which means we need to somehow turn the song
    elements in the stream into genre (String) elements. This is what **`map`** is
    for. The map operation states how to map *from* one type *to* another type.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Lou 想要一个流派的列表，这意味着我们需要想办法将流中的歌曲元素转换为流派（String）元素。这正是**`map`**的用途。map 操作指定了如何从一种类型映射到另一种类型。
- en: '![image](Images/f0404-01.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0404-01.png)'
- en: Mapping from one type to another
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一种类型映射到另一种类型
- en: 'The map method takes a **`Function`**. The generics by definition are a bit
    vague, which makes it a little tricky to understand, but Functions do one thing:
    they take something of one type and return something of a different type. Exactly
    what’s needed for mapping varies from one type to another.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: map 方法接受一个**`Function`**。泛型定义有些模糊，这使得理解起来有些棘手，但 Function 只做一件事：它接受一个类型的东西并返回一个不同类型的东西。对于不同类型的映射需要的确切内容因类型而异。
- en: '![image](Images/f0405-01.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0405-01.png)'
- en: Let’s see what it looks like when we use **`map`** in a stream pipeline.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在流式管道中使用**`map`**时的效果。
- en: '![image](Images/f0405-02.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0405-02.png)'
- en: The map’s lambda expression is similar to the one for filter; it takes a song
    and turns it into something else. Instead of returning a boolean, it returns some
    other object, in this case a String containing the song’s genre.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: map 的 lambda 表达式类似于 filter 的 lambda 表达式；它接受一个歌曲并将其转换为其他对象。不返回布尔值，而是返回其他对象，在本例中是包含歌曲流派的
    String。
- en: '![image](Images/f0405-03.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0405-03.png)'
- en: Removing duplicates
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除重复项
- en: We’ve got a list of all the genres in our test data, but Lou probably doesn’t
    want to wade through all these duplicate genres. The **`map`** operation on its
    own will result in an output List that’s the same size as the input List. Since
    stream operations are designed to be stacked together, perhaps there’s another
    operation we can use to get just one of every element in the stream?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了测试数据中所有流派的列表，但 Lou 可能不想浏览所有这些重复的流派。**`map`**操作本身将导致输出列表的大小与输入列表相同。由于流操作设计为可以堆叠在一起，也许我们可以使用另一个操作来仅获取流中每个元素的一个？
- en: '![image](Images/f0406-01.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0406-01.png)'
- en: Only one of every genre
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每种流派只有一个
- en: All we need to do is to add a distinct operation to the stream pipeline, and
    we’ll get just one of each genre.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需做的就是在流式管道中添加一个 distinct 操作，这样我们就能获得每种流派的唯一一种。
- en: '![image](Images/f0407-01.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0407-01.png)'
- en: Just keep building!
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续构建！
- en: A stream pipeline can have any number of intermediate operations. The power
    of the Streams API is that we can build up complex queries with understandable
    building blocks. The library will take care of running this in a way that is as
    efficient as possible. For example, we could create a query that returns a list
    of all the artists that have covered a specific song, excluding the original artists,
    by using a map operation and multiple filters.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 流式管道可以有任意数量的中间操作。Streams API 的强大之处在于我们可以使用易于理解的构建模块来构建复杂的查询。库会尽可能以高效的方式运行这些操作。例如，我们可以通过使用映射操作和多个过滤器来创建一个查询，该查询返回所有翻唱了特定歌曲的艺术家列表，但排除了原创艺术家。
- en: '[PRE6]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sometimes you don’t even need a lambda expression
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时甚至不需要 lambda 表达式
- en: Some lambda expressions do something simple and predictable, given the type
    of the parameter or the shape of the functional interface. Look again at the lambda
    expression for the **`map`** operation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有些 lambda 表达式做的事情非常简单和可预测，考虑到参数的类型或函数接口的形状。再次看看**`map`**操作的 lambda 表达式。
- en: '[PRE7]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Method references can replace lambda expressions, but you don’t have to use
    them.**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法引用可以替换 lambda 表达式，但你不一定非要使用它们。**'
- en: '**Sometimes method references make the code easier to understand.**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时方法引用使代码更易于理解。**'
- en: Instead of spelling this whole thing out, you can point the compiler to a method
    that does the operation we want, using a **method reference**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是详细说明整个操作，您可以使用**方法引用**指向我们想要执行操作的方法，让编译器处理。
- en: '![image](Images/f0408-02.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0408-02.png)'
- en: Method references can replace lambda expressions in a number of different cases.
    Generally, we might use a method reference if it makes the code easier to read.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用可以替换多种不同情况下的lambda表达式。一般来说，如果方法引用使代码更易读，则我们可能会使用方法引用。
- en: 'Take our old friend the Comparator, for example. There are a lot of helper
    methods on the Comparator interface that, when combined with a method reference,
    let you see which value is being used for sorting and in which direction. Instead
    of doing this, to order the songs from oldest to newest:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的老朋友Comparator为例。Comparator接口上有许多辅助方法，与方法引用结合使用时，可以让您查看用于排序的值及其排序方向。而不是这样做，按照从最旧到最新的顺序排序歌曲：
- en: '[PRE8]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use a method reference combined with a **`static`** helper method from Comparator
    to state what the comparison should be:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Comparator的**`static`**辅助方法结合的方法引用来说明比较应该是什么：
- en: '[PRE9]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Collecting results in different ways
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以不同的方式收集结果
- en: While **`Collectors.toList`** is the most commonly used Collector, there are
    other useful Collectors. For example, instead of using **`distinct`** to solve
    the last challenge, we could collect the results into a Set, which does not allow
    duplicates. The advantage of using this approach is that anything else that uses
    the results knows that because it’s a Set, *by definition* there will be no duplicates.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**`Collectors.toList`**是最常用的收集器，但还有其他有用的收集器。例如，为了解决最后的挑战，我们可以将结果收集到不允许重复的Set中，而不是使用**`distinct`**。使用此方法的优点是，任何使用结果的其他东西都知道，因为它是一个Set，*根据定义*不会有重复项。
- en: '![image](Images/f0409-01.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0409-01.png)'
- en: '**Collectors.toList and Collectors.toUnmodifiableList**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collectors.toList和Collectors.toUnmodifiableList**'
- en: You’ve already seen **`toList`**. Alternatively, you can get a List that can’t
    be changed (no elements can be added, replaced or removed) by using **`Collectors.toUnmodifableList`**
    instead. This is only available from Java 10 onward.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过**`toList`**。或者，您可以使用**`Collectors.toUnmodifableList`**获得无法更改的列表（无法添加、替换或删除元素）。这仅适用于Java
    10及以上版本。
- en: '![image](Images/f0409-02.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0409-02.png)'
- en: '**Collectors.toSet and Collectors.toUnmodifiableSet**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collectors.toSet和Collectors.toUnmodifiableSet**'
- en: Use these to put the results into a Set, rather than a List. Remember that a
    Set cannot contain duplicates, and is not usually ordered. If you’re using Java
    10 or higher, you can use **`Collectors.toUnmodifiableSet`** if you want to make
    sure your results aren’t changed by anything.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法将结果放入Set，而不是List。请记住，Set不能包含重复项，并且通常不排序。如果您使用的是Java 10或更高版本，则可以使用**`Collectors.toUnmodifiableSet`**确保您的结果不受任何其他东西的更改。
- en: '![image](Images/f0409-03.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0409-03.png)'
- en: '**Collectors.toMap and Collectors.toUnmodifiableMap**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collectors.toMap和Collectors.toUnmodifiableMap**'
- en: You can collect your stream into a Map of key/value pairs. You will need to
    provide some functions to tell the collector what will be the key and what will
    be the value. You can use **`Collectors.toUnmodifiableMap`** to create a map that
    can’t be changed, from Java 10 onward.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将流收集到键/值对的Map中。您需要提供一些函数告诉收集器什么将是键和什么将是值。您可以使用**`Collectors.toUnmodifiableMap`**创建无法更改的Map，从Java
    10开始。
- en: '![image](Images/f0409-04.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0409-04.png)'
- en: '**Collectors.joining**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collectors.joining**'
- en: You can create a String result from the stream. It will join together all the
    stream elements into a single String. You can optionally define the *delimiter*,
    the character to use to separate each element. This can be very useful if you
    want to turn your stream into a String of Comma Separated Values (CSV).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从流中创建一个String结果。它将所有流元素连接成一个单独的String。您可以选择定义*分隔符*，用于分隔每个元素。如果要将流转换为逗号分隔值（CSV）的字符串，这非常有用。
- en: But wait, there’s more!
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但等等，还有更多！
- en: Collecting the results is not the only game in town; **`collect`** is just one
    of many terminal operations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 收集结果并不是唯一的游戏方式；**`collect`**只是众多终端操作之一。
- en: Checking if something exists
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查某事是否存在
- en: You can use terminal operations that return a boolean value to look for certain
    things in the stream. For example, we can see if any R&B songs have been played
    in the diner.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用返回布尔值的终端操作来查找流中的特定内容。例如，我们可以查看在餐馆是否播放了任何R&B歌曲。
- en: '![image](Images/f0410-01.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0410-01.png)'
- en: Find a specific thing
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找特定的事物
- en: Terminal operations that return an **`Optional`** value look for certain things
    in the stream. For example, we can find the first song played that was released
    in 1995.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作返回一个**`Optional`**值，它在流中寻找特定的内容。例如，我们可以找到1995年发布的第一首播放的歌曲。
- en: '![image](Images/f0410-02.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0410-02.png)'
- en: Count the items
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计项目数。
- en: There’s a count operation that you can use to find out the number of elements
    in your stream. We could find the number of unique artists, for example.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个计数操作可以用来查找流中元素的数量。例如，我们可以找到唯一艺术家的数量。
- en: '[PRE10]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**There are even more terminal operations, and some of them depend upon the
    type of Stream you’re working with.**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**还有更多的终端操作，其中一些取决于你正在处理的Stream类型。**'
- en: '**Remember, the API documentation can help you figure out if there’s a built-in
    operation that does what you want.**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住，API文档可以帮助你确定是否有内置操作可以完成你想要的操作。**'
- en: '![image](Images/f0411-01.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0411-01.png)'
- en: Well, some operations may return something, or may not return anything at all
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好吧，有些操作可能返回一些东西，或者根本不返回任何东西。
- en: It might seem weird that a method *may* or *may not* return a value, but it
    happens all the time in real life.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，方法*可能*返回值，也*可能*不返回值，这似乎有点奇怪，但这种情况经常发生。
- en: Imagine you’re at an ice-cream stand, and you ask for strawberry ice cream.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你站在一个冰淇淋摊前，你要求草莓冰淇淋。
- en: '![image](Images/f0411-02.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0411-02.png)'
- en: Easy, right? But what if they don’t have any strawberry? The ice-cream person
    is likely to tell you “we don’t have that flavor.”
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？但如果他们没有草莓呢？冰淇淋人可能会告诉你“我们没有那种口味。”
- en: '![image](Images/f0411-03.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0411-03.png)'
- en: It’s then up to you what you do next—perhaps order chocolate instead, find another
    ice-cream place, or maybe just go home and sulk about your lack of ice cream.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来就取决于你接下来要做什么——也许是点巧克力，找另一个冰淇淋店，或者只是回家发牢骚，抱怨缺乏冰淇淋。
- en: Imagine trying to do this in the Java world. In the first example, you get an
    ice-cream instance. In the second, you get...a String message? But a message doesn’t
    fit into an ice-cream-shaped variable. A null? But what does null really mean?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 想象在Java世界中尝试做这件事。在第一个例子中，你得到一个冰淇淋实例。在第二个例子中，你得到...一个字符串消息？但是消息不能放入一个冰淇淋形状的变量中。一个null？但null到底意味着什么？
- en: '![image](Images/f0411-04.png)![image](Images/f0411-05.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0411-04.png)![image](Images/f0411-05.png)'
- en: Optional is a wrapper
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Optional是一个包装器。
- en: Since Java 8, the normal way for a method to declare that *sometimes it might
    not return a resu**lt* is to return an **Optional**. This is an object that *wraps*
    the result, so you can ask “Did I get a result? Or is it empty?” Then you can
    make a decision about what to do next.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java 8以来，方法声明*有时可能不返回结果*的常规方式是返回一个**Optional**。这是一个包装对象，所以你可以询问：“我得到了结果吗？还是它是空的？”然后你可以决定接下来要做什么。
- en: '![image](Images/f0412-01.png)![image](Images/f0412-02.png)![image](Images/f0412-03.png)![image](Images/f0413-01.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0412-01.png)![image](Images/f0412-02.png)![image](Images/f0412-03.png)![image](Images/f0413-01.png)'
- en: Yes, but now we have a way to ask if we have a result
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是的，但现在我们有了一种方法来询问是否有结果。
- en: Optional gives us a way to find out about, and deal with, the times when you
    don’t get an ice cream.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Optional为我们提供了一种方法来了解并处理那些你没有得到冰淇淋的时候。
- en: '![image](Images/f0413-02.png)![image](Images/f0413-03.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0413-02.png)![image](Images/f0413-03.png)'
- en: In the past, methods might have thrown Exceptions for this case, or return “null”,
    or a special type of “Not Found” ice-cream instance. Returning an *Optional* from
    a method makes it really clear that anything calling the method ***needs*** to
    check if there’s a result first, and ***then*** make their own decision about
    what to do if there isn’t one.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，方法可能会为这种情况抛出异常，或者返回“null”，或者返回特殊类型的“未找到”冰淇淋实例。从方法返回*Optional*可以非常清楚地表明，调用方法的任何内容***需要***首先检查是否有结果，然后***再***根据需要做出自己的决定。
- en: Don’t forget to talk to the Optional wrapper
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要忘记与Optional包装器交流。
- en: The important thing about Optional results is that **they can be empty**. If
    you don’t check first to see if there’s a value present and the result is empty,
    you will get an exception.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Optional结果的重要一点是**它们可能为空**。如果你不首先检查是否有值存在而结果为空，则会抛出异常。
- en: '![image](Images/f0414-01.png)![image](Images/f0414-02.png)![image](Images/f0414-03.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0414-01.png)![image](Images/f0414-02.png)![image](Images/f0414-03.png)'
- en: The Unexpected Coffee
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意外的咖啡。
- en: '![image](Images/f0415-01.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0415-01.png)'
- en: Alex was programming her mega-ultra-clever (Java-powered) coffee machine to
    give her the types of coffee that suited her best at different times of day.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Alex正在为她的超级聪明（由Java驱动）咖啡机编程，以便在一天中的不同时间给她最适合的咖啡类型。
- en: Five-Minute Mystery
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 五分钟之谜
- en: '![image](Images/f0415-02.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0415-02.png)'
- en: In the afternoons, Alex wanted the machine to give her the weakest coffee it
    had available (she had enough to keep her up at night; she didn’t need caffeine
    adding to her problems!). As an experienced software developer, she knew the Streams
    API would give her the best stream of coffee at the right time.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下午，Alex希望咖啡机为她提供最弱的咖啡（她已经有足够的咖啡让她整夜不眠；她不需要咖啡因增加她的问题！）。作为一名经验丰富的软件开发人员，她知道Streams
    API会在正确的时间给她最好的咖啡流。
- en: 'The coffees would automatically be sorted from the weakest to the strongest
    using natural ordering, so she gave the coffee machine these instructions:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 咖啡会自动按照从最弱到最强的自然顺序进行排序，所以她给了咖啡机这些指令：
- en: '[PRE11]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The very next day, she asked for an afternoon coffee. To her horror, the machine
    presented her with an Americano, not the Decaf Cappuccino she was expecting.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，她要求下午喝咖啡。令她恐惧的是，咖啡机给她提供了一杯美式咖啡，而不是她期望的低因咖啡。
- en: “I can’t drink that!! I’ll be up all night worrying about my latest software
    project!”
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: “我不能喝那个！！我会整夜担心我的最新软件项目！”
- en: '***What happened? Why did the coffee machine give Alex an Americano?***'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？为什么咖啡机给Alex一杯美式咖啡？***'
- en: '![Images](Images/arr1.png) **Answers in [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001).**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在[“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001)中。**'
- en: Pool Puzzle
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/f0416-01.png)![image](Images/f0416-02.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0416-01.png)![图片](Images/f0416-02.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You may ***not*** use the same snippet more than once,
    and you won’t need to use all the snippets. Your ***goal*** is to make a class
    that will compile and run and produce the output listed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***工作***是从池中获取代码片段，并将它们放入代码中的空白行中。你不能***多次***使用相同的片段，也不需要使用所有的片段。你的***目标***是创建一个能够编译、运行并产生列出的输出的类。
- en: '**Output**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![image](Images/f0416-03.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0416-03.png)'
- en: '**Note: each thing from the pool can be used only once!**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：池中的每个元素只能使用一次！**'
- en: '![image](Images/f0416-05.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0416-05.png)'
- en: '[PRE12]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Images](Images/arr1.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_41).**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在[“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_41)中。**'
- en: Mixed Messages
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合信息
- en: (from [“When for loops go wrong”](#when_for_loops_go_wrong))
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“When for loops go wrong”](#when_for_loops_go_wrong))
- en: '![image](Images/f0415-01.png)![image](Images/f0417-01.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0415-01.png)![图片](Images/f0417-01.png)'
- en: Who Does What?
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁做了什么？
- en: (from [“WHO DOES WHAT?”](#brain_barbell-id00200))
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“WHO DOES WHAT?”](#brain_barbell-id00200))
- en: '![image](Images/f0417-02.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0417-02.png)'
- en: Exercise Solutions
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解决方案
- en: Code Magnets
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: (from [“Code Magnets”](#code_magnets-id000004))
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“Code Magnets”](#code_magnets-id000004))
- en: '![image](Images/f0418-01.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-01.png)'
- en: '[PRE13]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![image](Images/f0418-02-01.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-02-01.png)'
- en: BE the Compiler
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为编译器
- en: (from [“BE the Compiler, advanced”](#be_the_compilercomma_advanced-id0001))
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“BE the Compiler, advanced”](#be_the_compilercomma_advanced-id0001))
- en: '![image](Images/f0418-04.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-04.png)'
- en: Sharpen your pencil
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磨尖你的铅笔
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00030))
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“磨尖你的铅笔”](#sharpen_your_pencil-id00030))
- en: '![image](Images/pencil.png)![image](Images/f0419-01.png)![image](Images/f0419-02.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/pencil.png)![图片](Images/f0419-01.png)![图片](Images/f0419-02.png)'
- en: Five-Minute Mystery
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 五分钟之谜
- en: (from [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001))
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001))
- en: '![image](Images/f0419-03.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0419-03.png)'
- en: Alex didn’t pay attention to the order of the stream operations. She first mapped
    the coffee objects to a stream of Strings, and then ordered that. Strings are
    naturally ordered alphabetically, so when the coffee machine got the “first” of
    these results for Alex’s afternoon coffee, it was brewing a fresh “Americano.”
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Alex没有注意流操作的顺序。她首先将咖啡对象映射到一个字符串流，然后对其进行排序。字符串在字母表中自然有序，所以当咖啡机为Alex的下午咖啡获取这些结果中的“第一个”时，它正在冲泡一杯新鲜的“美式咖啡”。
- en: If Alex wanted to order the coffees by strength, with the weakest (1 out of
    5) first, she needed to order the stream of coffees first, before mapping it to
    a String name,
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Alex想按强度对咖啡进行排序，从最弱（5分之1）开始，她需要先对咖啡流进行排序，然后再将其映射为一个字符串名称，
- en: '[PRE14]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then the coffee machine will brew her a decaf instead of an Americano.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然后咖啡机会给她冲一杯低因咖啡而不是美式咖啡。
- en: Pool Puzzle
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泳池难题
- en: (from [“Pool Puzzle”](#pool_puzzle-id00005))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: (from [“泳池难题”](#pool_puzzle-id00005))
- en: '![image](Images/f0415-01.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0415-01.png)'
- en: '[PRE15]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
