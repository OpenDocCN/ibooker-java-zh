- en: Chapter 6\. Java to Kotlin Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Java到Kotlin集合
- en: On the face of it, Java and Kotlin have very similar collections libraries;
    they certainly interoperate suspiciously seamlessly. What are the differences,
    what motivates them, and where do we have to take care as we move from Java to
    Kotlin collections?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乍一看，Java和Kotlin拥有非常相似的集合库；它们确实以非常无缝的方式进行互操作。它们之间有什么区别，是什么促使了这些差异，以及我们在从Java转向Kotlin集合时需要注意什么？
- en: Java Collections
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java集合
- en: In [Chapter 5](ch05.html#beans-to-values) we saw how Java grew up in the days
    when we saw objects as fundamentally stateful and mutable. This was particularly
    true for collections—I mean, what is the point of a list if you can’t add to it?
    We build collections by creating an empty one and adding to it. Need to remove
    an item from a shopping cart? Mutate the list. Shuffle a pack of cards? Obviously
    that changes the order of the deck. We wouldn’t create a new paper to-do list
    every time we need milk or take the cat to the vet. Mutable collections mirror
    our real world experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#beans-to-values)中，我们看到Java在我们将对象视为基本上是有状态和可变的时代成长。这在集合中尤为明显——我的意思是，如果不能向列表中添加东西，那么它的意义何在？我们通过创建一个空的集合并向其中添加项目来构建集合。需要从购物车中移除商品？改变列表。洗牌一副牌？显然这会改变牌组的顺序。每次需要牛奶或带猫去兽医时，我们不会创建新的纸质待办事项列表。可变集合反映了我们的现实世界经验。
- en: On its release, the quality of its built-in collections was a good reason to
    adopt Java. In those days many languages had no resizable collections in their
    standard library. Object technology allowed us to define and use mutable collections
    safely. It was only natural to use this superpower now that it had been given
    to us, so we went ahead and used `Vector` and `HashTable` as Sun intended. Which
    is to say, we created them and then mutated them. There was no choice, because
    all the constructors created empty collections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其发布时，其内置集合的质量是采用Java的一个很好的理由。在那些日子里，许多语言的标准库中没有可调整大小的集合。对象技术使我们能够安全地定义和使用可变集合。现在我们被赋予了这种超能力，自然而然地使用它是理所当然的，所以我们继续使用`Vector`和`HashTable`，如同Sun所期望的那样。也就是说，我们创建它们，然后改变它们。因为所有的构造函数都创建了空集合，所以没有选择。
- en: Java 2 (which was version 1.2 until Java had to compete with C# version numbers)
    introduced a revised collections library. This tidied up the ad hoc `Vector`,
    `Stack`, and `Hashtable` classes and created a common `Collection` interface with
    more useful implementations, including `ArrayList` and `HashSet`. It was now possible
    to create a collection as a copy of another collection. The static `Collections`
    class provided some helpful utility operations, like `sort` and `reverse`. Java
    5 introduced generics, and cleverly retrofitted them to the existing collections,
    so that now we could declare types like `List<Journey>`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java 2（在Java必须与C#版本号竞争之前是版本1.2）引入了修订后的集合库。这清理了临时的`Vector`、`Stack`和`Hashtable`类，并创建了一个通用的`Collection`接口，其中包括更有用的实现，如`ArrayList`和`HashSet`。现在可以将一个集合创建为另一个集合的副本。静态的`Collections`类提供了一些有用的实用操作，如`sort`和`reverse`。Java
    5引入了泛型，并巧妙地将它们改造成了现有的集合，因此现在我们可以声明像`List<Journey>`这样的类型。
- en: The Java collections remained mutable, though—very mutable. Not only are there
    operations to add and remove items, but also operations like sort are defined
    *only* as mutations; there is no standard library function to return a sorted
    copy of a `List`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java集合保持可变性，但非常可变。不仅可以添加和删除项目，还有像排序这样的操作仅被定义为*改变*；没有标准库函数可以返回一个已排序的`List`的副本。
- en: 'As we will keep on saying, mutation is the source of many of our problems with
    complexity, because it allows state in one place to get out of sync with respect
    to state in another. For example, in Travelator we can represent a route as a
    `List` of `Journey`. There is also the concept of a suffer-score: the lower the
    suffer-score, the more pleasant a route is likely to be. Here is how we calculate
    a suffer-score for a route:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一直在说的，变异是我们在复杂性方面许多问题的根源，因为它允许一个地方的状态与另一个地方的状态不同步。例如，在Travelator中，我们可以将路线表示为`Journey`的`List`。还有一个叫做痛苦分数的概念：痛苦分数越低，路线可能越愉快。以下是我们如何为路线计算痛苦分数的方法：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 6.1 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.1&show=diff)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.1 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.1&show=diff)'
- en: 'That `start` local variable doesn’t add much, so we decide to inline it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`start`本地变量没有太多帮助，所以我们决定将其内联：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 6.2 [collections.1:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.2&show=diff)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.2 [collections.1:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.2&show=diff)'
- en: 'Our tests pass, we push to production, but we get bug reports suggesting that
    all is not well. Drilling down we find:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试通过了，我们发布到生产环境，但我们收到了bug报告，表明并非一切顺利。深入分析后我们发现：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 6.3 [collections.0:src/main/java/travelator/Routes.java]](https://java-to-kotlin.dev/code.html?ref=6.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.3&show=diff)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.3 [collections.0:src/main/java/travelator/Routes.java]](https://java-to-kotlin.dev/code.html?ref=6.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.3&show=diff)'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 6.4 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.4&show=diff)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.4 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.4&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO5-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO5-1)'
- en: '`journeys` parameter mutated by `sort`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`改变了`journeys`参数'
- en: Ah, now we can see that finding the longest journeys has changed the apparent
    departure `Location`. A developer called methods on a parameter (`journeys`) to
    solve a problem, and that turned out to break code somewhere else in the system!
    You only have to spend several hundred hours of your life debugging the problems
    caused by [aliasing errors](https://oreil.ly/PeqKs) like this to come to the conclusion
    that immutable data would be a better default. For the JDK developers, this point
    evidently came after the introduction of Java 2, so we have forever been stuck
    with mutable collections interfaces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在我们可以看到，找到最长旅程已经改变了明显的出发`位置`。一个开发者在一个参数(`journeys`)上调用了方法来解决一个问题，结果在系统的其他地方导致了代码的破坏！你只需花费数百个小时来调试由于[别名错误](https://oreil.ly/PeqKs)而引起的问题，就会得出一个结论：不可变数据会是一个更好的默认选择。对于JDK开发者来说，显然是在引入Java
    2之后，我们一直被困在可变集合接口中。
- en: To be fair, although Java’s collections are mutable in theory, they have, over
    the years, become less and less so in practice. Even at the start, it was possible
    to wrap a collection with, for example, `Collections.unmodifiableList`. The result
    is still a `List`; it still has all the mutation methods, but they all throw `UnsupportedOperationException`.
    We could have found out about the problem of `shortestJourneyIn` mutating our
    list by wrapping the result from `loadJourneys` in an `UnmodifiableList`. The
    tests of any code that combined the two would quickly fail, albeit only when run
    as opposed to when compiled. It’s a shame that we cannot depend on the type system
    to ensure correctness, but we can’t go back in time, so this is a pragmatic patch.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，尽管Java的集合理论上是可变的，在实践中多年来变得越来越不可变。即使在最初，也可以用例如`Collections.unmodifiableList`来包装一个集合。结果仍然是一个`List`；它仍然有所有的变异方法，但它们都会抛出`UnsupportedOperationException`。我们本可以通过在`loadJourneys`的结果中包装一个`UnmodifiableList`来发现`shortestJourneyIn`修改我们的列表的问题。任何结合这两者的代码的测试都会很快失败，尽管只有在运行时而不是在编译时才会如此。遗憾的是，我们不能依赖类型系统来确保正确性，但我们不能回到过去，所以这是一个实用的补丁。
- en: Wrapping a list in an `UnmodifiableList` solves the problems of depended-on
    code mutating our collection. If it’s possible for the *original list* to be modified,
    we can still have issues though, because the wrapper reads through to its underlying
    collection. So an `UnmodifiableList` doesn’t guarantee that it never changes,
    just that it cannot be modified through the wrapper. In these cases we have to
    take a defensive copy of the original list if we are to be isolated from changes.
    `List.copyOf(collection)` was added in Java 10 to copy an underlying collection
    as an `AbstractImmutableList`, which is neither modifiable nor subject to changes
    in the original collection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用`UnmodifiableList`包装列表解决了依赖代码修改我们的集合的问题。然而，如果*原始列表*可以被修改，我们仍然可能会遇到问题，因为包装器会透过到其底层集合。因此，`UnmodifiableList`不能保证它永远不变，只是通过包装器无法修改它。在这些情况下，如果我们要与原始集合的变化隔离开来，我们必须对原始列表进行防御性拷贝。Java
    10中添加了`List.copyOf(collection)`来复制一个底层集合作为`AbstractImmutableList`，既不可修改也不受原始集合变化的影响。
- en: All this second-guessing of whether the source or destination of a collection
    is likely to modify it, and taking appropriate action, is tedious and error-prone.
    The problem applies to any mutable data, but changing collections is particularly
    pernicious, because we often derive values (such as `departsFrom`) that can get
    out of date if we change the collection that we extracted them from. Rather than
    taking defensive copies at every function boundary, many teams, your authors’
    included, adopted a simpler and more efficient strategy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在是否修改集合的源或目标的二次猜测，并采取适当的行动，这是令人厌烦且容易出错的。这个问题适用于任何可变数据，但修改集合尤为恶劣，因为我们经常会从中提取出可能会过时的值（例如`departsFrom`）。与其在每个函数边界处采取防御性副本，许多团队，包括本书作者在内，采用了一种更简单和更有效的策略。
- en: This strategy doesn’t stop us from creating mutable collections and populating
    them within a function, but code should only change a collection that it has just
    created. As soon as we return a reference as a result, we should treat it as immutable—*create,
    don’t mutate*. We might occasionally enforce this immutability by wrapping with
    `Collections.unmodifiableList(…)` etc., but in an aligned development team this
    is unnecessary, because no one would treat a shared collection as mutable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略并不阻止我们在函数内创建可变集合并填充它们，但是代码应该只能更改它刚刚创建的集合。一旦我们将引用作为结果返回，我们应该将其视为不可变的 —— *创建，而不是变异*。我们偶尔可能通过包装`Collections.unmodifiableList（…）`等来强制这种不可变性，但在一个配合良好的开发团队中，这是不必要的，因为没有人会将共享集合视为可变的。
- en: There will of course be exceptions to the rule, places where, usually for reasons
    of efficiency, we want to share a collection as a mutable collection. In these
    cases we can get dispensation by naming (`accumulator` is a good start) and by
    limiting the scope of the sharing as much as possible. Within a function is ideal,
    between private methods in a class acceptable, across module boundaries very rarely
    so. [Chapter 14](ch14.html#accumulating-objects-to-transformations) discusses
    ways to avoid (visibly) mutable collections in these situations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，规则总有例外，通常出于效率考虑，我们希望将一个集合作为可变集合共享的情况。在这些情况下，我们可以通过命名（`accumulator`是个不错的开始）和尽可能限制共享的范围来获取特例情况的许可。在函数内部是理想的，类中的私有方法之间是可以接受的，跨模块边界极少这样做。[第14章](ch14.html#accumulating-objects-to-transformations)讨论了如何避免在这些情况下（显然）使用可变集合。
- en: Project teams that adopt this convention can produce simple and reliable software
    in spite of collections’ mutability. On the whole, the benefits of treating collections
    as immutable outweigh the problems of a type system that is lying to you, because
    values are just so valuable. The JVM’s libraries may hark back to the days when
    mutability was the norm, but this is a case where the grain of Java is shifting
    to the immutable, and it’s better to be ahead of this change than behind it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种约定的项目团队可以生成简单且可靠的软件，尽管集合是可变的。总体而言，将集合视为不可变的好处超过了类型系统欺骗你的问题，因为值实在是太宝贵了。虽然JVM的库可能仍然依赖于可变性是正常的，但这是一个Java正在向不可变性转变的案例，领先于这种变化要比落后于它要好。
- en: Kotlin Collections
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin集合
- en: In contrast to Java, Kotlin and its standard library were designed in an age
    when mutability had fallen out of fashion. However, smooth interoperation with
    Java was a key goal, and Java has mutable collections. Scala had tried introducing
    its own sophisticated persistent (immutable but data-sharing) collections, but
    this forced developers to copy information between collections on the interop
    boundary, which was both inefficient and annoying. How could Kotlin square the
    circle and have immutable collections interoperate seamlessly with Java?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相比，Kotlin及其标准库是在可变性已经过时的时代设计的。然而，与Java的平稳互操作性是一个关键目标，而Java有可变集合。Scala曾试图引入其自己的复杂持久（不可变但数据共享）集合，但这迫使开发人员在互操作边界上在集合之间复制信息，这既低效又令人讨厌。Kotlin如何圆满解决这一难题，并使不可变集合与Java无缝互操作呢？
- en: The Kotlin developers removed the mutation methods from the Jave collections
    interfaces and published them in the `kotlin.collections` package as `Collection<E>`,
    `List<E>`, and so on. These were then extended by `MutableCollection<E>`, `Mutable​L⁠ist<E>`,
    etc., which add back in the Java mutation methods. So in Kotlin we have `MutableList`,
    which is a subtype of `List`, which is a subtype of `Collection`. `MutableList`
    also implements `MutableCollection`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 开发人员从 Java 集合接口中移除了变异方法，并将它们发布在 `kotlin.collections` 包中，例如 `Collection<E>`、`List<E>`
    等。然后，这些接口被 `MutableCollection<E>`、`MutableList<E>` 等扩展，添加了 Java 的变异方法。因此，在 Kotlin
    中，我们有 `MutableList`，它是 `List` 的子类型，`List` 是 `Collection` 的子类型。`MutableList` 还实现了
    `MutableCollection`。
- en: On the face of it, this is a simple scheme. Mutable collections have the same
    operations as collections that are not mutable, plus the mutation methods. It
    is safe to pass a `MutableList` as an argument to code that expects a `List`,
    because all the `List` methods will be present and can be invoked. In terms of
    the [Liskov Substitution Principle](https://oreil.ly/8A8KO), we can substitute
    a `MutableList` for a `List` without affecting our program correctness.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这是一个简单的方案。可变集合与非可变集合具有相同的操作，再加上变异方法。将`MutableList`作为期望`List`的参数传递是安全的，因为所有`List`方法都将存在并可调用。按照[里斯科夫替换原则](https://oreil.ly/8A8KO)，我们可以用`MutableList`替换`List`而不影响程序的正确性。
- en: 'A little compiler magic allows Kotlin code to accept a `java.util.List` as
    a `kotlin.​col⁠lections.List`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一点编译器魔法允许 Kotlin 代码接受 `java.util.List` 作为 `kotlin.collections.List`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That magic also allows Kotlin to accept the Java `List` as a `kotlin.collections.​Muta⁠bleList`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种魔法也使得 Kotlin 可以将 Java 的 `List` 接受为 `kotlin.collections.MutableList`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In fact, because the Java `List` is actually mutable here, we could (but almost
    always shouldn’t) downcast to Kotlin’s `MutableList` and mutate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，因为 Java 的 `List` 在这里实际上是可变的，我们可以（但几乎总是不应该）向下转换为 Kotlin 的 `MutableList` 并进行变异：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the other direction, the compiler will allow both a `kotlin.collections.MutableList`
    and a `kotlin.collections.List` where a `java.util.List` is needed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，编译器将允许在需要 `java.util.List` 的地方同时接受 `kotlin.collections.MutableList` 和 `kotlin.collections.List`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At face value, so far everything has been very plausible. Unfortunately, when
    it comes to mutability, there is more to substitution than Barbara Liskov’s principle.
    As we saw in [“Java Collections”](#java-collections), just because we can’t see
    mutators on our reference of type `kotlin.collections.List`, it doesn’t mean that
    the contents cannot change. The actual type could be a `java.util.List`, which
    *is* mutable. In some ways it’s worse in Kotlin, because we can convert a `MutableList`
    to a `List` in passing:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，到目前为止一切都非常合理。不幸的是，当涉及到可变性时，替换比巴巴拉·里斯科夫的原则更复杂。正如我们在[“Java 集合”](#java-collections)中看到的，仅因为我们在类型为
    `kotlin.collections.List` 的引用上看不到变异器，这并不意味着内容不能改变。实际类型可能是可变的 `java.util.List`。在某些方面，这在
    Kotlin 中更糟，因为我们可以将 `MutableList` 转换为传递的 `List`：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s say that we accept a `List<String>` somewhere, and take its immutabilty
    at face value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们在某处接受了一个`List<String>`，并且对其不可变性深信不疑：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Everything seems fine:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很正常：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But wait, don’t we still have a reference to a `MutableList`?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们还保留着对 `MutableList` 的引用吗？
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_introduction_CO6-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO6-1)'
- en: '`Expected "0", actual "banana"`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`期望 "0"，实际 "banana"`'
- en: '`AValueType` turns out to be mutable after all! Because of this, `first`, which
    is initialized on construction, can get out of date. Having nonmutable collections
    interfaces has not resulted in immutable collections!'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`AValueType`原来毕竟是可变的！因此，初始化时的`first`可能会过时。拥有非可变集合接口并未导致不可变集合！'
- en: Immutable, Read-Only, Mutable
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变、只读、可变
- en: The official line is that a nonmutable Kotlin collection is not *immutable*,
    but rather a *read-only view* of a collection. As with the Java `UnmodifiableList`,
    a read-only collection can’t be changed through its interface, but may be changed
    through some other mechanism. Only true *immutable* collections are guaranteed
    never to change.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 官方说法是，非可变 Kotlin 集合不是*不可变*的，而是集合的*只读视图*。与 Java 的 `UnmodifiableList` 一样，只读集合不能通过其接口更改，但可能通过其他机制更改。只有真正的*不可变*集合才能保证永远不会更改。
- en: It is possible to have true immutable collections on the JVM, (the result of
    `java.util.List.of(...)`, for example), but this is not (yet) a standard Kotlin
    feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 上可能存在真正的不可变集合（例如 `java.util.List.of(...)` 的结果），但这（尚）不是 Kotlin 的标准功能。
- en: This is the unfortunate consequence of having your mutable collections extend
    your otherwise nonmutable collections; the recipient of a nonmutable collection
    cannot modify it, but cannot know that it won’t change, because a reference of
    type nonmutable `List` may in fact be pointing to an object of type `MutableList`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将可变集合扩展到否则不可变集合的不幸后果；接收非可变集合的接收者不能修改它，但不能知道它不会改变，因为类型为非可变 `List` 的引用实际上可能指向类型为
    `MutableList` 的对象。
- en: The rigorous solution to this problem is to separate mutable from immutable
    collections by not having a subtype relationship. In this scheme, if we have a
    mutable list and want an immutable copy of it, we have to copy the data. A good
    analogy is a `StringBuilder`. This is effectively a mutable `String`, but is not
    a subtype of `String`. Once we have a result we want to publish, we need to call
    `.toString()`, and subsequent modifications to the `StringBuilder` will not affect
    previous results. Both Clojure and Scala adopted this builder approach for their
    mutable collections—why doesn’t Kotlin?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的严格解决方案是通过不具有子类型关系来将可变和不可变集合分离。在这种方案中，如果我们有一个可变列表并希望得到其不可变副本，我们必须复制数据。一个很好的类比是
    `StringBuilder`。这实际上是一个可变的 `String`，但不是 `String` 的子类型。一旦我们有了想要发布的结果，我们需要调用 `.toString()`，并且对
    `StringBuilder` 的后续修改不会影响先前的结果。Clojure 和 Scala 都采用了这种构建器方法来处理他们的可变集合 —— 为什么 Kotlin
    没有？
- en: 'We suspect that the answer is: because the Kotlin designers, like your authors,
    had adopted the convention described in [“Don’t Mutate Shared Collections”](#dont-mutate-shared-collections).
    If you treat any collection received as a parameter, returned as a result, or
    otherwise shared between code as immutable, then having mutable collections extend
    nonmutable collections turns out to be quite safe. Admittedly *quite* in the sense
    of *mainly*, rather than *completely*, but still the benefits outweigh the costs.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怀疑答案是：因为 Kotlin 的设计者，像您的作者一样，已采纳了 [“不要改变共享集合”](#dont-mutate-shared-collections)
    中描述的惯例。如果将任何作为参数接收、作为结果返回或以其他方式在代码之间共享的集合视为不可变，则使可变集合扩展非可变集合实际上是相当安全的。诚然在“相当”的意义上，而不是完全的，但仍然是收益大于成本的。
- en: The Kotlin collections make this scheme even more powerful. In Java, we have
    the situation where we can, in theory, mutate any collections, so the type system
    doesn’t tell us when this is safe or otherwise. In Kotlin, if we declare all normal
    references as the nonmutable versions, we can use a `MutableCollection` to document
    when we do, in fact, consider that the collection is subject to change. In return
    for accepting a largely theoretical risk, we reap the rewards of very simple and
    efficient interoperation with Java. Pragmatism is typical of the grain of Kotlin;
    in this case it might be expressed as “be as safe as is sensible, but no safer.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 集合使得这一方案更加强大。在 Java 中，我们面临的情况是，理论上可以改变任何集合，因此类型系统无法告诉我们何时是安全的或其他情况。在
    Kotlin 中，如果我们将所有普通引用声明为不可变版本，我们可以使用一个 `MutableCollection` 来记录我们实际上认为集合是可变的时候。尽管接受了在很大程度上是理论风险的条件下，我们通过与
    Java 的非常简单和高效的互操作性获得了回报。实用主义是 Kotlin 的特点之一；在这种情况下，可以表达为“尽可能安全，但不要过度安全。”
- en: 'We said that another way to express the “Don’t Mutate Shared Collections” is
    that our code should only mutate a collection that it has just created. We see
    this in action if we look into the Kotlin standard library. Here, for example,
    is (a simplified version of) the definition of `map`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说另一种表达“不要改变共享集合”的方式是，我们的代码只应该改变它刚刚创建的集合。如果我们查看 Kotlin 标准库，我们可以看到这一点。例如，这里是
    `map` 的（简化版本的）定义：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here the list is built in place by mutation and then returned as read-only.
    This is simple *and* efficient. Technically, we *could* downcast the result to
    `MutableList` and change the result, but we shouldn’t. Instead, we should take
    the result type at face value. That way, any code sharing this collection will
    not have to worry about it changing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的列表通过变异就地构建，然后作为只读返回。这既简单又高效。从技术上讲，我们*可以*将结果向下转型为 `MutableList` 并更改结果，但我们不应该这样做。相反，我们应该接受结果类型的表面价值。这样，任何使用此集合的代码都不必担心它会更改。
- en: Refactoring from Java to Kotlin Collections
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Java 转换到 Kotlin 集合
- en: Because of the smooth interop between Java and Kotlin collections described
    earlier, converting code with collections is usually seamless, at least at the
    syntactic level. If our Java code relies on mutating collections, though, we may
    have to take extra care to avoid ending up breaking invariants in Kotlin.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于早期描述的 Java 和 Kotlin 集合之间的平滑互操作，使用集合转换代码通常是无缝的，至少在语法层面上是这样的。但是，如果我们的 Java 代码依赖于对集合的变异，我们可能需要特别小心，以避免在
    Kotlin 中破坏不变式。
- en: A good approach is to refactor your Java code to the convention used in [“Don’t
    Mutate Shared Collections”](#dont-mutate-shared-collections) before converting
    it to Kotlin. That’s what we’ll do here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的方法是在将 Java 代码转换为 Kotlin 之前，将其重构为[“不要改变共享集合”](#dont-mutate-shared-collections)中使用的约定。这就是我们在这里要做的。
- en: Fix Up the Java
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复 Java
- en: 'Let’s have a look at the code from Travelator we saw earlier. The static methods
    we’ve been looking at are in a class called `Suffering`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看一下我们之前在 Travelator 中看到的代码。我们一直在看的静态方法位于名为 `Suffering` 的类中：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 6.5 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.5&show=diff)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.5 [collections.0:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.5&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.5&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO7-1)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO7-1)'
- en: '`longestJourneysIn` breaks our rule by mutating its parameter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`longestJourneysIn` 通过改变其参数来违反我们的规则。'
- en: As we saw previously, because `longestJourneysIn` mutates its parameter, we
    can’t change the order of evaluation of `getDepartsFrom`, and `longestJourneysIn`
    in `sufferScoreFor`. Before we can fix this, we have to be sure that no other
    code depends on this mutation. This can be hard, which is itself a good reason
    not to allow modifying collections from the outset. If we have confidence in our
    tests, we can try making the edit and seeing whether anything breaks. Otherwise,
    we may have to add tests and/or reason with our code and dependency analysis.
    Let’s decide that it’s safe to go ahead and make the change in Travelator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，因为 `longestJourneysIn` 改变了其参数，所以我们无法改变 `sufferScoreFor` 中 `getDepartsFrom`
    和 `longestJourneysIn` 的评估顺序。在我们修复此问题之前，我们必须确保没有其他代码依赖于此变异。这可能很困难，这本身就是不允许从一开始修改集合的一个很好的理由。如果我们对测试有信心，我们可以尝试进行编辑并查看是否会有任何问题。否则，我们可能需要添加测试和/或使用我们的代码和依赖性分析进行推理。让我们决定在
    Travelator 中继续进行更改是安全的。
- en: 'We don’t want to sort the collection in place, so we need a function that returns
    a sorted copy of a list without modifying the original. Even Java 16 doesn’t seem
    to have a function to do this. Curiously, `List.sort` actually creates a sorted
    version of itself and then mutates itself to match:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想就地对集合进行排序，因此我们需要一个函数，该函数返回一个已排序的列表的副本，而不修改原始列表。即使在 Java 16 中似乎也没有这样的功能。耐人寻味的是，`List.sort`
    实际上会创建其自身的已排序版本，然后使自身变异以匹配：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This just goes to show how mutable thinking was the grain of Java, back in
    the Java 8 days when this was written. There is now `Stream.sorted`, but in our
    experience streams rarely perform well with small collections (see [Chapter 13](ch13.html#streams-to-sequences)).
    Maybe we shouldn’t care about performance, but we can’t help ourselves! We justify
    our indulgence by reasoning that we know of several places in the code that currently
    sort in place, so will have to be changed to remove the mutation of shared collections.
    Reasoning that the authors of `List.sort` actually knew a thing or two about Java
    efficiency, we copy their code and write:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这正显示了在编写本文时的 Java 8 时代，Java 的思维方式是多么易变。现在有了 `Stream.sorted`，但根据我们的经验，流很少在处理小集合时表现良好（参见[第
    13 章](ch13.html#streams-to-sequences)）。也许我们不应该关心性能，但我们无法自制！我们通过推理来为自己的放纵辩护，即我们知道代码中有几个地方目前正在就地排序，因此必须更改以删除共享集合的变异。通过推理，`List.sort`
    的作者实际上对 Java 的效率知道一些，我们复制他们的代码并写下：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 6.6 [collections.3:src/main/java/travelator/Collections.java]](https://java-to-kotlin.dev/code.html?ref=6.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.6&show=diff)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.6 [collections.3:src/main/java/travelator/Collections.java]](https://java-to-kotlin.dev/code.html?ref=6.6&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.6&show=diff)'
- en: Before we go on, it’s worth considering how we can be confident that this code
    is correct. Because of mutation, it’s really quite hard. We have to be sure that
    `Arrays.sort` won’t affect the input collection, which means checking the documentation
    for `Collection.toArray`. When we do, we find the magic words “The caller is thus
    free to modify the returned array,” so that’s OK; we’ve decoupled the input from
    the output. This function is a classic example of accepting mutation in the scope
    where we create a collection, but not outside—create, don’t mutate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，值得考虑的是我们如何确保这段代码是正确的。因为变异的原因，这确实相当困难。我们必须确保 `Arrays.sort` 不会影响输入集合，这意味着需要检查
    `Collection.toArray` 的文档。当我们这样做时，我们找到了魔法词语“调用者因此可以自由修改返回的数组”，所以没问题；我们已经将输入与输出解耦了。这个函数是接受变异在我们创建集合的作用域内部的经典示例，但在外部则不是——创建，而不是变异。
- en: While we’re pulling this thread, what are we returning, and is it mutable? `Arrays.​as⁠L⁠ist`
    returns an `ArrayList`, but not the standard one. This one is private inside `Arrays`
    and writes through to our `result`. Because it is backed by an array, though,
    we cannot add or remove items. It isn’t resizable. It turns out that Java collections
    aren’t just mutable, nonmutable, or immutable; they are sometimes mutable provided
    that we don’t change their structure! None of these distinctions are reflected
    in the type system, so it is possible to make type-preserving changes that break
    at runtime, depending on which code path yields a collection that we subsequently
    try to modify, and how we try to modify it. This is yet another reason to sidestep
    the issue altogether and just never modify a shared collection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入探讨的时候，我们需要知道我们返回什么，以及它是否可变。`Arrays.asList` 返回一个 `ArrayList`，但不是标准的 `ArrayList`。这个
    `ArrayList` 是 `Arrays` 内部私有的，并且会直接写入我们的 `result`。由于它由数组支持，所以我们不能添加或移除项。它是不可调整大小的。事实证明，Java
    集合不仅仅是可变、不可变或不可修改的；它们有时是可变的，只要我们不改变它们的结构！这些区别都没有在类型系统中反映出来，因此可能会进行类型保持的更改，这些更改在运行时根据代码路径和我们尝试修改的方式而定，可能会导致我们尝试修改的集合在运行时中断。这正是为什么我们应该尽量避开这个问题，并且永远不要修改共享集合的另一个原因。
- en: Returning to our refactoring, we can use our new `sorted` in `longestJourneysIn`
    to stop modifying the shared collection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的重构，我们可以在 `longestJourneysIn` 中使用我们的新 `sorted` 来停止修改共享集合。
- en: 'Using `sort`, we had:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sort`，我们有：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 6.7 [collections.2:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.7&show=diff)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.7 [collections.2:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.7&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.7&show=diff)'
- en: 'Our new `sorted` function allows us to write:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 `sorted` 函数允许我们编写：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 6.8 [collections.3:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.8&show=diff)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.8 [collections.3:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.8&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.8&show=diff)'
- en: 'Now that `sufferScoreFor` won’t be subject to the side effect in `longestJourneysIn`,
    we can inline its local variables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `sufferScoreFor` 不再受 `longestJourneysIn` 中副作用的影响，我们可以内联其局部变量：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 6.9 [collections.4:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.9&show=diff)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.9 [collections.4:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.9&show=diff)'
- en: Inlining local variables might not seem much of a payoff, but it’s a small example
    of a bigger theme. In [Chapter 7](ch07.html#actions-to-calculations), we’ll look
    at how avoiding mutation allows us to refactor code in ways that just aren’t safe
    otherwise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 内联局部变量可能看起来并没有太多好处，但这是一个更大主题的小例子。在[第7章](ch07.html#actions-to-calculations)中，我们将看看如何通过避免变异以不安全的方式重构代码。
- en: 'Stepping out to look at the callers of `sufferScoreFor`, we find:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 离开来看看 `sufferScoreFor` 的调用者时，我们发现：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 6.10 [collections.4:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.10&show=diff)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.10 [collections.4:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=6.10&show=diff)'
- en: 'Hmmm, that’s so pathologically mutating that it might have been written as
    an example in a book! At least `removeUnbearableRoutes` is telling us that it
    must mutate something by returning `void`. We can take baby steps by changing
    the function to return the parameter it is mutating and using the result—another
    case of making something worse before making it better:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这太病态突变了，可能写成了书中的例子！至少 `removeUnbearableRoutes` 告诉我们它必须通过返回 `void` 来突变某些东西。我们可以通过将函数更改为返回它正在突变的参数并使用结果来采取小步骤，以此来使事情变得更糟然后再变得更好：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 6.11 [collections.5:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.11&show=diff)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.11 [collections.5:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.11&show=diff)'
- en: 'This time we’ll use `Stream.filter` to replace the mutation in `removeUnbearableRoutes`.
    In passing, we can take the opportunity to rename it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将使用 `Stream.filter` 来替换 `removeUnbearableRoutes` 中的突变。顺便说一句，我们可以借此机会将其重命名为：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 6.12 [collections.6:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.12&show=diff)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.12 [collections.6:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.12&show=diff)'
- en: Note how it is now easier to find a nice short name for our function; `removeUnbearableRoutes`
    becomes `bearable`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在更容易找到一个好的简短名称来命名我们的函数；`removeUnbearableRoutes` 变成了 `bearable`。
- en: 'The reassignment to `routes` in `routesToShowFor` is ugly, but deliberate,
    because it allows us to draw parallels with the refactor in [Chapter 5](ch05.html#beans-to-values).
    There, we changed mutating-some-data-in-place to replacing-the-reference-with-a-mutated-value,
    and that is what we have done here too. Of course, we don’t need the local variable
    at all really, so let’s get rid of it. Invoking the Inline refactoring twice does
    it nicely:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`routesToShowFor` 中对 `routes` 的重新赋值看起来很丑，但是却是故意的，因为它允许我们与 [第 5 章](ch05.html#beans-to-values)
    中的重构进行对比。在那里，我们将原地突变数据更改为用突变后的值替换引用，这也是我们在这里所做的。当然，我们真的不需要局部变量，所以让我们完全摆脱它。连续两次调用内联重构就可以很好地完成：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 6.13 [collections.7:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.13&show=diff)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.13 [collections.7:src/main/java/travelator/Suffering.java]](https://java-to-kotlin.dev/code.html?ref=6.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.13&show=diff)'
- en: Convert to Kotlin
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为 Kotlin
- en: 'Now that we’ve removed all the mutation from our Java collections, it’s time
    to convert to Kotlin. “Convert Java File to Kotlin File” on our `Suffering` class
    does a reasonable job, but when we wrote this, it got confused, inferring the
    nullability of collections and their generic types. After conversion, we had to
    remove `?`s from some hairy types like `List<List<Journey?>>?` to have:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从我们的 Java 集合中移除了所有的突变，是时候转换为 Kotlin 了。在我们的 `Suffering` 类上，“将 Java 文件转换为
    Kotlin 文件”做得相当不错，但是当我们编写这个时，它会混淆，推断集合及其泛型类型的可空性。转换后，我们不得不从一些复杂的类型中去除 `?`，比如 `List<List<Journey?>>?`，以得到：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 6.14 [collections.8:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.14&show=diff)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.14 [collections.8:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.14&show=diff)'
- en: 'We have also reformatted and tidied some imports. On the plus side, the Java
    code calling our Kotlin hasn’t had to change. Here, for example, is a test passing
    a plain Java `List` to the Kotlin `longestJourneyIn`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还重新格式化并整理了一些导入。正面的是，调用我们的 Kotlin 的 Java 代码没有变化。例如，在这里，测试将普通的 Java `List` 传递给
    Kotlin `longestJourneyIn`：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 6.15 [collections.8:src/test/java/travelator/LongestJourneyInTests.java]](https://java-to-kotlin.dev/code.html?ref=6.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.15&show=diff)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6.15 [collections.8:src/test/java/travelator/LongestJourneyInTests.java]](https://java-to-kotlin.dev/code.html?ref=6.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.15&show=diff)'
- en: 'Returning to the Kotlin, we can now take advantage of the many utilities available
    on Kotlin collections to simplify the code. Take `longestJourneysIn`, for example.
    This was:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Kotlin，我们现在可以利用 Kotlin 集合上提供的许多实用程序来简化代码。例如，`longestJourneysIn` 是这样的：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 6.16 [collections.8:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.16&show=diff)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.16【collections.8:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.16&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.16&show=diff)）'
- en: 'Replacing `sorted` with `sortedByDescending`, and `subList` with `take` gives:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 用`sortedByDescending`替换`sorted`，用`take`替换`subList`得到：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 6.17 [collections.9:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.17&show=diff)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.17【collections.9:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.17&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.17&show=diff)）'
- en: 'Now if we convert `longestJourneysIn` to an extension function (see [Chapter 10](ch10.html#functions-to-extension-functions)),
    we can simplify its name to `longestJourneys`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们将`longestJourneysIn`转换为扩展函数（参见[第10章](ch10.html#functions-to-extension-functions)），我们可以将其名称简化为`longestJourneys`：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 6.18 [collections.10:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.18&show=diff)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.18【collections.10:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.18&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.18&show=diff)）'
- en: 'Because `longestJourneys` doesn’t modify its parameter, we’ve made it a single-expression
    function ([Chapter 9](ch09.html#multi-to-single-expression-functions)). It can
    still be called from Java as a static method, but reads particularly nicely when
    called from Kotlin, especially if we name the argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`longestJourneys`不修改其参数，所以我们把它变成了单表达式函数（[第9章](ch09.html#multi-to-single-expression-functions)）。它仍然可以从Java中调用作为静态方法，但从Kotlin中调用时特别流畅，尤其是如果我们给参数命名：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 6.19 [collections.10:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.19&show=diff)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.19【collections.10:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.19&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.19&show=diff)）'
- en: '[![1](assets/1.png)](#co_introduction_CO8-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO8-1)'
- en: Named argument
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Moving on to `bearable`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论`bearable`：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 6.20 [collections.10:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.20&show=diff)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.20【collections.10:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.20&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.20&show=diff)）'
- en: 'Here we can use the techniques in [Chapter 13](ch13.html#streams-to-sequences)
    to convert the `Stream` to Kotlin. We remove the call to `.stream()` as Kotlin
    makes `filter` available as an extension function on `List`. Then we don’t need
    the terminal `toUnmodifiableList`, because Kotlin `filter` returns a `List` directly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用[第13章](ch13.html#streams-to-sequences)中的技术将`Stream`转换为Kotlin。我们删除对`.stream()`的调用，因为Kotlin在`List`上作为扩展函数提供了`filter`。然后我们不需要终端的`toUnmodifiableList`，因为Kotlin的`filter`直接返回一个`List`：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 6.21 [collections.11:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.21&show=diff)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.21【collections.11:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.21&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.21&show=diff)）'
- en: Interestingly, this is a place where the result is potentially more mutable
    than our Java was. In Java, we were collecting with `Collectors.toUnmodifiableList()`.
    Kotlin `filter` declares its return type as `List` (the read-only view), but the
    actual runtime type is the mutable `ArrayList`. Provided we never downcast, this
    shouldn’t be an issue, especially because we are now treating our shared collections
    as immutable even in Java.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个地方的结果潜在的更易变动，比我们的Java在这方面更多。在Java中，我们使用`Collectors.toUnmodifiableList()`进行收集。Kotlin的`filter`声明其返回类型为`List`（只读视图），但实际运行时类型为可变的`ArrayList`。只要我们不向下转型，这应该不是问题，特别是因为我们现在即使在Java中也将我们的共享集合视为不可变的。
- en: 'Here then is the final code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是最终的代码：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 6.22 [collections.11:src/main/java/travelator/Suffering.kt]](https://java-to-kotlin.dev/code.html?ref=6.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=6.22&show=diff)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6.22【collections.11:src/main/java/travelator/Suffering.kt】](https://java-to-kotlin.dev/code.html?ref=6.22&show=file)（[差异](https://java-to-kotlin.dev/code.html?ref=6.22&show=diff)）'
- en: We say final, but in practice we probably wouldn’t finish this refactoring at
    this point. Those `List<List<Journey>>` types are hinting at some type trying
    to get out, and in Kotlin we don’t usually publish static methods in an object
    like this; we prefer top-level function definitions. [Chapter 8](ch08.html#static-methods-to-top-level-functions)
    will fix the latter at least.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说最终的，但实际上在这一点上我们可能不会完成这个重构。那些`List<List<Journey>>`类型暗示着一些类型试图脱颖而出，在Kotlin中，我们通常不会像这样在对象中发布静态方法；我们更喜欢顶层函数定义。[第8章](ch08.html#static-methods-to-top-level-functions)至少会解决后者。
- en: Moving On
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前行
- en: Java at one time favored programming with mutability. That has fallen out of
    vogue, but more by convention than by enforcement. Kotlin has taken a very pragmatic
    approach to mutability in its collections, giving smooth operation and a simple
    programming model, but only where your Java conventions align with its approach.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，Java更倾向于使用可变性进行编程。这已经不再流行，但更多是基于约定而非强制。Kotlin在其集合中采取了非常实用的可变性方法，提供了流畅的操作和简单的编程模型，但仅在Java的约定与其方法一致的情况下。
- en: 'To help your Java and Kotlin interoperate smoothly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助Java和Kotlin之间的平滑互操作：
- en: Beware that Java can mutate a collection that it has passed to Kotlin.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，Java可以修改传递给Kotlin的集合。
- en: Beware that Java can (at least try to) mutate a collection that it has received
    from Kotlin.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，Java可以（至少试图）修改从Kotlin接收到的集合。
- en: Remove mutation from your use of Java collections. Where you can’t, take defensive
    copies.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你对Java集合的使用中去除变异。无法去除变异时，请采用防御性拷贝。
- en: We have more to say about collections in [Chapter 15, *Encapsulated Collections
    to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases). In terms
    of this code example, [Chapter 8, *Static Methods to Top-Level Functions*](ch08.html#static-methods-to-top-level-functions),
    continues where this chapter leaves off.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第15章，*封装集合到类型别名*](ch15.html#encapsulated-collections-to-typealiases)中对集合有更多的阐述。在这段代码示例中，[第8章，*静态方法到顶层函数*](ch08.html#static-methods-to-top-level-functions)继续了这一章节的内容。
