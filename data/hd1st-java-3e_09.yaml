- en: 'Chapter 7\. Better Living in Objectville: Inheritance and Polymorphism'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 在Objectville中过上更好的生活：继承和多态
- en: '![image](Images/f0167-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0167-01.png)'
- en: '**Plan your programs with the future in mind.** If there were a way to write
    Java code such that you could take more vacations, how much would it be worth
    to you? What if you could write code that someone *else* could extend, **easily**?
    And if you could write code that was flexible, for those pesky last-minute spec
    changes, would that be something you’d be interested in? Then this is your lucky
    day. For just three easy payments of 60 minutes time, you can have all this. When
    you get on the Polymorphism Plan, you’ll learn the 5 steps to better class design,
    the 3 tricks to polymorphism, the 8 ways to make flexible code, and if you act
    now—a bonus lesson on the 4 tips for exploiting inheritance. Don’t delay, an offer
    this good will give you the design freedom and programming flexibility you deserve.
    It’s quick, it’s easy, and it’s available now. Start today, and we’ll throw in
    an extra level of abstraction!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**为未来规划您的程序。** 如果有一种方法可以编写Java代码，让您可以更多地度假，那对您来说价值多少？如果您可以编写其他人*可以轻松扩展*的代码呢？如果您可以编写灵活的代码，以应对那些令人讨厌的临时规范更改，这是否是您感兴趣的？那么今天是您的幸运日。只需轻松的三次60分钟的时间投入，您就可以拥有这一切。当您加入多态计划时，您将学会5步更好的类设计，3个多态技巧，8种编写灵活代码的方法，如果您现在行动——还有一个额外的关于利用继承的4个技巧的奖励课程。不要拖延，这么好的优惠将为您提供您应得的设计自由和编程灵活性。快速，简单，现在就可以获得。今天开始，我们将为您额外增加一个抽象层次！'
- en: Chair Wars Revisited...
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 椅子之战重温……
- en: '***Remember way back in [Chapter 2](ch02.xhtml#a_trip_to_objectville_classes_and_object),
    when Laura (procedural programmer) and Brad (OO developer) were vying for the
    Aeron chair? Let’s look at a few pieces of that story to review the basics of
    inheritance.***'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '***还记得在[第2章](ch02.xhtml#a_trip_to_objectville_classes_and_object)里，当劳拉（过程式程序员）和布拉德（面向对象开发者）为Aeron椅子争斗的时候吗？让我们回顾一下那个故事的几个片段，复习继承的基础知识。***'
- en: '**LAURA:** You’ve got duplicated code! The rotate procedure is in all four
    Shape things. It’s a stupid design. You have to maintain four different rotate
    “methods.” How can that ever be good?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '-   **LAURA:** 你有重复的代码！旋转过程在所有四个形状中都有。这是一个愚蠢的设计。你必须维护四个不同的旋转“方法”。这样的设计怎么能好？'
- en: '**BRAD:** Oh, I guess you didn’t see the final design. Let me show you how
    OO **inheritance** works, Laura.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**BRAD:** 哦，我猜你还没看到最终的设计。让我展示一下面向对象的**继承**是如何工作的，劳拉。'
- en: '![image](Images/f0168-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0168-01.png)'
- en: You can read this as **“Square inherits from Shape”, “Circle inherits from Shape”**
    and so on. I removed rotate() and playSound() from the other shapes, so now there’s
    only one copy to maintain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它理解为**“Square继承自Shape”，“Circle继承自Shape”**等等。我从其他形状中移除了rotate()和playSound()，现在只需维护一个副本。
- en: The Shape class is called the **superclass** of the other four classes. The
    other four are the **subclasses** of Shape. The subclasses inherit the methods
    of the superclass. In other words, *if the Shape class has the functionality,
    then the subclasses automatically get that same functionality.*
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Shape类被称为其他四个类的**超类**。其他四个是Shape的**子类**。子类继承超类的方法。换句话说，*如果Shape类具有功能，则子类自动获取相同的功能。*
- en: What about the Amoeba rotate()?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阿米巴的rotate()呢？
- en: '![image](Images/f0169-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0169-01.png)'
- en: '**LAURA:** Wasn’t that the whole problem here—that the Amoeba shape had a completely
    different rotate and playSound procedure?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAURA:** 这不正是问题的关键吗——阿米巴形状有完全不同的rotate和playSound过程？'
- en: How can Amoeba do something different if it *inherits* its functionality from
    the Shape class?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果阿米巴从Shape类*继承*其功能，它如何执行不同的操作呢？
- en: '**BRAD:** That’s the last step. The Amoeba class ***overrides*** any methods
    of the Shape class that need specific amoeba behavior. Then at runtime, the JVM
    knows exactly which rotate() method to run when someone tells the Amoeba to rotate.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**BRAD:** 这是最后一步。Amoeba类***覆盖***了Shape类需要特定的阿米巴行为的任何方法。然后在运行时，JVM知道当有人告诉Amoeba旋转时应该运行哪个rotate()方法。'
- en: '![image](Images/f0169-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0169-02.png)'
- en: Understanding Inheritance
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: When you design with inheritance, you put common code in a class and then tell
    other more specific classes that the common (more abstract) class is their superclass.
    When one class inherits from another, **the subclass inherits from the superclass.**
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用继承进行设计时，您将通用代码放入一个类中，然后告诉其他更具体的类通用（更抽象）类是它们的超类。当一个类从另一个类继承时，**子类从超类继承。**
- en: In Java, we say that the **subclass *extends* the superclass**. An inheritance
    relationship means that the subclass inherits the **members** of the superclass.
    When we say “members of a class,” we mean the instance variables and methods.
    For example if PantherMan is a subclass of SuperHero, the PantherMan class automatically
    inherits the instance variables and methods common to all superheroes including
    `suit, tights, specialPower, useSpecialPower()`, and so on. But the PantherMan
    **subclass can add new methods and instance variables of its own, and it can override
    the methods it inherits from the superclass** SuperHero.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们说子类 *extends* 父类。继承关系意味着子类继承了父类的成员，包括实例变量和方法。例如，如果 PantherMan 是 SuperHero
    的子类，PantherMan 类自动继承了所有超级英雄共有的实例变量和方法，包括 `suit, tights, specialPower, useSpecialPower()`
    等等。但是 PantherMan 子类可以添加自己的新方法和实例变量，并且可以覆盖它从父类 SuperHero 继承的方法。
- en: '![image](Images/f0170-01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0170-01.png)'
- en: FriedEggMan doesn’t need any behavior that’s unique, so he doesn’t override
    any methods. The methods and instance variables in SuperHero are sufficient. PantherMan,
    though, has specific requirements for his suit and special powers, so `useSpecialPower()`
    and `putOnSuit()` are both overridden in the PantherMan class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: FriedEggMan 不需要任何独特的行为，因此他不会覆盖任何方法。SuperHero 类中的方法和实例变量已经足够了。然而，PantherMan 对他的服装和特殊能力有特定的要求，因此在
    PantherMan 类中 `useSpecialPower()` 和 `putOnSuit()` 都被覆盖了。
- en: '**Instance variables are not overridden** because they don’t need to be. They
    don’t define any special behavior, so a subclass can give an inherited instance
    variable any value it chooses. PantherMan can set his inherited `tights` to purple,
    while FriedEggMan sets his to white.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例变量不会被覆盖**，因为它们没有这个必要。它们不定义任何特殊行为，所以子类可以为继承的实例变量赋予任何值。PantherMan可以将他继承的`tights`设为紫色，而FriedEggMan则将其设为白色。'
- en: 'An inheritance example:'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个继承的例子：
- en: '![image](Images/f0171-01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0171-01.png)'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '* * *'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s design the inheritance tree for an Animal simulation program
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们为动物模拟程序设计继承树
- en: Imagine you’re asked to design a simulation program that lets the user throw
    a bunch of different animals into an environment to see what happens. We don’t
    have to code the thing now; we’re mostly interested in the design.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被要求设计一个模拟程序，让用户将各种不同的动物扔到环境中看看会发生什么。我们现在不必编写这个程序；我们主要关心的是设计。
- en: We’ve been given a list of *some* of the animals that will be in the program,
    but not all. We know that each animal will be represented by an object and that
    the objects will move around in the environment, doing whatever it is that each
    particular type is programmed to do.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了将在程序中出现的*一些*动物的列表，但不是全部。我们知道每种动物将由一个对象表示，并且这些对象将在环境中移动，执行每个特定类型被编程执行的操作。
- en: '***And we want other programmers to be able to add new kinds of animals to
    the program at any time.***'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '***而且我们希望其他程序员能够随时向程序中添加新类型的动物。***'
- en: First we have to figure out the common, abstract characteristics that all animals
    have, and build those characteristics into a class that all animal classes can
    extend.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须找出所有动物共有的抽象特征，并将这些特征构建到一个所有动物类都可以扩展的类中。
- en: '![Images](Images/1circlea.png) Look for objects that have common attributes
    and behaviors.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlea.png) 寻找具有共同属性和行为的对象。'
- en: '**What do these six types have in common? This helps you to abstract out behaviors.
    (step 2)**'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**这六种类型有什么共同点？这可以帮助您抽象出行为。 （步骤2）**'
- en: '**How are these types related? This helps you to define the inheritance tree
    relationships (steps 4-5)**'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**这些类型有什么共同点？这有助于定义继承树关系（步骤4-5）**'
- en: '![image](Images/f0172-01.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0172-01.png)'
- en: Using inheritance to avoid duplicating code in subclasses
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承来避免在子类中重复编写代码
- en: We have five ***instance variables:***
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五个***实例变量：***
- en: '***picture*** – the filename representing the JPEG of this animal.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '***picture*** – 表示这种动物的JPEG文件名。'
- en: '***food*** – the type of food this animal eats. Right now, there can be only
    two values: *meat* or *grass*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '***food*** – 这种动物食用的食物类型。目前只能有两个值：*meat* 或 *grass*。'
- en: '***hunger*** – an int representing the hunger level of the animal. It changes
    depending on when (and how much) the animal eats.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***hunger*** – 表示动物饥饿水平的整数。它会根据动物吃饭的时间（和数量）而变化。'
- en: '***boundaries*** – values representing the height and width of the “space”
    (for example, 640 x 480) that the animals will roam around in.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '***boundaries*** – 表示动物将漫游的“空间”的高度和宽度的值（例如640 x 480）。'
- en: '***location*** – the X and Y coordinates for where the animal is in the space.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***location*** – 动物在空间中所处位置的X和Y坐标。'
- en: We have four ***methods:***
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个***方法:***
- en: '***makeNoise()*** – behavior for when the animal is supposed to make noise.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***makeNoise()*** – 动物应该发出噪音时的行为。'
- en: '***eat()*** – behavior for when the animal encounters its preferred food source,
    *meat* or *grass*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '***eat()*** – 动物遇到其首选食物源（*肉*或*草*）时的行为。'
- en: '***sleep()*** – behavior for when the animal is considered asleep.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***sleep()*** – 动物被认为处于睡眠状态时的行为。'
- en: '***roam()*** – behavior for when the animal is not eating or sleeping (probably
    just wandering around waiting to bump into a food source or a boundary).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***roam()*** – 动物不吃或睡觉时的行为（可能只是四处游荡等待碰到食物源或边界）。'
- en: '![Images](Images/1circleb.png) Design a class that represents the common state
    and behavior.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circleb.png) 设计一个代表共同状态和行为的类。'
- en: '**These objects are all animals, so we’ll make a common superclass called Animal.**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些对象都是动物，因此我们将创建一个名为Animal的共同超类。**'
- en: '**We’ll put in methods and instance variables that all animals might need.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们将放入所有动物可能需要的方法和实例变量。**'
- en: '![image](Images/f0173-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0173-01.png)'
- en: Do all animals eat the same way?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有动物都吃同样的方式吗？
- en: 'Assume that we all agree on one thing: the instance variables will work for
    *all* Animal types. A lion will have his own value for picture, food (we’re thinking
    *meat*), hunger, boundaries, and location. A hippo will have different *values*
    for his instance variables, but he’ll still have the same variables that the other
    Animal types have. Same with dog, tiger, and so on. But what about *behavior*?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们都同意一件事：实例变量将适用于*所有*动物类型。狮子会有自己的picture、food（我们考虑*肉*）、hunger、boundaries和location的值。河马将有不同的*值*作为他的实例变量，但他仍将拥有其他动物类型拥有的相同变量。狗、老虎等也是如此。但是*行为*呢？
- en: Which methods should we override?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该重写哪些方法？
- en: Does a lion make the same **noise** as a dog? Does a cat **eat** like a hippo?
    Maybe in *your* version, but in ours, eating and making noise are Animal-type-specific.
    We can’t figure out how to code those methods in such a way that they’d work for
    any animal. OK, that’s not true. We could write the makeNoise() method, for example,
    so that all it does is play a sound file defined in an instance variable for that
    type, but that’s not very specialized. Some animals might make different noises
    for different situations (like one for eating, and another when bumping into an
    enemy, etc.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 狮子和狗发出相同的**声音**吗？猫和河马是一样**吃**东西吗？也许在*你*的版本中是这样，但在我们的版本中，进食和发出声音是特定于动物类型的。我们无法想出如何编写这些方法，以使它们适用于任何动物。好吧，这不是真的。例如，我们可以编写makeNoise()方法，使其只是播放由该类型的实例变量定义的声音文件，但这并不是非常专业化。有些动物在不同情况下可能会发出不同的声音（比如吃东西时一个声音，遇到敌人时另一个声音等）。
- en: So just as with the Amoeba overriding the Shape class rotate() method, to get
    more amoeba-specific (in other words, *unique*) behavior, we’ll have to do the
    same for our Animal subclasses.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像变形虫重写Shape类的rotate()方法以获得更多变形虫特定（换句话说，*独特*）的行为一样，我们将不得不为我们的动物子类做同样的事情。
- en: '![Images](Images/1circlec.png) Decide if a subclass needs behaviors (method
    implementations) that are specific to that particular subclass type.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlec.png) 决定子类是否需要特定于该特定子类类型的行为（方法实现）。'
- en: '**Looking at the Animal class, we decide that eat() and makeNoise() should
    be overridden by the individual subclasses.**'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**查看Animal类后，我们决定应该由各个子类重写eat()和makeNoise()。**'
- en: '![image](Images/f0174-01.png)![image](Images/f0174-02.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0174-01.png)![image](Images/f0174-02.png)'
- en: Looking for more inheritance opportunities
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找更多的继承机会
- en: The class hierarchy is starting to shape up. We have each subclass override
    the *makeNoise()* and *eat()* methods so that there’s no mistaking a Dog bark
    from a Cat meow (quite insulting to both parties). And a Hippo won’t eat like
    a Lion.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构开始形成。我们让每个子类重写*makeNoise()*和*eat()*方法，以便狗的吠声不会被误认为是猫的喵声（对双方都是相当侮辱）。河马也不会像狮子一样吃东西。
- en: But perhaps there’s more we can do. We have to look at the subclasses of Animal
    and see if two or more can be grouped together in some way, and given code that’s
    common to only *that* new group. Wolf and Dog have similarities. So do Lion, Tiger,
    and Cat.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许我们还可以做得更多。我们必须查看Animal的子类，并看看是否可以以某种方式将两个或更多子类分组，并为只属于*那个*新组的代码提供。
- en: '![Images](Images/1circled.png) Look for more opportunities to use abstraction,
    by finding two or more *subclasses* that might need common behavior.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circled.png) 寻找更多使用抽象的机会，通过找到两个或更多*子类*可能需要共同行为的地方。'
- en: '**We look at our classes and see that Wolf and Dog might have some behavior
    in common, and the same goes for Lion, Tiger, and Cat.**'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**我们查看我们的类并看到Wolf和Dog可能有一些共同的行为，同样适用于Lion、Tiger和Cat。**'
- en: '![image](Images/f0175-01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0175-01.png)'
- en: '![Images](Images/1circlee.png) Finish the class hierarchy'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlee.png) 完成类层次结构'
- en: Since animals already have an organizational hierarchy (the whole kingdom, genus,
    phylum thing), we can use the level that makes the most sense for class design.
    We’ll use the biological “families” to organize the animals by making a Feline
    class and a Canine class.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于动物已经有了组织层次（整个界、门、纲的事情），我们可以使用最合适的级别来进行类设计。我们将使用生物学上的“家族”来组织动物，创建一个Feline类和一个Canine类。
- en: '**We decide that Canines could use a common roam() method, because they tend
    to move in packs. We also see that Felines could use a common roam() method, because
    they tend to avoid others of their own kind. We’ll let Hippo continue to use its
    inherited roam() method— the generic one it gets from Animal.**'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**我们决定犬科动物可以使用一个通用的roam()方法，因为它们倾向于成群结队移动。我们也看到猫科动物可以使用一个通用的roam()方法，因为它们倾向于避开同类。我们将让河马继续使用其继承的roam()方法——从Animal类那里继承的通用方法。**'
- en: '**So we’re done with the design for now; we’ll come back to it later in the
    chapter.**'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**所以我们现在完成了设计；我们将在本章稍后回到它。**'
- en: '![image](Images/f0176-01.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0176-01.png)'
- en: Which method is called?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用哪个方法？
- en: The Wolf class has four methods. One inherited from Animal, one inherited from
    Canine (which is actually an overridden version of a method in class Animal),
    and two overridden in the Wolf class. When you create a Wolf object and assign
    it to a variable, you can use the dot operator on that reference variable to invoke
    all four methods. But which *version* of those methods gets called?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Wolf类有四个方法。一个继承自Animal，一个继承自Canine（实际上是Animal类中一个方法的重写版本），以及两个在Wolf类中重写的方法。当你创建一个Wolf对象并将其分配给一个变量时，你可以在该引用变量上使用点运算符来调用所有四个方法。但是哪个*版本*的这些方法会被调用？
- en: '![image](Images/f0177-01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0177-01.png)'
- en: When you call a method on an object reference, you’re calling the most specific
    version of the method for that object type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象引用上调用一个方法时，你实际上是调用该对象类型的最具体版本的方法。
- en: In other words, ***the lowest one wins!***
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，***最低的那个获胜！***
- en: “Lowest” meaning lowest on the inheritance tree. Canine is lower than Animal,
    and Wolf is lower than Canine, so invoking a method on a reference to a Wolf object
    means the JVM starts looking first in the Wolf class. If the JVM doesn’t find
    a version of the method in the Wolf class, it starts walking back up the inheritance
    hierarchy until it finds a match.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “最低”指继承树上的最底层。Canine低于Animal，Wolf低于Canine，因此在对Wolf对象的引用上调用方法时，JVM首先在Wolf类中查找。如果JVM在Wolf类中找不到方法的版本，它会沿着继承层次向上查找，直到找到匹配的方法。
- en: Designing an Inheritance Tree
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个继承树
- en: '![image](Images/f0178-02.png)![image](Images/f0178-01.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0178-02.png)![image](Images/f0178-01.png)'
- en: Using IS-A and HAS-A
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IS-A和HAS-A
- en: '![image](Images/f0179-01.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0179-01.png)'
- en: Remember that when one class inherits from another, we say that the subclass
    *extends* the superclass. When you want to know if one thing should extend another,
    apply the IS-A test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当一个类继承另一个类时，我们说子类*扩展*了超类。当你想知道一个东西是否应该扩展另一个东西时，请应用IS-A测试。
- en: Triangle IS-A Shape, yeah, that works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Triangle IS-A Shape，是的，这可以。
- en: Cat IS-A Feline, that works too.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cat IS-A Feline，这也行。
- en: Surgeon IS-A Doctor, still good.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Surgeon IS-A Doctor，仍然适用。
- en: Tub extends Bathroom, sounds reasonable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Tub extends Bathroom，听起来合理。
- en: '*Until you apply the IS-A test.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*直到应用IS-A测试。*'
- en: To know if you’ve designed your types correctly, ask, “Does it make sense to
    say type X IS-A type Y?” If it doesn’t, you know there’s something wrong with
    the design, so if we apply the IS-A test, Tub IS-A Bathroom is definitely false.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道你是否设计了正确的类型，请问：“说类型 X 是类型 Y 有意义吗？”如果不是，你就知道设计有问题了，所以如果我们应用 IS-A 测试，浴缸是浴室显然是不对的。
- en: What if we reverse it to Bathroom extends Tub? That still doesn’t work, Bathroom
    IS-A Tub doesn’t work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反过来，让浴室扩展浴缸呢？那也不行，浴室是浴缸不行。
- en: Tub and Bathroom *are* related, but not through inheritance. Tub and Bathroom
    are joined by a HAS-A relationship. Does it make sense to say “Bathroom HAS-A
    Tub”? If yes, then it means that Bathroom has a Tub instance variable. In other
    words, Bathroom has a *reference* to a Tub, but Bathroom does not *extend* Tub
    and vice versa.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 浴缸和浴室*是*相关的，但不是通过继承。浴缸和浴室通过 HAS-A 关系连接。说“浴室有一个浴缸”有意义吗？如果是，那么意味着浴室有一个浴缸的实例变量。换句话说，浴室对浴缸有一个*引用*，但浴室不*扩展*浴缸，反之亦然。
- en: '![image](Images/f0179-02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0179-02.png)'
- en: Bathroom HAS-A Tub and Tub HAS-A Bubbles.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 浴室有一个浴缸，浴缸有泡泡。
- en: But nobody inherits from (extends) anybody else.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有人从其他人那里继承（扩展）。
- en: But wait! There’s more!
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但等等！还有更多！
- en: The IS-A test works *anywhere* in the inheritance tree. If your inheritance
    tree is well-designed, the IS-A test should make sense when you ask *any* subclass
    if it IS-A *any* of its supertypes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: IS-A 测试在继承树的*任何地方*都适用。如果你的继承树设计良好，当你询问*任何*子类是否是*任何*其超类型时，IS-A 测试应该是有意义的。
- en: '**If class B extends class A, class B IS-A class A.**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果 B 类扩展 A 类，则 B 类是 A 类。**'
- en: '**This is true anywhere in the inheritance tree. If class C extends class B,
    class C passes the IS-A test for both B *and* A.**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**这在继承树的任何地方都是正确的。如果类 C 扩展类 B，那么类 C 对于类 B *和* 类 A 都通过了 IS-A 测试。**'
- en: Canine extends Animal
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 犬科动物扩展动物
- en: Wolf extends Canine
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 狼扩展犬科动物
- en: Wolf extends Animal
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 狼扩展动物
- en: Canine IS-A Animal
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 犬科动物是动物
- en: Wolf IS-A Canine
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 狼是一种犬科动物
- en: Wolf IS-A Animal
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 狼是动物
- en: '![image](Images/f0180-01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0180-01.png)'
- en: With an inheritance tree like the one shown here, you’re always allowed to say
    **“Wolf extends Animal”** or **“Wolf IS-A Animal.”** It makes no difference if
    Animal is the superclass of the superclass of Wolf. In fact, **as long as Animal
    is *somewhere* in the inheritance hierarchy above Wolf, Wolf IS-A Animal will
    always be true.**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了像这里显示的继承树，你总是可以说“狼扩展动物”或“狼是动物”。如果动物是狼的超类的超类，这并没有任何区别。事实上，**只要动物在狼的继承层次结构的某处之上，狼是动物就总是正确的。**
- en: 'The structure of the Animal inheritance tree says to the world:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 动物继承树的结构向世界表明：
- en: “Wolf IS-A Canine, so Wolf can do anything a Canine can do. And Wolf IS-A Animal,
    so Wolf can do anything an Animal can do.”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “狼是犬科动物，所以狼可以做任何犬科动物可以做的事情。而且狼是动物，所以狼可以做任何动物可以做的事情。”
- en: It makes no difference if Wolf overrides some of the methods in Animal or Canine.
    As far as the world (of other code) is concerned, a Wolf can do those four methods.
    *How* he does them, or *in which class they’re overridden*, makes no difference.
    A Wolf can makeNoise(), eat(), sleep(), and roam() because a Wolf extends from
    class Animal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 狼是否覆盖了动物或犬科动物中的某些方法并不重要。对于其他代码的世界来说，狼可以执行这四种方法。他们如何执行这些方法或这些方法在哪个类中被覆盖都不重要。狼可以叫声、吃饭、睡觉和漫步，因为狼扩展自动物类。
- en: How do you know if you’ve got your inheritance right?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你如何知道你的继承是正确的？
- en: There’s obviously more to it than what we’ve covered so far, but we’ll look
    at a lot more OO issues in the next chapter (where we eventually refine and improve
    on some of the design work we did in *this* chapter).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所涵盖的内容显然还不足，但我们将在下一章中查看更多的面向对象问题（在那里我们最终会对本章的一些设计工作进行精炼和改进）。
- en: For now, though, a good guideline is to use the IS-A test. If “X IS-A Y” makes
    sense, both classes (X and Y) should probably live in the same inheritance hierarchy.
    Chances are, they have the same or overlapping behaviors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在一个很好的指导原则是使用 IS-A 测试。如果“X 是 Y”有意义，那么这两个类（X 和 Y）很可能应该在同一个继承层次结构中。它们很可能具有相同或重叠的行为。
- en: '**Keep in mind that the inheritance IS-A relationship works in only *one* direction!**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**请记住，继承的 IS-A 关系只能在*一个*方向上工作！**'
- en: Triangle IS-A Shape makes sense, so you can have Triangle extend Shape.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形是一种形状有意义，所以你可以让三角形扩展形状。
- en: But the reverse—Shape IS-A Triangle—does *not* make sense, so Shape should not
    extend Triangle. Remember that the IS-A relationship implies that if X IS-A Y,
    then X can do anything a Y can do (and possibly more).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但反过来——形状IS-A三角形——是*不*有意义的，所以形状不应扩展三角形。请记住，IS-A关系意味着如果X是Y的一种，则X可以做任何Y可以做的事情（可能更多）。
- en: '![Images](Images/arr1.png) **Yours to solve.**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **你来解决。**'
- en: '*Hint: apply the IS-A test*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示：应用IS-A测试*'
- en: '**Who ge ts the Porsche, who ge ts the porcelain? (how to know what a subclass
    can inherit from it’s superclass)**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁得到保时捷，谁得到瓷器？（如何知道一个子类可以从其超类继承什么）**'
- en: '![image](Images/f0182-02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0182-02.png)'
- en: A subclass inherits members of the superclass. Members include instance variables
    and methods, although later in this book we’ll look at other inherited members.
    A superclass can choose whether or not it wants a subclass to inherit a particular
    member by the level of access the particular member is given.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 子类继承超类的成员。成员包括实例变量和方法，尽管在本书的后面我们将会看到其他继承的成员。超类可以选择是否希望子类继承特定成员，这取决于特定成员的访问级别。
- en: 'There are four access levels that we’ll cover in this book. Moving from most
    restrictive to least, the four access levels are:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将涵盖四种访问级别。从最严格到最宽松，这四种访问级别分别是：
- en: '![image](Images/f0182-03.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0182-03.png)'
- en: '**Access levels control *who sees what***, and are crucial to having well-designed,
    robust Java code. For now we’ll focus just on public and private. The rules are
    simple for those two:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问级别控制*谁看见什么***，对于拥有设计良好、健壮的Java代码至关重要。目前我们将只关注公共和私有两种。对于这两者的规则很简单：'
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a subclass inherits a member, it is ***as if the subclass defined the member
    itself***. In the Shape example, Square inherited the `rotate()` and `playSound()`
    methods and to the outside world (other code) the Square class simply has a `rotate()`
    and `playSound()` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类继承一个成员时，就***好像子类自己定义了该成员***。在形状的例子中，正方形继承了`rotate()`和`playSound()`方法，对于外部世界（其他代码），正方形类简单地具有`rotate()`和`playSound()`方法。
- en: The members of a class include the variables and methods defined in the class
    plus anything inherited from a superclass.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的成员包括在类中定义的变量和方法以及从超类继承的任何内容。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: get more details about default and protected in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：获取有关默认和受保护内容的更多详细信息，请参阅[附录 B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d)。
- en: When designing with inheritance, are you using or abusing?
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在设计时使用继承，您是在使用还是滥用？
- en: Although some of the reasons behind these rules won’t be revealed until later
    in this book, for now, simply *knowing* a few rules will help you build a better
    inheritance design.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些规则背后的一些原因直到本书的后面才会被揭示，但现在，简单地*了解*一些规则将有助于您构建更好的继承设计。
- en: '**DO** use inheritance when one class *is* a more specific type of a superclass.
    Example: Willow is a more specific type of Tree, so Willow *extends* Tree makes
    sense.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**请**在一个类*是*超类的更具体类型时使用继承。例如：柳树是树的更具体类型，因此柳树*扩展*树是有意义的。'
- en: '**DO** consider inheritance when you have behavior (implemented code) that
    should be shared among multiple classes of the same general type. Example: Square,
    Circle, and Triangle all need to rotate and play sound, so putting that functionality
    in a superclass Shape might make sense and makes for easier maintenance and extensibility.
    Be aware, however, that while inheritance is one of the key features of object-oriented
    programming, it’s not necessarily the best way to achieve behavior reuse. It’ll
    get you started, and often it’s the right design choice, but design patterns will
    help you see other more subtle and flexible options. If you don’t know about design
    patterns, a good follow-on to this book would be *Head First Design Patterns.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**请**在您有应该被多个相同类型的类共享的行为（实现的代码）时考虑继承。例如：正方形、圆形和三角形都需要旋转和播放声音，因此将这些功能放在一个超类形状（Shape）中可能是有意义的，也更容易维护和扩展。但是，请注意，虽然继承是面向对象编程的关键特性之一，但并不一定是实现行为重用的最佳方法。它可以让您入门，并且通常是正确的设计选择，但是设计模式将帮助您看到其他更微妙和灵活的选项。如果您不了解设计模式，那么这本书的一个好的后续阅读选择将是*《Head
    First Design Patterns》*。'
- en: '**DO NOT** use inheritance just so that you can reuse code from another class,
    if the relationship between the superclass and subclass violate either of the
    above two rules. For example, imagine you wrote special printing code in the Animal
    class and now you need printing code in the Potato class. You might think about
    making Potato extend Animal so that Potato inherits the printing code. That makes
    no sense! A Potato is *not* an Animal! (So the printing code should be in a Printer
    class that all printable objects can take advantage of via a HAS-A relationship.)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**仅仅为了从另一个类中重用代码而使用继承，如果超类和子类之间的关系违反了上述两条规则中的任何一条。例如，想象一下，在 Animal 类中编写了特殊的打印代码，现在需要在
    Potato 类中使用打印代码。你可能会考虑让 Potato 扩展 Animal 以便 Potato 继承打印代码。这毫无意义！Potato *不是* Animal！（因此，打印代码应该在一个
    Printer 类中，所有可打印对象都可以通过 HAS-A 关系利用它。）'
- en: '**DO NOT** use inheritance if the subclass and superclass do not pass the IS-A
    test. Always ask yourself if the subclass IS-A more specific type of the superclass.
    Example: Tea IS-A Beverage makes sense. Beverage IS-A Tea does not.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**在子类和超类不通过 IS-A 测试时使用继承。始终要问自己子类是否是超类的更具体类型。例如：Tea IS-A Beverage 是有意义的。Beverage
    IS-A Tea 是没有意义的。'
- en: So what does all this inheritance really buy you?
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，所有这些继承到底带来了什么好处？
- en: 'You get a lot of OO mileage by designing with inheritance. You can get rid
    of duplicate code by abstracting out the behavior common to a group of classes,
    and sticking that code in a superclass. That way, when you need to modify it,
    you have only one place to update, and *the change is magically reflected in all
    the classes that inherit that behavior.* Well, there’s no magic involved, but
    it is pretty simple: make the change and compile the class again. That’s it. **You
    don’t have to touch the subclasses!**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用继承进行设计，你可以获得很多面向对象的好处。通过将一组类共有的行为抽象出来，放入一个超类中，你可以消除重复的代码。这样，当你需要修改时，只需更新一个地方，*这种变更会神奇地反映在继承了该行为的所有类中。*好吧，并没有魔法，但确实很简单：做出改变，然后重新编译该类。就是这样。**你不必触及子类！**
- en: '**Just deliver the newly changed superclass, and all classes that extend it
    will automatically use the new version.**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**只需交付新变更的超类，所有扩展它的类将自动使用新版本。**'
- en: A Java program is nothing but a pile of classes, so the subclasses don’t have
    to be recompiled in order to use the new version of the superclass. As long as
    the superclass doesn’t *break* anything for the subclass, everything’s fine. (We’ll
    discuss what the word “break” means in this context later in the book. For now,
    think of it as modifying something in the superclass that the subclass is depending
    on, like a particular method’s arguments, return type, method name, etc.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Java 程序无非就是一堆类，因此在使用新版本的超类时，不需要重新编译子类。只要超类不会对子类造成*破坏*，一切都好。（我们将在本书的后面讨论在这个上下文中“破坏”一词的含义。现在，可以将其理解为修改了超类中某个方法的参数、返回类型、方法名等，而子类依赖于这些内容。）
- en: '![Images](Images/1circlea.png) **You avoid duplicate code.**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circlea.png) **你避免了重复代码。**'
- en: Put common code in one place, and let the subclasses inherit that code from
    a superclass. When you want to change that behavior, you have to modify it in
    only one place, and everybody else (i.e., all the subclasses) sees the change.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将共有代码放在一个地方，并让子类从超类中继承该代码。当你想要改变这种行为时，你只需在一个地方进行修改，所有其他人（即所有子类）都会看到这一变更。
- en: '![Images](Images/1circleb.png) **You define a common protocol for a group of
    classes.**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circleb.png) **你为一组类定义了一个通用协议。**'
- en: '![image](Images/f0184-01.png)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0184-01.png)'
- en: Inheritance lets you guarantee that all classes grouped under a certain supertype
    have all the methods that the supertype has*
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承能确保所有归于某个特定超类型的类都具有超类型拥有的所有方法*
- en: '**In other words, you define a common protocol for a set of classes related
    through inheritance.**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**换句话说，你为通过继承关联的一组类定义了一个通用协议。**'
- en: When you define methods in a superclass that can be inherited by subclasses,
    you’re announcing a kind of protocol to other code that says, “All my subtypes
    (i.e., subclasses) can do these things, with these methods that look like this...”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在超类中定义可以被子类继承的方法时，你在向其他代码宣告一种协议，说：“我的所有子类型（即子类）都可以做这些事情，使用这些看起来像这样的方法…”
- en: In other words, you establish a *contract.*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你建立了一个*协议*。
- en: 'Class Animal establishes a common protocol for all Animal subtypes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Animal 为所有 Animal 子类型建立了一个通用协议：
- en: '![image](Images/f0185-01.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0185-01.png)'
- en: And remember, when we *say any Animal*, we mean Animal *and any class that extends
    from Animal*. That again means, *any class that has Animal somewhere above it
    in the inheritance hierarchy.*
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住，当我们说任何Animal时，我们指的是Animal *及其任何从Animal继承的类*。这也意味着，*任何一个在继承层次结构中Animal上方的类*。
- en: But we’re not even at the really cool part yet, because we saved the best—*polymorphism*—for
    last.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们甚至还没有到真正酷的部分，因为我们把最好的一部分——*多态性*——留到了最后。
- en: When you define a supertype for a group of classes, *any subclass of that supertype
    can be substituted where the supertype is expected.*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一组类定义一个超类型时，*该超类型的任何子类都可以替换为预期的超类型*。
- en: Say, what?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，什么？
- en: Don’t worry, we’re nowhere near done explaining it. Two pages from now, you’ll
    be an expert.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我们还远没有解释完。再过两页，你就会成为专家。
- en: '**And I care because...**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**我关心的原因是...**'
- en: You get to take advantage of polymorphism.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用多态性。
- en: '**Which matters to me because...**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**对我很重要的原因是...**'
- en: You get to refer to a subclass object using a reference declared as the supertype.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用声明为超类型的引用来引用子类对象。
- en: '**And that means to me...**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**对我来说意味着...**'
- en: You get to write really flexible code. Code that’s cleaner (more efficient,
    simpler). Code that’s not just easier to *develop*, but also much, much easier
    to *extend*, in ways you never imagined at the time you originally wrote your
    code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写非常灵活的代码。更清洁的代码（更高效、更简单）。不仅更容易*开发*，而且在编写代码时从未想象过的方式中，也更容易*扩展*。
- en: That means you can take that tropical vacation while your co-workers update
    the program, and your co-workers might not even need your source code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以在你的同事更新程序时去度假，而且你的同事甚至可能不需要你的源代码。
- en: You’ll see how it works on the next page.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一页看到它是如何工作的。
- en: We don’t know about you, but personally, we find the whole tropical vacation
    thing particularly motivating.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道你，但就个人而言，我们觉得整个热带假期的事情尤其具有动力。
- en: '![image](Images/f0185-02.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0185-02.png)'
- en: '* When we say “all the methods,” we mean “all the inheritable methods,” which
    for now actually means “all the *public* methods,” although later we’ll refine
    that definition a bit more.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* 当我们说“所有方法”时，我们指的是“所有可继承方法”，目前实际上意味着“所有*公共*方法”，尽管稍后我们会进一步细化这个定义。'
- en: '**To see how polymorphism works, we have to step back and look at the way we
    normally declare a reference and create an object...**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**要看看多态性是如何工作的，我们必须退后一步，看看我们通常如何声明一个引用并创建一个对象...**'
- en: '**The 3 steps of object declaration and assignment**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象声明和赋值的三个步骤**'
- en: '![image](Images/f0186-01.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0186-01.png)'
- en: '![Images](Images/1circlea.png) **Declare a reference variable**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circlea.png) **声明一个引用变量**'
- en: '[PRE4]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tells the JVM to allocate space for a reference variable. The reference variable
    is, forever, of type Dog. In other words, a remote control that has buttons to
    control a Dog, but not a Cat or a Button or a Socket.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉JVM为一个引用变量分配空间。该引用变量永远是Dog类型。换句话说，一个遥控器，上面有控制Dog的按钮，但没有控制Cat、Button或Socket的按钮。
- en: '![image](Images/f0186-02.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0186-02.png)'
- en: '![Images](Images/1circleb.png) **Create an object**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circleb.png) **创建一个对象**'
- en: '[PRE5]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tells the JVM to allocate space for a new Dog object on the garbage collectible
    heap.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉JVM在可回收堆上为一个新的Dog对象分配空间。
- en: '![image](Images/f0186-03.png)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0186-03.png)'
- en: '![Images](Images/1circlec.png) **Link the object and the reference**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circlec.png) **链接对象和引用**'
- en: '[PRE6]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assigns the new Dog to the reference variable myDog. In other words, ***program
    the remote control.***
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将新的Dog分配给引用变量myDog。换句话说，***编程遥控器。***
- en: '![image](Images/f0186-04.png)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0186-04.png)'
- en: '**The important point is that the reference type AND the object type are the
    same.**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要的是，引用类型和对象类型是相同的。**'
- en: '**In this example, both are Dog.**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这个例子中，两者都是Dog。**'
- en: '![image](Images/f0187-01.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0187-01.png)'
- en: '**But with polymorphism, the reference type and the object type can be *different.***'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是在多态性中，引用类型和对象类型可以是*不同的*。**'
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![image](Images/f0187-02.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0187-02.png)'
- en: '**With polymorphism, the reference type can be a superclass of the actual object
    type.**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用多态性时，引用类型可以是实际对象类型的超类。**'
- en: '![image](Images/f0188-01.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0188-01.png)'
- en: When you declare a reference variable, any object that passes the IS-A test
    for the type of the reference can be assigned to that variable. In other words,
    anything that *extends* the declared reference variable type can be *assigned*
    to the reference variable. ***This lets you do things like make polymorphic arrays.***
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明一个引用变量时，通过“IS-A”测试与引用类型相同的任何对象都可以分配给该变量。换句话说，任何*扩展*声明的引用变量类型的对象都可以*分配*给引用变量。***这使您能够做像制作多态数组这样的事情。***
- en: '**OK, OK maybe an example will help.**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的，好的，也许一个例子会有所帮助。**'
- en: '![image](Images/f0188-02.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0188-02.png)'
- en: '**But wait! There’s more!**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**但等等！还有更多！**'
- en: '**You can have polymorphic arguments and return types.**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以有多态参数和返回类型。**'
- en: If you can declare a reference variable of a supertype, say, Animal, and assign
    a subclass object to it, say, Dog, think of how that might work when the reference
    is an argument to a method...
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以声明一个超类型的引用变量，比如Animal，并将一个子类对象，比如Dog，分配给它，请想想当引用是方法的参数时可能如何工作...
- en: '![image](Images/f0189-01.png)![image](Images/f0190-01.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0189-01.png)![image](Images/f0190-01.png)'
- en: '**With polymorphism, you can write code that doesn’t have to change when you
    introduce new subclass types into the program.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过多态性，您可以编写在引入新的子类类型到程序时无需更改的代码。**'
- en: Remember that Vet class? If you write that Vet class using arguments declared
    as type *Animal*, your code can handle any Animal *subclass*. That means if others
    want to take advantage of your Vet class, all they have to do is make sure *their*
    new Animal types extend class Animal. The Vet methods will still work, even though
    the Vet class was written without any knowledge of the new Animal subtypes the
    Vet will be working on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那个Vet类吗？如果你使用声明为类型*Animal*的参数编写该Vet类，你的代码可以处理任何Animal的*子类*。这意味着，如果其他人想利用你的Vet类，他们只需确保*他们*的新Animal类型扩展了Animal类。即使Vet类在编写时对将要处理的新Animal子类型一无所知，Vet方法仍将正常工作。
- en: 'Keeping the contract: rules for overriding'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持合约：覆盖规则
- en: When you override a method from a superclass, you’re agreeing to fulfill the
    contract. The contract that says, for example, “I take no arguments and I return
    a boolean.” In other words, the arguments and return types of your overriding
    method must look to the outside world *exactly* like the overridden method in
    the superclass.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从超类覆盖方法时，您同意履行合约。合约即说，“我不带参数，返回一个布尔值。”换句话说，您覆盖的方法的参数和返回类型必须在外部世界看起来*完全*像超类中被覆盖的方法。
- en: '**The methods *are* the contract.**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 *就是* 合约。**'
- en: If polymorphism is going to work, the Toaster’s version of the overridden method
    from Appliance has to work at runtime. Remember, the compiler looks at the reference
    type to decide whether you can call a particular method on that reference.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多态性要起作用，Appliance中Toaster覆盖方法的版本必须在运行时起作用。请记住，编译器查看引用类型来决定是否可以在该引用上调用特定方法。
- en: '![image](Images/f0192-01.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0192-01.png)'
- en: With an Appliance reference to a Toaster, the compiler cares only if class *Appliance*
    has the method you’re invoking on an Appliance reference. But at runtime, the
    JVM does not look at the **reference** type (*Appliance*) but at the actual *Toaster*
    **object** on the heap.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对Toaster的Appliance引用时，编译器仅关心类*Appliance*是否具有您在Appliance引用上调用的方法。但在运行时，JVM并不关注**引用**类型（*Appliance*），而是堆上实际的*Toaster*
    **对象**。
- en: So if the compiler has already approved the method call, the only way it can
    work is if the overriding method has the same arguments and return types. Otherwise,
    someone with an Appliance reference will call turnOn() as a no-arg method, even
    though there’s a version in Toaster that takes an int. Which one is called at
    runtime? The one in Appliance. In other words, ***the turnOn(int level) method
    in Toaster is not an override!***
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果编译器已经批准了方法调用，它能够工作的唯一方式是覆盖方法具有相同的参数和返回类型。否则，具有Appliance引用的人将调用turnOn()作为无参方法，即使Toaster中有一个接受int参数的版本。在运行时调用哪个方法？是Appliance中的方法。换句话说，***Toaster中的turnOn(int
    level)方法不是覆盖！***
- en: '![image](Images/f0192-02.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0192-02.png)'
- en: '![Images](Images/1.png) **Arguments must be the same, and return types must
    be compatible.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **参数必须相同，返回类型必须兼容。**'
- en: The contract of superclass defines how other code can use a method. Whatever
    the superclass takes as an argument, the subclass overriding the method must use
    that same argument. And whatever the superclass declares as a return type, the
    overriding method must declare either the same type or a subclass type. Remember,
    a subclass object is guaranteed to be able to do anything its superclass declares,
    so it’s safe to return a subclass where the superclass is expected.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 超类的合同定义了其他代码如何使用方法。无论超类接受什么样的参数，覆盖方法的子类必须使用相同的参数。并且无论超类声明什么返回类型，覆盖方法必须声明相同类型或子类类型。记住，子类对象保证能够执行其超类声明的任何操作，因此可以安全地返回子类，而超类预期返回的是安全的。
- en: '![Images](Images/2.png) **The method can’t be less accessible.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **方法不能更少可访问。**'
- en: That means the access level must be the same, or friendlier. You can’t, for
    example, override a public method and make it private. What a shock that would
    be to the code invoking what it *thinks* (at compile time) is a public method,
    if suddenly at runtime the JVM slammed the door shut because the overriding version
    called at runtime is private!
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着访问级别必须相同，或者更友好。例如，你不能覆盖一个公共方法并将其变为私有。如果在运行时调用的代码突然因为覆盖版本在运行时是私有的而被 JVM 关闭，那会是多么震惊的事情！
- en: 'So far we’ve learned about two access levels: private and public. The other
    two are in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d).
    There’s also another rule about overriding related to exception handling, but
    we’ll wait until [Chapter 13](ch13.xhtml#risky_behavior_exception_handling), *Risky
    Behavior*, to cover that.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了两种访问级别：私有和公共。另外两种在[附录 B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d)中。关于与异常处理相关的重写还有另一条规则，但我们将等到[第 13 章](ch13.xhtml#risky_behavior_exception_handling)——
    *风险行为* 中再讨论。
- en: '![image](Images/f0192-03.png)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0192-03.png)'
- en: Overloading a method
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对方法进行重载
- en: Method overloading is nothing more than having two methods with the same name
    but different argument lists. Period. There’s no polymorphism involved with overloaded
    methods!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载只不过是具有相同名称但不同参数列表的两个方法。没有重载方法涉及多态性！
- en: Overloading lets you make multiple versions of a method, with different argument
    lists, for convenience to the callers. For example, if you have a method that
    takes only an int, the calling code has to convert, say, a double into an int
    before calling your method. But if you overloaded the method with another version
    that takes a double, then you’ve made things easier for the caller. You’ll see
    more of this when we look into constructors in [Chapter 9](ch09.xhtml#life_and_death_of_an_object_constructors),
    *Life and Death of an Object.*
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重载让你可以创建多个版本的方法，具有不同的参数列表，为调用者提供方便。例如，如果你有一个仅接受 int 的方法，调用代码必须在调用你的方法之前将 double
    转换为 int。但如果你重载该方法并提供另一个接受 double 的版本，那么你为调用者简化了操作。当我们在[第 9 章](ch09.xhtml#life_and_death_of_an_object_constructors)——
    *对象的生死：构造函数* 中查看构造函数时，你会看到更多这样的情况。
- en: Since an overloading method isn’t trying to fulfill the polymorphism contract
    defined by its superclass, overloaded methods have much more flexibility.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重载方法并不试图满足其超类定义的多态性约定，重载方法具有更大的灵活性。
- en: An overloaded method is just a different method that happens to have the same
    met hod name. It has nothing to do with inheritance and polymorphism. An overloaded
    met hod is NOT the same as an overridden method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重载方法只是一个具有相同方法名称的不同方法。它与继承和多态无关。重载的方法不同于重写的方法。
- en: '![Images](Images/1.png) **The return types can be different.**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **返回类型可以不同。**'
- en: You can’t change ONLY the return type.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能只改变返回类型。
- en: '![Images](Images/2.png) **You can’t change ONLY the return type.**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **你不能只改变返回类型。**'
- en: If only the return type is different, it’s not a valid over*load*—the compiler
    will assume you’re trying to override the method. And even *that* won’t be legal
    unless the return type is a subtype of the return type declared in the superclass.
    To overload a method, you MUST change the argument list, although you *can* change
    the return type to anything.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果只有返回类型不同，则这不是有效的重*载* —— 编译器会假定你试图重写该方法。即使 *那* 也不合法，除非返回类型是超类声明的返回类型的子类型。要重载一个方法，你必须改变参数列表，尽管你
    *可以* 将返回类型更改为任何类型。
- en: '![Images](Images/3.png) **You *can* vary the access levels in any direction.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **你 *可以* 在任何方向上变化访问级别。**'
- en: You’re free to overload a method with a method that’s more restrictive. It doesn’t
    matter, since the new method isn’t obligated to fulfill the contract of the overloaded
    method.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以自由地使用一个更为严格的方法重载一个方法。这无关紧要，因为新方法无需履行重载方法的约定。
- en: '**Legal examples of method overloading:**'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**合法的方法重载示例：**'
- en: '[PRE8]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exercise
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/common-03.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-03.png)'
- en: Mixed Messages
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mixed Messages
- en: '![image](Images/common-04.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-04.png)'
- en: A short Java program is listed below. One block of the program is missing! Your
    challenge is to match the candidate block of code (on the left), with the output
    that you’d see if the block were inserted. Not all the lines of output will be
    used, and some of the lines of output might be used more than once. Draw lines
    connecting the candidate blocks of code with their matching command-line output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一个简短的 Java 程序。程序中有一个代码块缺失！你的挑战是将候选的代码块（在左侧）与插入后看到的匹配命令行输出进行配对。并非所有输出行都会被使用，有些输出行可能会被多次使用。画线连接代码块与匹配的命令行输出。
- en: '**The program:**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序：**'
- en: '![image](Images/f0194-01.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0194-01.png)'
- en: '**Code candidates:**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码候选人：**'
- en: '![image](Images/f0194-02.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0194-02.png)'
- en: '**Output:**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE9]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Images](Images/arr1.png) **Answers in [“Mixed Messages”](#mixed_messages_left_parenthesisfro-id200).**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr1.png) **在 [“Mixed Messages”](#mixed_messages_left_parenthesisfro-id200)
    中的答案。**'
- en: BE the Compiler
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the Compiler
- en: '****Which of the A-B pairs of methods listed on the right, if inserted into
    the classes on the left, would compile and produce the output shown? (The A method
    inserted into class Monster, the B method inserted into class Vampire.)**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '****如果将右侧列出的 A-B 方法对插入到左侧的类中，则会编译并产生显示的输出。 （将 A 方法插入到 Monster 类中，将 B 方法插入到
    Vampire 类中。）**'
- en: '[PRE10]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](Images/f0195-02.png)![image](Images/f0195-01.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0195-02.png)![image](Images/f0195-01.png)'
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler”](#be_the_compiler_left_parenthesisfro-0001).**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr1.png) **在 [“BE the Compiler”](#be_the_compiler_left_parenthesisfro-0001)
    中的答案。**'
- en: '![image](Images/common-04.png)** **# Exercise Solutions'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/common-04.png)** **# 练习解决方案'
- en: '![image](Images/common-03.png)![image](Images/f0197-01.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-03.png)![image](Images/f0197-01.png)'
- en: BE the Compiler
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the Compiler
- en: (from [“BE the Compiler”](#exercise-id000012))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“BE the Compiler”](#exercise-id000012))
- en: Set 1 **will** work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 1 **将** 可以工作。
- en: Set 2 **will not** compile because of Vampire’s return type (int).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 2 **不会** 编译，因为 Vampire 的返回类型是 int。
- en: The Vampire’s frighten() method (B) is not a legal override OR overload of Monster’s
    frighten() method. Changing ONLY the return type is not enough to make a valid
    overload, and since an int is not compatible with a boolean, the method is not
    a valid override. (Remember, if you change ONLY the return type, it must be to
    a return type that is compatible with the superclass version’s return type, and
    then it’s an override.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Vampire 的 frighten() 方法（B）不是 Monster 的 frighten() 方法的合法重写或重载。仅更改返回类型是不足以使其成为有效重载的，因为
    int 类型与 boolean 类型不兼容。请记住，如果只更改返回类型，则必须将其更改为与超类版本兼容的返回类型，那么它就是一个重写。
- en: 'Sets 3 and 4 **will** compile but produce:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 3 和 4 **将** 编译但会产生：
- en: '`arrrgh`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrrgh`'
- en: '`breathe fire`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`breathe fire`'
- en: '`arrrgh`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrrgh`'
- en: Remember, class Vampire did not override class Monster’s frighten() method.
    (The frighten() method in Vampire’s set 4 takes a byte, not an int.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Vampire 类没有重写 Monster 类的 frighten() 方法。（Vampire 类中集合 4 的 frighten() 方法使用的是
    byte，而不是 int。）
- en: '**Code candidates:**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码候选人：**'
- en: '![image](Images/common-04.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-04.png)'
- en: Mixed Messages
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mixed Messages
- en: (from [“Mixed Messages”](#mixed_messages-id0100006))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“Mixed Messages”](#mixed_messages-id0100006))
- en: '![image](Images/f0197-02.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0197-02.png)'
- en: Pool Puzzle
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pool Puzzle
- en: (from [“Pool Puzzle”](#pool_puzzle-id00003))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“Pool Puzzle”](#pool_puzzle-id00003))
- en: '![image](Images/common-04.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-04.png)'
- en: '[PRE11]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**OUTPUT:**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![image](Images/f0198-01.png)**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/f0198-01.png)**'
