- en: 'Chapter 6\. Quarkus: Reactive Engine'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章\. Quarkus：响应式引擎
- en: In [Part II](part02.html#reactive-part), you learned a lot about Reactive, in
    all its forms, meanings, and variations! I know, you’re probably a bit tired of
    hearing the word *reactive* right now, but it’s a key piece to accurately describing
    Quarkus. At the core of Quarkus is its reactive engine, which we cover in [“A
    Reactive Engine”](#quarkus-reactive::reactive-engine). Without its reactive engine
    core, Quarkus would not allow implementing reactive applications and provide a
    seamless integration of reactive programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 II 部分](part02.html#reactive-part)中，你学到了关于反应式的许多内容，以及它的各种形式、含义和变化！我知道，你现在可能有点厌倦听到
    *reactive* 这个词了，但这是准确描述 Quarkus 的关键。Quarkus 的核心是其响应式引擎，我们在 [“一个响应式引擎”](#quarkus-reactive::reactive-engine)
    中对其进行了介绍。没有其响应式引擎核心，Quarkus 将无法实现响应式应用并提供响应式编程的无缝集成。
- en: 'Quarkus unifies two development models: imperative and reactive. In this chapter,
    we review the main differences and show how Quarkus handles the unification. Quarkus
    aims for them to be as alike as possible. If the APIs *feel* similar, understanding
    a complex model such as Reactive becomes seamless.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 统一了两种开发模型：命令式和响应式。在本章中，我们将回顾主要区别，并展示 Quarkus 如何处理这种统一。Quarkus 的目标是使它们尽可能相似。如果
    API *感觉* 相似，那么理解诸如响应式这样的复杂模型就会变得轻松。
- en: Before we can get into the reactive engine, we need to revisit the imperative
    and reactive models. Doing so allows us an opportunity to appreciate how they’re
    unified with Quarkus. For anyone already familiar with imperative and reactive
    models, how they work, and the benefits and disadvantages of each, feel free to
    skip ahead to [“Unification of Reactive and Imperative”](#quarkus-reactive::unification).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解响应式引擎之前，我们需要重新审视命令式和响应式模型。这样做可以让我们有机会欣赏它们如何与 Quarkus 统一。对于那些已经熟悉命令式和响应式模型、它们的工作原理以及各自的优缺点的人来说，可以直接跳到
    [“命令式和响应式的统一”](#quarkus-reactive::unification)。
- en: You might worry we’re repeating previously covered information. We might be
    a little, but it’s all geared toward reinforcing how the two models impact the
    way applications are developed—and as a result, how frameworks differ depending
    on the model they offer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能担心我们在重复之前涵盖过的信息。我们可能有点重复，但这都是为了加强这两种模型如何影响应用程序开发方式以及因此框架在提供的模型上有何不同。
- en: First up is the imperative model, which most Java developers likely started
    their careers using.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是命令式模型，大多数 Java 开发人员可能是从这个模型开始他们的职业生涯的。
- en: The Imperative Model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式模型
- en: When using the *imperative model*, you may not even be aware of its name. So
    what is the imperative model? It alters a program’s state with a defined sequence
    of commands. One command is executed after another until all commands are executed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *命令式模型* 时，你甚至可能不知道它的名字。那么什么是命令式模型？它通过一系列定义好的命令来改变程序的状态。一个命令在另一个命令之后执行，直到所有命令都执行完毕。
- en: '[Figure 6-1](#image:imperative-commands-result-10) shows a sequence of mathematical
    commands, executed in succession, until the result (in this case 10 if we start
    from 0, is produced). As you can see in the imperative model, defining the proper
    sequence is critical to achieving the desired result, 10.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#image:imperative-commands-result-10) 展示了一系列数学命令的顺序执行，直到产生结果（在本例中，如果我们从
    0 开始，结果为 10）。正如你在命令式模型中所看到的，定义正确的顺序对于实现所需的结果 10 至关重要。'
- en: '![Imperative commands with result 10](assets/rsij_0601.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![带有结果 10 的命令](assets/rsij_0601.png)'
- en: Figure 6-1\. Imperative commands with result 10
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 带有结果 10 的命令
- en: '[Figure 6-2](#image:imperative-commands-result-7-5) shows the exact same commands,
    but in a different sequence.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-2](#image:imperative-commands-result-7-5) 展示了完全相同的命令，但顺序不同。'
- en: '![Imperative commands with result 7.5](assets/rsij_0602.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![带有结果 7.5 的命令](assets/rsij_0602.png)'
- en: Figure 6-2\. Imperative commands with result 7.5
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 带有结果 7.5 的命令
- en: As you see, the sequence of commands, in the imperative mode, is just as important
    as the commands themselves. Modifying the sequence results in an entirely different
    program output. An imperative program can be considered the process of getting
    from A to B, when we already know what A and B need to be. The developer needs
    to define only the steps between A and B in the correct sequence to achieve the
    desired result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在命令式模式下，命令的顺序与命令本身一样重要。修改顺序会导致完全不同的程序输出。命令式程序可以被视为从 A 到 B 的过程，当我们已经知道
    A 和 B 需要什么时。开发人员只需按照正确的顺序定义从 A 到 B 的步骤，就能实现所需的结果。
- en: In imperative programs, we have a defined input and output, and, in addition,
    we know the steps needed to get from A to B. For these two reasons, imperative
    programs are easily reasoned about. When we have a defined input, what we know
    the output should be, and the defined steps to get there, writing tests is a lot
    easier because the permutations of what can happen are limited and determinable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式程序中，我们有一个明确的输入和输出，并且我们知道从 A 到 B 所需的步骤。因此，命令式程序很容易理解。当我们有一个明确的输入，知道输出应该是什么，并且知道到达那里的定义步骤时，编写测试就变得更容易，因为可能发生的情况有限且可确定。
- en: What are some other aspects of the imperative programming model we need to be
    aware of? As imperative relies on a sequence of commands, resource utilization
    will always be a primary concern. In the example shown in [Figure 6-1](#image:imperative-commands-result-10),
    we’re not going to need a large amount of resources to perform basic mathematical
    calculations. However, if we replaced all those operations with database calls
    retrieving a few hundred records each, the impacts begin adding up quickly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程模型的其他一些方面是什么？由于命令式依赖于一系列命令，资源利用率将始终是主要关注点。在 [图 6-1](#image:imperative-commands-result-10)
    中显示的示例中，我们不需要大量资源来执行基本的数学计算。但是，如果我们将所有这些操作替换为检索几百条记录的数据库调用，那么影响将很快累积起来。
- en: The impacts we’re talking about are related to the threading model for imperative
    programming. If we have our sequence of database operations using a single I/O
    thread, the same I/O thread handling the HTTP request (not realistic but useful
    for illustrative purposes), only one request can be processed at any point in
    time. We introduced the I/O thread in [Chapter 5](ch05.html#reactive-programming).
    Moreover, as the sequence of the imperative program is fixed, each command must
    complete before the next one can commence. What does that look like?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论的影响与命令式编程的线程模型有关。如果我们的数据库操作序列使用单个 I/O 线程，同一个 I/O 线程处理 HTTP 请求（虽然不现实但对说明有用），那么在任何时候只能处理一个请求。我们在
    [第 5 章](ch05.html#reactive-programming) 中介绍了 I/O 线程。此外，由于命令式程序的序列是固定的，每个命令必须在下一个命令开始之前完成。这是什么样子？
- en: Though contrived, [Figure 6-3](#image:database-retrieval-single-thread) illustrates
    how each step in the database program must complete before the next can commence.
    More importantly, any subsequent request can begin only when the one being processed
    is finished. In this situation, the number of concurrent requests we can process
    is limited by the number of I/O threads we give the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是人为的，但 [图 6-3](#image:database-retrieval-single-thread) 说明了数据库程序中每个步骤必须在下一个步骤开始之前完成。更重要的是，只有处理的请求完成时，才能开始后续的请求。在这种情况下，我们能够处理的并发请求数量受到我们为应用程序提供的
    I/O 线程数量的限制。
- en: '![Database program on single I/O thread](assets/rsij_0603.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![单个 I/O 线程上的数据库程序](assets/rsij_0603.png)'
- en: Figure 6-3\. Database program on single I/O thread
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 单个 I/O 线程上的数据库程序
- en: Now, as depicted in [Figure 6-4](#image:database-retrieval-multiple-threads),
    we will be generous and provide the same application two I/O threads!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如 [图 6-4](#image:database-retrieval-multiple-threads) 所示，我们会慷慨地为同一个应用提供两个
    I/O 线程！
- en: '![Database program on multiple I/O threads](assets/rsij_0604.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![多个 I/O 线程上的数据库程序](assets/rsij_0604.png)'
- en: Figure 6-4\. Database program on multiple I/O threads
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 多个 I/O 线程上的数据库程序
- en: We can process two concurrent requests, but no more than that with only two
    I/O threads. Being able to handle only a single request per I/O thread is not
    great, so let’s dive deeper into what’s going on inside.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以处理两个并发请求，但仅有两个 I/O 线程，不会有更多。只能处理每个 I/O 线程的单个请求并不理想，所以让我们深入了解内部发生了什么。 '
- en: Both the *Retrieve DB records* and *Write new DB records* commands have periods
    of time when the command itself is not performing any work, shown as the lighter
    section in [Figure 6-5](#image:database-retrieval-thread-delays). In between sending
    a request to the database and receiving the response, what is the I/O thread doing?
    In this situation, absolutely nothing! The I/O thread sits there waiting for the
    response from the database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*检索 DB 记录* 和 *写入新的 DB 记录* 命令都有一段时间的空闲，在 [图 6-5](#image:database-retrieval-thread-delays)
    中显示为较浅的部分。在发送请求到数据库和接收响应之间，I/O 线程在做什么？在这种情况下，绝对什么都不做！I/O 线程就坐在那里等待数据库的响应。'
- en: '![Database program I/O thread delays](assets/rsij_0605.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![I/O 线程延迟的数据库程序](assets/rsij_0605.png)'
- en: Figure 6-5\. Database program I/O thread delays
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. I/O 线程延迟的数据库程序
- en: Why does it do nothing? Could an I/O thread perform other work while waiting?
    As we mentioned earlier, imperative programming requires an ordered sequence of
    commands. Because *Retrieve DB records* is still running during the wait period,
    an I/O thread does not know there is time to perform other work. This is why imperative
    programming is often tied with synchronous execution, and by default synchronous
    is the execution model for imperative programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它什么也没做？I/O 线程在等待时能否执行其他工作？正如我们之前提到的，命令式编程需要按顺序执行命令。因为在等待期间仍在运行*检索数据库记录*，所以
    I/O 线程不知道是否有时间执行其他工作。这就是为什么命令式编程通常与同步执行结合，并且默认情况下同步是命令式编程的执行模型的原因。
- en: Some might wonder whether an I/O thread waiting is a big deal. The time an I/O
    thread waits for a command to complete could be several seconds or longer. An
    imperative program taking about a second to complete all its steps may be OK,
    but it doesn’t take many periods of I/O threads waiting to explode the total response
    time to many seconds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想知道 I/O 线程等待是否很重要。I/O 线程等待命令完成的时间可能是几秒钟甚至更长。一个命令式程序大约需要一秒钟完成所有步骤可能还可以接受，但是如果
    I/O 线程等待的周期增多，将会显著增加总响应时间。
- en: The expanded time to complete an imperative program has several effects. Increased
    execution time on an I/O thread leads to a reduction in the number of requests
    being processed in a given period of time. There are additional impacts on the
    resources required to buffer in memory any incoming requests that are waiting
    on I/O threads to become available to begin processing. These resource impacts
    can cause significant issues with the overall performance of an application. If
    an application is dealing with a few hundred, or even thousand, users, it may
    not be noticeable, especially if few are concurrent users. However, tens of thousands
    of users, many concurrently, will show these problems to their users in failed
    connections, time-outs, errors, and any number of possible problems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 增加命令式程序完成时间会产生几个影响。I/O 线程上的增加执行时间导致在给定时间段内处理的请求数量减少。还会对内存中缓冲任何等待 I/O 线程可用的传入请求的资源产生额外影响。这些资源影响可能会对应用程序的整体性能造成显著问题。如果一个应用程序处理数百甚至数千个用户，特别是并发用户较少时，可能不会引起注意。然而，处理成千上万个并发用户时会在用户端显示出问题，如连接失败、超时、错误以及各种可能的问题。
- en: There are other ways to break the synchronous and blocking nature of an imperative
    program. We can use `ExecutorService` to move work from the I/O thread onto a
    separate worker pool thread. Or we can use `@Suspended` and `AsyncResponse` with
    JAX-RS Resources to delegate work to a worker pool of threads, enabling the HTTP
    request to be suspended from the I/O thread until a response is set on `AsyncResponse`.
    Suspending HTTP requests waiting for a response facilitates processing of additional
    HTTP requests on the I/O thread while others are waiting for a processing response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要打破命令式程序的同步和阻塞特性，还有其他方法。我们可以使用`ExecutorService`将工作从 I/O 线程移动到单独的工作池线程中。或者我们可以使用`@Suspended`和`AsyncResponse`与
    JAX-RS 资源来将工作委托给工作池的线程，使得 HTTP 请求可以从 I/O 线程中暂停，直到在`AsyncResponse`上设置了响应。暂停 HTTP
    请求等待响应有助于在其他请求等待处理响应时在 I/O 线程上处理额外的 HTTP 请求。
- en: Though these approaches work, the complexity of code increases without a significant
    benefit in throughput as we’re still I/O thread limited—not quite to the level
    of a request per thread when using `@Suspended`, but not significantly more either.
    How does the reactive model differ?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些方法可行，但是代码复杂度增加了，而吞吐量的显著增加并未体现出来，因为我们仍然受制于 I/O 线程的限制——虽然使用`@Suspended`时不完全是每个线程一个请求的级别，但也没有显著提升。那么，响应式模型有何不同呢？
- en: The Reactive Model
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式模型
- en: The *reactive model* is built around the notion of continuations and nonblocking
    I/O, as we detailed in [“Asynchronous Code and Patterns”](ch05.html#reactive-programming:async-code-patterns).
    As mentioned previously, this approach significantly increases the level of concurrency,
    enabling many more requests to be processed in parallel. However, it’s not a free
    ride because it requires additional thought on the part of a developer to develop
    an application built around these principles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应式模型*围绕着延续和非阻塞 I/O 的概念构建，正如我们在 [“异步代码和模式”](ch05.html#reactive-programming:async-code-patterns)
    中详细说明的那样。正如前文提到的，这种方法显著增加了并发水平，可以同时处理更多的请求。然而，这并不是免费的，因为它需要开发人员在这些原则基础上开发应用程序时进行额外的思考。'
- en: Taking our previous database example, what would it look like to remove the
    I/O thread wait times to improve the concurrency? Take a look at [Figure 6-6](#image:database-retrieval-reactive).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的数据库示例为例，如果要删除I/O线程的等待时间以提高并发性能，会是什么样子？看看 [图 6-6](#image:database-retrieval-reactive)。
- en: '![Reactive database program on I/O thread](assets/rsij_0606.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![I/O 线程上的反应式数据库程序](assets/rsij_0606.png)'
- en: Figure 6-6\. Reactive database program on I/O thread
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. I/O 线程上的反应式数据库程序
- en: Here, we can see that, instead of an I/O thread waiting, it begins processing
    another incoming request. It continues to do so until it’s been notified that
    a database response is ready for processing. How do we achieve this separation?
    We provide a continuation to process the database response. The continuation is
    added to the queue of methods to execute on the I/O thread after the database
    response is received. Likewise, the single command to process the database records
    is split into smaller methods to help with the concurrency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，I/O线程不再等待，而是开始处理另一个传入的请求。直到收到数据库响应就会继续这样做。我们如何实现这种分离？我们提供一个延续来处理数据库响应。在接收到数据库响应后，将延续添加到要在I/O线程上执行的方法队列中。同样地，处理数据库记录的单个命令被分割成更小的方法，以帮助处理并发性。
- en: '[Figure 6-6](#image:database-retrieval-reactive) shows how a reactive model
    utilizing continuations can facilitate the removal of I/O thread wait time and
    increase the number of requests processed concurrently. As you’ve seen, we developers
    need to adjust how programs are developed to *align* with the reactive model.
    We need to break work into smaller chunks, but most importantly, modify interactions
    with anything external to the application into separate request and response handling.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-6](#image:database-retrieval-reactive)展示了利用延续实现的反应式模型如何减少I/O线程等待时间并增加同时处理的请求数量。正如您所见，作为开发者，我们需要调整程序开发方式，以*与*反应式模型保持一致。我们需要将工作分解为较小的块，但更重要的是，修改与应用程序外部的任何交互为单独的请求和响应处理。'
- en: In [Figure 6-6](#image:database-retrieval-reactive), we approximated how pieces
    of a program could be segmented to prevent the I/O thread from waiting or being
    blocked. Quarkus uses an *event loop*, as discussed in [“Reactor Pattern and Event
    Loop”](ch04.html#reactive-system::reactor-pattern-event-loop), to implement the
    reactive model. The event loop can visually be represented as shown previously
    in [Figure 4-7](ch04.html#image:event-loop).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-6](#image:database-retrieval-reactive)中，我们近似展示了程序的各个部分如何被分割，以防止I/O线程等待或被阻塞。Quarkus使用了*事件循环*，如[“Reactor
    Pattern and Event Loop”](ch04.html#reactive-system::reactor-pattern-event-loop)中讨论的那样，来实现反应式模型。事件循环可以像之前在
    [图 4-7](ch04.html#image:event-loop)中展示的那样被视觉化表示。
- en: We’ve discussed some hugely beneficial aspects of the reactive model, but nothing
    comes for free. With the reactive model needing to separate code execution, as
    opposed to the imperative model in which everything is sequential, complexity
    is introduced in the ability to understand the entirety of a program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了反应式模型的一些极其有益的方面，但没有任何东西是免费的。随着反应式模型需要将代码执行分离，与命令式模型相反，其中一切都是顺序执行，会在理解程序整体性方面引入复杂性。
- en: A program is no longer a sequenced set of steps, but a series of handlers executing
    at different points in time with no predetermined order. Though continuations
    can be guaranteed to occur after they were triggered, there is no ordering among
    various asynchronous invocations within a single request, or among multiple requests.
    This shift requires an alteration in thinking by developers toward event passing,
    with the triggering of associated event handlers. No longer is it a sequence of
    commands called one after another in code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不再是一系列顺序步骤，而是一系列在不同时间点执行的处理程序，没有预定的顺序。虽然延续可以保证在触发后发生，但在单个请求内的各种异步调用之间，或在多个请求之间，没有任何排序。这种转变要求开发者改变对事件传递的思考方式，并触发相关事件处理程序。代码中不再是一系列依次调用的命令序列。
- en: Unification of Reactive and Imperative
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式与命令式的统一
- en: 'What do we mean by Quarkus unifying reactive and imperative? We don’t mean
    being able to ignore the complexities of reactive or expecting imperative to provide
    high levels of concurrency. We *do* mean the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Quarkus统一反应式和命令式的含义？我们不是指能够忽略反应式的复杂性或期望命令式提供高并发性能。我们*确实*指的是以下内容：
- en: Quarkus’s reactive core nonblocking I/O is key to any extension built on top.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus的反应式核心非阻塞I/O对于任何构建在其上的扩展都至关重要。
- en: Quarkus offers a framework of extensions built on the performance of the Eclipse
    Vert.x toolkit, the reactive engine.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus基于Eclipse Vert.x工具包的性能提供了一个框架扩展，这是响应式引擎。
- en: A developer’s choice of imperative or reactive is an API choice, and not a framework
    one.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者选择命令式还是响应式是一个API选择，而不是框架选择。
- en: Often when choosing to develop an application, an *up-front* choice needs to
    be made as to whether to use reactive or imperative programming. This decision
    requires much forethought by developers and architects in terms of the skills
    required by the team building the application, the current business requirements
    for the application, as well as the final architecture of the application. We
    developers find choosing a specific technology stack one of the most difficult
    decisions to make. We always want to consider the future needs of the application,
    even if we don’t know what those needs are concretely. No matter how we try, there
    will always be new requirements or unforeseen problems, requiring a change in
    architecture or even design.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择开发应用程序时，通常需要做一个*前期*选择，是使用响应式还是命令式编程。这个决策需要开发人员和架构师在团队技能、当前业务需求以及最终应用架构方面进行深思熟虑。我们开发者发现选择特定技术栈是最困难的决定之一。即使我们不知道具体的未来需求，我们总是希望考虑应用的未来需求。无论我们如何努力，总会出现新的需求或未预见的问题，需要改变架构甚至设计。
- en: We feel more comfortable about a decision when it doesn’t box us in, offering
    ways to shift and alter the way an application works as needs change. This is
    a huge advantage with Quarkus. When we choose Quarkus, and the unification of
    imperative and reactive models, we’re free to pick one or the other, a mix of
    the two, or even switch parts of an application between the models over time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用需要在需要变更时，提供不受限制的选择方式来改变应用的工作方式时，我们感到更加自在。这是使用Quarkus的一个巨大优势。当我们选择Quarkus及其命令式和响应式模型的统一时，我们可以自由选择其中之一，两者混合，甚至随时间变更应用的部分模型。
- en: How does Quarkus support reactive or imperative models seamlessly? Supporting
    both models seamlessly is the key foundation to everything Quarkus offers. Built
    on the foundation of Vert.x, Quarkus has a routing layer enabling either model.
    This is how the layers work together when we’ve deployed reactive code, assuming
    an HTTP request is being processed ([Figure 6-7](#image:unify-model-reactive)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus如何无缝支持响应式或命令式模型？支持两种模型的无缝集成是Quarkus提供一切的关键基础。建立在Vert.x基础上，Quarkus具有路由层，可以启用任一模型。这是我们部署响应式代码时各层如何协同工作的方式，假设正在处理HTTP请求（[图 6-7](#image:unify-model-reactive)）。
- en: '![Quarkus reactive model](assets/rsij_0607.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus响应式模型](assets/rsij_0607.png)'
- en: Figure 6-7\. Quarkus reactive model
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. Quarkus响应式模型
- en: We see in [Figure 6-7](#image:unify-model-reactive) how a request is received
    by the Vert.x HTTP server, passes through the routing layer, and our reactive
    code executes. All these interactions occur on the I/O thread; a worker thread
    is not needed. As already mentioned, having code execute on the I/O thread provides
    the highest level of concurrency.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[图 6-7](#image:unify-model-reactive)中看到请求如何被Vert.x HTTP服务器接收，通过路由层，并执行我们的响应式代码。所有这些交互都发生在I/O线程上；不需要工作线程。正如前面提到的，使代码在I/O线程上执行提供了最高级别的并发性。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [Figure 6-7](#image:unify-model-reactive), only a single HTTP request is
    being processed. If there were multiple requests, those executions would be interleaved
    on the I/O thread.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-7](#image:unify-model-reactive)中，只有一个单一的HTTP请求正在处理。如果有多个请求，则这些执行将在I/O线程上交错执行。
- en: You might be wondering how executing imperative code alters the behavior—take
    a look at [Figure 6-8](#image:unify-model-imperative).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会好奇，执行命令式代码如何改变行为—查看[图 6-8](#image:unify-model-imperative)。
- en: '![Quarkus imperative model](assets/rsij_0608.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus命令式模型](assets/rsij_0608.png)'
- en: Figure 6-8\. Quarkus imperative model
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. Quarkus命令式模型
- en: You can see that the model is not significantly different. The biggest change
    is that our code, now imperative in nature, is executed on a worker thread and
    not the I/O thread. In this way, Quarkus can execute imperative code, a series
    of sequential commands, without impacting the concurrency of the I/O thread. Quarkus
    has *offloaded* the imperative execution to a worker.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到模型没有显著的不同。最大的变化在于我们的代码现在是命令式的性质，会在工作线程上执行，而不是I/O线程上。这样，Quarkus可以执行命令式代码，即一系列顺序命令，而不影响I/O线程的并发性。Quarkus已经*转移*了命令式执行到工作线程上。
- en: The process of offloading to a worker thread comes with a cost, however. Every
    time we execute on a worker thread, a context switch, before and after execution,
    is necessary. In [Figure 6-8](#image:unify-model-imperative), we represent this
    switch as a circle on the boundary between the I/O and worker threads. These context
    switches cost time and resources to perform the switch and store the information
    in a new thread.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将任务转移到工作线程的过程是有代价的。每当我们在工作线程上执行时，都需要进行一次上下文切换，在执行之前和之后都是如此。在[图6-8](#image:unify-model-imperative)中，我们将这种切换表示为I/O线程和工作线程之间边界上的一个圆圈。这些上下文切换会消耗时间和资源，用于执行切换并在新线程中存储信息。
- en: We’ve seen how the two models operate on Quarkus, but what about when we unify
    them? For example, if we have a reactive application needing to execute a piece
    of blocking code, how can we do that without blocking the I/O thread? In [Figure 6-9](#image:unify-model-combined),
    we see our code executing on both the I/O and worker threads!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到这两种模型在Quarkus上的运行方式，但是当我们将它们统一起来时会怎样呢？例如，如果我们有一个需要执行一段阻塞代码的响应式应用程序，我们如何在不阻塞I/O线程的情况下做到这一点？在[图6-9](#image:unify-model-combined)中，我们看到我们的代码同时在I/O线程和工作线程上执行！
- en: '![Quarkus reactive and imperative model](assets/rsij_0609.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus响应式和命令式模型](assets/rsij_0609.png)'
- en: Figure 6-9\. Quarkus reactive and imperative model
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-9\. Quarkus响应式和命令式模型
- en: When reactive code is executed, it’s on the I/O thread, but any imperative code
    is executed on a worker thread. Quarkus handles all of this for developers without
    them needing to create `Executors` or `Threads`, or needing to manage them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行响应式代码时，它在I/O线程上运行，但任何命令式代码都在工作线程上执行。Quarkus为开发人员处理所有这些，而无需他们创建`Executors`或`Threads`，也无需管理它们。
- en: '[Figure 6-9](#image:unify-model-combined) is a visualization of the *proactor*
    pattern we defined in [“Reactor Pattern and Event Loop”](ch04.html#reactive-system::reactor-pattern-event-loop).
    Nonblocking and blocking handlers can coexist, as long as we offload blocking
    execution onto worker threads and invoke continuations when a blocking handler
    completes.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-9](#image:unify-model-combined)是我们在[“Reactor Pattern and Event Loop”](ch04.html#reactive-system::reactor-pattern-event-loop)中定义的*proactor*模式的可视化展示。非阻塞和阻塞处理程序可以共存，只要我们将阻塞执行委托给工作线程，并在阻塞处理程序完成时调用继续执行。'
- en: The proactor pattern unifies imperative and reactive code in Quarkus. Anyone
    familiar with developing reactive applications knows that sometimes it’s necessary
    to write code in a blocking, or sequential, manner. Quarkus’s unification allows
    us to delegate such execution onto a worker thread, by using `@Blocking`, which
    we cover for HTTP in [Chapter 8](ch08.html#http) and Reactive Messaging in [Chapter 10](ch10.html#messaging).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: proactor模式在Quarkus中统一了命令式和响应式代码。熟悉开发响应式应用程序的人都知道，有时需要以阻塞或顺序的方式编写代码。Quarkus的统一允许我们将这样的执行委托给工作线程，通过使用`@Blocking`来处理HTTP中的内容（我们在[第8章](ch08.html#http)中介绍），以及在Reactive
    Messaging中的内容（我们在[第10章](ch10.html#messaging)中介绍）。
- en: Utilizing the reactive model, and thus the I/O thread, for as much work as possible
    has an added benefit. We minimize the amount of context switching performed when
    delegating execution to a worker thread. Anytime execution of the same request
    moves between threads, from the I/O to worker thread, or vice versa, costs are
    associated with the switch. Any objects associated with the request need to be
    available from the new thread, costing time and resources to move them, as well
    as resource costs for additional threads.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能利用响应式模型，因此利用I/O线程完成尽可能多的工作具有额外的好处。当我们将执行委托给工作线程时，尽可能减少上下文切换的次数。任何时候同一请求的执行从一个线程（如I/O线程）移动到另一个线程（如工作线程），或反之，都会带来一定的成本。与请求相关联的任何对象需要从新线程中可用，这会消耗时间和资源来移动它们，还需要为额外的线程分配资源成本。
- en: We’ve talked a lot about how the models are unified in Quarkus, but what extensions
    use these models? RESTEasy Reactive, covered in [Chapter 8](ch08.html#http), and
    Reactive Messaging, in [Chapter 10](ch10.html#messaging), both utilize the reactive
    model. The classic RESTEasy and Spring controller both use the imperative model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了Quarkus中这些模型的统一方式，但是有哪些扩展使用了这些模型呢？在[第8章](ch08.html#http)中涵盖的RESTEasy
    Reactive和[第10章](ch10.html#messaging)中的Reactive Messaging都使用了响应式模型。经典的RESTEasy和Spring控制器则使用命令式模型。
- en: A Reactive Engine
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个响应式引擎
- en: If you have written reactive programs or done any research into Reactive, you
    are likely aware of the Vert.x toolkit. As mentioned before, the Quarkus reactive
    engine utilizes Vert.x. In addition to Vert.x, as well as Netty, the routing layer
    of Quarkus forms the outer layer of the reactive engine. It’s the integration
    piece for extensions, coordinating the offloading of blocking handlers onto worker
    threads, and the execution of their continuations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写过响应式程序或对 Reactive 进行过任何研究，您可能已经了解到了 Vert.x 工具包。如前所述，Quarkus 响应式引擎利用了 Vert.x。除了
    Vert.x 和 Netty 外，Quarkus 的路由层形成了响应式引擎的外层。它是扩展的集成部分，协调着将阻塞处理程序卸载到工作线程上，以及执行它们的延续。
- en: In addition, all the reactive clients are built on top of the reactive engine
    to utilize the nonblocking handling. Reactive applications are no longer reactive
    after they use blocking clients, a key aspect often overlooked by developers.
    Quarkus endeavors to have all clients that an application might need built on
    the reactive engine, for true reactive integration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有的响应式客户端都是建立在响应式引擎之上的，以利用非阻塞处理。一旦使用阻塞客户端，响应式应用程序就不再是响应式的，这是开发人员经常忽视的一个关键方面。Quarkus
    努力确保应用程序可能需要的所有客户端都建立在响应式引擎上，以实现真正的响应式集成。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, everything in Quarkus is reactive. Developers must decide whether
    they want reactive or imperative. What do we mean by *everything*? It includes
    HTTP handling, event-driven applications with AMQP and Kafka, and *everything*
    Quarkus offers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Quarkus 中的所有内容都是响应式的。开发人员必须决定他们想要响应式还是命令式。我们所说的 *所有* 是什么意思？它包括 HTTP 处理、使用
    AMQP 和 Kafka 的事件驱动应用程序，以及 Quarkus 提供的 *所有* 内容。
- en: A Reactive Programming Model
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种响应式编程模型
- en: SmallRye Mutiny is the reactive programming library of Quarkus. You already
    learned about it in [“Reactive Programming”](ch05.html#reactive-programming::reactive-programming),
    and we will learn even more in [Chapter 7](ch07.html#mutiny), so we won’t cover
    too much detail here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SmallRye Mutiny 是 Quarkus 的响应式编程库。您已经在 [“Reactive Programming”](ch05.html#reactive-programming::reactive-programming)
    中了解了它，我们将在 [第 7 章](ch07.html#mutiny) 中学到更多内容，因此我们不会在这里详细介绍。
- en: 'In short, Mutiny is built around three key aspects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Mutiny 围绕三个关键方面构建：
- en: Event-driven
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动
- en: Listening to events from the stream and handling them appropriately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 监听来自流的事件并适当处理它们。
- en: Easily navigable API
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 易于导航的 API
- en: Navigating the API is driven by an event type and the available options for
    that event.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API 的导航由事件类型和该事件的可用选项驱动。
- en: Only two types
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仅两种类型
- en: '`Multi` and `Uni` can handle any desired asynchronous actions.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Multi` 和 `Uni` 可以处理任何所需的异步操作。'
- en: One point to note is the laziness of the Mutiny types. Events won’t begin flowing
    through the data streams until a subscriber requests them. This is a fantastic
    feature to prevent streams from consuming resources if nothing is listening, but
    developers do need to be aware of this, so we don’t forget to subscribe!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意的是 Mutiny 类型的惰性。除非订阅者请求它们，否则事件不会开始流经数据流。这是一个很棒的功能，可以防止流在没有人监听时消耗资源，但开发人员需要注意这一点，以免忘记订阅！
- en: All Quarkus reactive APIs use `Multi` and `Uni`. This approach facilitates the
    seamless integration of Quarkus extensions with reactive programming and Mutiny.
    Let’s see examples of using Mutiny.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Quarkus 响应式 API 都使用 `Multi` 和 `Uni`。这种方法有助于将 Quarkus 扩展与响应式编程和 Mutiny 无缝集成。让我们看看使用
    Mutiny 的示例。
- en: A reactive application with Quarkus using the PostgreSQL reactive client retrieves
    `Fruit` objects from the database with `Multi`, as shown in [Example 6-1](#quarkus-reactive::mutiny-data).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 响应式客户端的 Quarkus 响应式应用程序从数据库中使用 `Multi` 检索 `Fruit` 对象，如 [示例 6-1](#quarkus-reactive::mutiny-data)
    所示。
- en: Example 6-1\. Reactive Mutiny client
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 响应式 Mutiny 客户端
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_quarkus__reactive_engine_CO1-1)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_quarkus__reactive_engine_CO1-1)'
- en: '`client` is an instance of `PgPool`, the PostgreSQL reactive client built with
    Mutiny and Vert.x.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`client` 是 `PgPool` 的一个实例，是使用 Mutiny 和 Vert.x 构建的 PostgreSQL 响应式客户端。'
- en: '[![2](assets/2.png)](#co_quarkus__reactive_engine_CO1-2)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_quarkus__reactive_engine_CO1-2)'
- en: When a `RowSet` item is received, transform the single `RowSet` into a `Multi<Row>`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到一个 `RowSet` 项时，将单个 `RowSet` 转换为 `Multi<Row>`。
- en: '[![3](assets/3.png)](#co_quarkus__reactive_engine_CO1-3)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_quarkus__reactive_engine_CO1-3)'
- en: Convert each `Row` in `Multi` to a `Fruit` instance. The result of the execution
    is `Multi<Fruit>`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Multi` 中的每个 `Row` 转换为一个 `Fruit` 实例。执行的结果是 `Multi<Fruit>`。
- en: Given we’re writing about Reactive in this book, all the remaining chapters
    have examples utilizing Mutiny in many situations. We present reactive HTTP endpoints
    in [Chapter 8](ch08.html#http) and their consumption in [Chapter 12](ch12.html#http-client).
    We cover reactive data access with Quarkus and Mutiny in [Chapter 9](ch09.html#data),
    including many examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们在本书中讨论响应式，所有剩余章节都有使用Mutiny在多种情况下的示例。我们在[第8章](ch08.html#http)中介绍了响应式HTTP端点及其在[第12章](ch12.html#http-client)中的消费。我们还包括了Quarkus和Mutiny在[第9章](ch09.html#data)中的响应式数据访问，包括许多示例。
- en: Event-Driven Architecture with Quarkus
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus的事件驱动架构
- en: Though building reactive applications with Quarkus is great, performant, and
    fun, we want to do more than build a single application. We need a reactive system,
    as covered in [Chapter 4](ch04.html#reactive-systems), combining smaller applications
    into a coordinated distributed system. To support such an architecture, Quarkus
    must receive and produce events, an event-driven architecture! Quarkus achieves
    this by using Reactive Messaging, as shown in [Example 6-2](#quarkus-reactive::messaging).
    Reactive Messaging integrates with various messaging technologies, such as Apache
    Kafka, AMQP, and others, with annotations for developers to specify whether a
    method receives or produces events.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用Quarkus构建响应式应用程序很棒、高效且有趣，但我们希望不仅仅是构建单个应用程序。我们需要一个响应式系统，正如在[第4章](ch04.html#reactive-systems)中所述，将小型应用程序组合成一个协调的分布式系统。为了支持这样的架构，Quarkus必须接收和产生事件，这就是事件驱动架构！Quarkus通过使用响应式消息来实现这一点，如[示例6-2](#quarkus-reactive::messaging)所示。响应式消息集成了各种消息传递技术，如Apache
    Kafka、AMQP等，开发人员可以通过注解指定方法是接收还是产生事件。
- en: Example 6-2\. Reactive Messaging
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-2. 响应式消息
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_quarkus__reactive_engine_CO2-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_quarkus__reactive_engine_CO2-1)'
- en: Read messages from the `prices` channel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从`prices`通道中读取消息。
- en: '[![2](assets/2.png)](#co_quarkus__reactive_engine_CO2-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_quarkus__reactive_engine_CO2-2)'
- en: Transform each `Price` into a `Quote`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个`Price`转换为一个`Quote`。
- en: The offered development model allows consuming, transforming, and generating
    messages easily. The `@Incoming` annotation denotes the consumption of a *channel*.
    Reactive Messaging invokes the method for each transiting `Price` from the configured
    channel. The `@Outgoing` annotation indicates in which channel the results are
    written.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的开发模型允许轻松消费、转换和生成消息。`@Incoming`注解表示消费*通道*中传递的每个`Price`。响应式消息在配置的通道中为每个通过的`Price`调用方法。`@Outgoing`注解指示将结果写入的通道。
- en: Full details of Reactive Messaging are covered in [Chapter 10](ch10.html#messaging).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有关响应式消息的完整详细信息，请参阅[第10章](ch10.html#messaging)。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the imperative model, a series of sequential commands,
    and the reactive model, utilizing continuations and nonblocking I/O.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了命令式模型，一系列顺序命令，以及响应式模型，利用续体和非阻塞I/O。
- en: 'We have seen the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了以下内容：
- en: How the two models work with threads (in Figures [6-8](#image:unify-model-imperative),
    [6-7](#image:unify-model-reactive), and [6-9](#image:unify-model-combined)), providing
    improved concurrency with the reactive model.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图[6-8](#image:unify-model-imperative)、[6-7](#image:unify-model-reactive)和[6-9](#image:unify-model-combined)展示了两种模型如何使用线程，通过响应式模型提供了改进的并发性能。
- en: How Quarkus unifies these models to allow developers to grow their applications,
    introducing reactive aspects, as it grows and expands without the need to switch
    frameworks.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus如何统一这些模型，允许开发人员在不切换框架的情况下增强应用程序，引入响应式方面，随着应用程序的增长和扩展。
- en: How we can use reactive programming in Quarkus.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在Quarkus中使用响应式编程。
- en: In the coming chapters, we explore the various reactive aspects of Quarkus,
    such as HTTP and RESTEasy Reactive in [Chapter 8](ch08.html#http), and reactive
    data access in [Chapter 9](ch09.html#data). But first, let’s have a deeper look
    into the Mutiny reactive programming API.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨Quarkus的各种响应式方面，如[第8章](ch08.html#http)中的HTTP和RESTEasy Reactive，以及[第9章](ch09.html#data)中的响应式数据访问。但首先，让我们深入了解Mutiny响应式编程API。
